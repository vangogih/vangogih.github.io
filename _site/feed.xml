<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.6.2">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2018-03-22T19:38:02+03:00</updated><id>http://localhost:4000/</id><title type="html">Блог Маслёнка</title><subtitle>All contents under (CC) BY-NC-SA license, unless otherwise noted. </subtitle><entry><title type="html">Unity3D Урок №2. Построение графика. Математическая визуализация</title><link href="http://localhost:4000/jekyll/update/2018/03/18/Building-Graph.html" rel="alternate" type="text/html" title="Unity3D Урок №2. Построение графика. Математическая визуализация" /><published>2018-03-18T19:00:00+03:00</published><updated>2018-03-18T19:00:00+03:00</updated><id>http://localhost:4000/jekyll/update/2018/03/18/Building-Graph</id><content type="html" xml:base="http://localhost:4000/jekyll/update/2018/03/18/Building-Graph.html">&lt;h2 id=&quot;Построение-графика-Математическая-визуализация&quot;&gt;&lt;strong&gt;Построение графика. Математическая визуализация&lt;/strong&gt;&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;Создадим префаб.&lt;/li&gt;
  &lt;li&gt;Создадим линию из кубов.&lt;/li&gt;
  &lt;li&gt;Отобразим математическую функцию.&lt;/li&gt;
  &lt;li&gt;Создадим свой собственный шейдер.&lt;/li&gt;
  &lt;li&gt;Анимируем наш график.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;В этом уроке мы будем использовать игровые объекты для построения графиков по математическим формулам. Мы также сделаем функцию, зависящую от времени, в результате чего получится анимация графика.&lt;/p&gt;

&lt;p&gt;Этот урок предполагает, что вы ознакомились с уроком &lt;a href=&quot;/jekyll/update/2018/01/17/Game-Objects-and-Scripts.html&quot;&gt;Игровые объекты и скрипты&lt;/a&gt;. Этот урок, как и прошлый был сделан в Unity версии 2017.1.0.&lt;/p&gt;

&lt;center&gt;&lt;img src=&quot;\images\2018\02\BuildingGraph\tutorial-image.jpg&quot; /&gt;&lt;/center&gt;
&lt;p&gt;&lt;em&gt;&lt;center&gt;Синусоида из кубов&lt;/center&gt;&lt;/em&gt;&lt;/p&gt;

&lt;h2 id=&quot;1Создадим-линию-из-кубов&quot;&gt;&lt;strong&gt;1.Создадим линию из кубов&lt;/strong&gt;&lt;/h2&gt;

&lt;p&gt;Хорошее понимание математики имеет важное значение при программировании. На своем фундаментальном уровне математика – это манипулирование символами, представляющие числа. Решение уравнений сводится к переписыванию одного набора символов, который становится другим – обычно более коротким набором символов. Правила математики диктуют как именно это переписывание может быть сделано.&lt;/p&gt;

&lt;p&gt;Например, у нас есть функция &lt;script type=&quot;math/tex&quot;&gt;f(x) = x + 1&lt;/script&gt;. Мы можем заменить &lt;script type=&quot;math/tex&quot;&gt;x&lt;/script&gt;, скажем на 3. Тогда получится &lt;script type=&quot;math/tex&quot;&gt;f(3) = 3 + 1 = 4&lt;/script&gt;. Мы передали 3 как входное значение параметра &lt;script type=&quot;math/tex&quot;&gt;x&lt;/script&gt;, а на выходе получили значение 4 как результат выполнения некоторой математической функции. Так же мы можем сказать, что это функция &lt;a href=&quot;https://ru.wikipedia.org/wiki/Map&quot;&gt;map&lt;/a&gt; 3 к 4. В более коротком виде это можно записать так: &lt;script type=&quot;math/tex&quot;&gt;(3,4)&lt;/script&gt;. Мы можем создать множества пар формы &lt;script type=&quot;math/tex&quot;&gt;(x, f(x))&lt;/script&gt;. Например, (5,6), (8,9), (1,2), (6,7). Но легче понять функцию, когда мы упорядочиваем пары по входным-выходным значениям. (1,2), (2,3), (3,4) и т.д.&lt;/p&gt;

&lt;p&gt;Функция &lt;script type=&quot;math/tex&quot;&gt;f(x) = x + 1&lt;/script&gt; проста для понимания. &lt;script type=&quot;math/tex&quot;&gt;f(x) = (x -1)^4 + 5x^3 – 8x^2 + 3x&lt;/script&gt; сложна. Мы бы могли записать несколько пар ввода-вывода, но это, вероятно, не даст нам понимания о том, как выглядит график этой функции. Нам нужно будет записать множество точек, которые находятся близко друг к другу. Как результат мы получим море чисел, которые очень сложно разобрать. Вместо этого мы могли бы интерпретировать пары как двумерные координаты вида &lt;script type=&quot;math/tex&quot;&gt;\left[\begin{array}{c}x\\f(x)\end{array}\right]&lt;/script&gt;. Это 2D вектор где вверху представлены координаты по оси Х, а внизу координаты для оси Y. По другому еще это можно записать так: &lt;script type=&quot;math/tex&quot;&gt;y = f(x)&lt;/script&gt;. Если мы будем использовать достаточное количество точек, то результатом соединения точек друг за другом станет график.&lt;/p&gt;

&lt;center&gt;&lt;img src=&quot;\images\2018\02\BuildingGraph\graph.png&quot; /&gt;&lt;/center&gt;
&lt;p&gt;&lt;em&gt;График &lt;script type=&quot;math/tex&quot;&gt;y = (x -1)^4 + 5x^3 – 8x^2 + 3x&lt;/script&gt; построенный на интервале от -2 до 2&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Визуализация может быстро дать нам представление о том, как ведет себя функция. Это очень удобный инструмент, потому давайте сделаем подобное в Unity. Для начала создайте пустую сцену &lt;em&gt;File / New Scene&lt;/em&gt; или используйте сцену по умолчанию, которая создается при создании нового проекта.&lt;/p&gt;

&lt;h2 id=&quot;11-Префабы&quot;&gt;&lt;strong&gt;1.1 Префабы&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;Графики создаются путем размещения точек по соответствующим координатам. Для этого нам понадобится 3D визуализация точки. Мы не будем изобретать велосипед, потому будем использовать объект, который доступен в Unity по умолчанию – куб. Добавим один на нашу сцену и удалим у него коллайдер, потому что нам не нужно чтобы куб взаимодействовал с другими объектами.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Являются ли кубы лучшим решением для визуализации графиков?&lt;/p&gt;

  &lt;p&gt;Можно так же использовать систему частиц или сегменты линий, но проще всего использовать отдельные кубы.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Мы будем использовать скрипт, чтобы создать много экземпляров этого куба и расположить их правильно. Для этого мы будем использовать куб в качестве шаблона. Перетащите куб из окна иерархии в окно проекта. Это позволит создать новый объект со значком синего куба, этого объект более известен как &lt;em&gt;префаб (Prefab)&lt;/em&gt;. Это готовый игровой объект, который существует в проекте, но не на сцене.&lt;/p&gt;

&lt;center&gt;&lt;img src=&quot;\images\2018\02\BuildingGraph\prefab.png&quot; /&gt;&lt;/center&gt;
&lt;p&gt;&lt;em&gt;&lt;center&gt;Префаб куба&lt;/center&gt;&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Префабы – удобный способ настройки игровых объектов. При изменении главного префаба, который находится в проекте, все его экземпляры в любой сцене изменяются одинаково. Например, изменение масштаба префаба так же изменит масштаб куба, который все еще находится на сцене. Однако каждый экземпляр использует свое собственное положение и поворот. Кроме того, свойства у каждого игрового объекта можно изменить, никак не повлияв на префаб, но это отходит от сути ради которой был создан префаб. При больших изменениях, таких как добавление или удаление компонента, связь между префабом и экземпляром будет нарушена.&lt;/p&gt;

&lt;p&gt;Мы хотим написать скрипт для создания экземпляров префаба, поэтому нам больше не нужен экземпляр куба, который в настоящее время находится на сцене. Просто удалите его.&lt;/p&gt;

&lt;h2 id=&quot;12-Компонент-graph&quot;&gt;&lt;strong&gt;1.2 Компонент Graph&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;Нам понадобится скрипт на C# для того чтобы создать наш график. Давайте создадим один, и назовем его Graph. Мы начнем с простого класса, который будет расширять класс &lt;code class=&quot;highlighter-rouge&quot;&gt;MonoBehavior&lt;/code&gt; , так его можно использовать как компонент для игровых объектов. Создадим публичное поле, которое будет ссылаться на префаб для создания точек, дадим ему имя &lt;code class=&quot;highlighter-rouge&quot;&gt;pointPrefab&lt;/code&gt;. Так как нам понадобится доступ к компоненту &lt;code class=&quot;highlighter-rouge&quot;&gt;Transform&lt;/code&gt; для позиционирования точек, то установим этот тип у нашего поля.&lt;/p&gt;
&lt;div class=&quot;language-c# highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;using&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;UnityEngine&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Graph&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;MonoBehaviour&lt;/span&gt; 
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Transform&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pointPrefab&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;Добавим пустой игровой объект на сцену, с помощью &lt;em&gt;GameObject /Create Empty&lt;/em&gt;, установим его в начале, и назовем его Graph. Добавим наш скрипт Graph к этому объекту, с помощью переноса или кнопки &lt;em&gt;Add Component&lt;/em&gt;. Затем перетащим наш префаб из окна проекта в созданное нами поле &lt;em&gt;Point Prefab&lt;/em&gt;. Теперь он ссылается на компонент префаба –  &lt;em&gt;Transform&lt;/em&gt;.&lt;/p&gt;
&lt;center&gt;&lt;img src=&quot;\images\2018\02\BuildingGraph\graph-with-prefab.png&quot; /&gt;&lt;/center&gt;
&lt;p&gt;&lt;em&gt;&lt;center&gt;Объект Graph с компонентом Graph, который содержит ссылку на префаб Cube&lt;/center&gt;&lt;/em&gt;&lt;/p&gt;

&lt;h2 id=&quot;13-Создание-экземпляров-префаба&quot;&gt;&lt;strong&gt;1.3 Создание экземпляров префаба&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;Создание экземпляра объекта игры осуществляется через метод &lt;em&gt;Instantiate&lt;/em&gt;. Это общедоступный метод, который мы получили из класса &lt;em&gt;object&lt;/em&gt;, от которого неявно наследуется &lt;em&gt;MonoBehaviour&lt;/em&gt;. Метод &lt;em&gt;Instantiate&lt;/em&gt; клонирует любой объект и добавляет его на сцену. В качестве аргумента он принимает любой объект, который есть в &lt;em&gt;Unity&lt;/em&gt;. Если мы укажем в качестве аргумента наш префаб, то в результате мы увидим, как наш куб появится на сцене. Давайте вызовем этот метод в момент, когда наш &lt;code class=&quot;highlighter-rouge&quot;&gt;Graph&lt;/code&gt; «пробуждается».&lt;/p&gt;
&lt;div class=&quot;language-c# highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Graph&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;MonoBehaviour&lt;/span&gt; 
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Transform&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pointPrefab&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;Awake&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; 
	&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;nf&quot;&gt;Instantiate&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pointPrefab&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;center&gt;&lt;img src=&quot;\images\2018\02\BuildingGraph\instantiated-prefab.png&quot; /&gt;&lt;/center&gt;
&lt;p&gt;&lt;em&gt;&lt;center&gt;Создание экземпляра префаба&lt;/center&gt;&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;На данном этапе при переходе в режим воспроизведения будет создан один куб в начале координат, при условии, что позиция префаба будет равна нулю. Чтобы переместить его в другое место, нам нужно изменить положение нашего только что созданного экземпляра. Метод &lt;code class=&quot;highlighter-rouge&quot;&gt;Instantiate&lt;/code&gt; возвращается ссылку на все, что он создал. Поскольку мы передали в метод ссылку на компонент &lt;em&gt;Transform&lt;/em&gt;, то давайте попросим его вернуть нам ссылку на этот же компонент, но уже у экземпляра префаба. Создадим переменную типа &lt;code class=&quot;highlighter-rouge&quot;&gt;Transform&lt;/code&gt; и присвоим ей возвращаемое значение метода &lt;code class=&quot;highlighter-rouge&quot;&gt;Instantiate&lt;/code&gt;.&lt;/p&gt;

&lt;div class=&quot;language-c# highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;Awake&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;Transform&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;point&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;Instantiate&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pointPrefab&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Теперь мы можем задать положение точки, назначив ей нужное нам значение 3D вектора. Вспомните как мы задавали положение стрелкам часов в предыдущем уроке &lt;a href=&quot;/jekyll/update/2018/01/17/Game-Objects-and-Scripts.html&quot;&gt;Игровые объекты и скрипты&lt;/a&gt;. Точно так же мы будем делать и для точек графика. Мы будем изменять локальное положение через свойство &lt;code class=&quot;highlighter-rouge&quot;&gt;localPosition&lt;/code&gt;, а не через &lt;code class=&quot;highlighter-rouge&quot;&gt;position&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;3D вектора создаются при помощи структуры &lt;code class=&quot;highlighter-rouge&quot;&gt;Vector3&lt;/code&gt;. Поскольку это структура, то используется она в контексте значения, примерно так же как число, она не является объектом. Например, можно вручную установть координату X равной 1, оставив координаты Y и Z равные нулю, но можно использовать свойство &lt;code class=&quot;highlighter-rouge&quot;&gt;Vector3.right&lt;/code&gt; которое хранит в себе значения для координат X,Y,Z равные (+1,0,0).&lt;/p&gt;
&lt;div class=&quot;language-c# highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;Transform&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;point&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;Instantiate&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pointPrefab&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;point&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;localPosition&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Vector3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;right&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;blockquote&gt;
  &lt;p&gt;Разве свойства не должны писаться с большой буквы?&lt;/p&gt;

  &lt;p&gt;По негласному соглашению так и есть. Мы должны давать имена свойствам с заглавной буквы, но в Unity очень часто пренебрегают этим.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;При переходе в режим игры мы все равно получаем один куб, только в немного другой позиции. Давайте создадим второй экземпляр, сместив его немного вправо. Это можно сделать, умножив наш вектор на 2. Продублируйте строку с созданием экземпляра объекта и строку с изменением позиции, но умножив правый вектор на 2 &lt;code class=&quot;highlighter-rouge&quot;&gt;Vector3.right *2&lt;/code&gt;.&lt;/p&gt;

&lt;div class=&quot;language-c# highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;Transform&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;point&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;Instantiate&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pointPrefab&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;point&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;localPosition&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Vector3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;right&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;Transform&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;point&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;Instantiate&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pointPrefab&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;point&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;localPosition&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Vector3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;right&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;2f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;blockquote&gt;
  &lt;p&gt;Можем ли мы перемножать структуры и числа?&lt;/p&gt;

  &lt;p&gt;“Из под коробки” такого функционала нет, но можно добавить его. Это делается путем создания метода со специальным синтаксисом, который перегружает символ умножения &lt;code class=&quot;highlighter-rouge&quot;&gt;*&lt;/code&gt;. В этом случае, то, что кажется простым умножением, но на самом деле является вызовом метода, что-то вроде &lt;code class=&quot;highlighter-rouge&quot;&gt;Vector3.Multiply(Vector3.right, 2f)&lt;/code&gt;.&lt;/p&gt;

  &lt;p&gt;Возможность использовать методы, как если бы они были простыми операциям, делает написание кода более быстрым и легким для чтения. Это не особо важно, но приятно иметь такую возможность, так же, как возможность неявно использовать пространства имен. Такой более удобное написание называется синтаксическим сахаром.&lt;/p&gt;

  &lt;p&gt;Но когда мы внедряем подобный сахар, то мы должны быть уверены, что подобное сокращение не приведет к двузначности в понимании нашего сокращения. Методы, должны выполнять только то, что определено конкретным символом (сложение, умножение, деление и т.д.). В случае векторов некоторые математические операторы четко определены, поэтому мы можем спокойно использовать сахар для векторов.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Код, который мы только что написали приведет к ошибке компиляции, потому что мы пытаемся определить переменную &lt;code class=&quot;highlighter-rouge&quot;&gt;point&lt;/code&gt; дважды. Если мы хотим использовать другую переменную, мы должны дать ей другое имя. Нам уже не нужна ссылка на первую точку (куб), поэтому просто создайте новый экземпляр точки использовав ту же переменную.&lt;/p&gt;

&lt;div class=&quot;language-c# highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;	&lt;span class=&quot;n&quot;&gt;Transform&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;point&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;Instantiate&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pointPrefab&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;point&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;localPosition&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Vector3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;right&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;//	Transform point = Instantiate(pointPrefab);&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;point&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;Instantiate&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pointPrefab&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;point&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;localPosition&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Vector3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;right&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;2f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;center&gt;&lt;img src=&quot;\images\2018\02\BuildingGraph\two-instances.png&quot; /&gt;&lt;/center&gt;
&lt;p&gt;&lt;em&gt;&lt;center&gt;Два экземпляра с координатой по оси X равной 1 и 2.&lt;/center&gt;&lt;/em&gt;&lt;/p&gt;

&lt;h2 id=&quot;14-Циклы&quot;&gt;&lt;strong&gt;1.4 Циклы&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;Давайте создадим больше точек, например, 10. Мы, конечно, можем просто продублировать код, который у нас уже есть еще 8 раз, но это очень неэффективно. В идеале, мы пишем код только для одной точки и поручаем программе выполнить его несколько раз с небольшими изменениями.&lt;/p&gt;

&lt;p&gt;Ключевое слово &lt;code class=&quot;highlighter-rouge&quot;&gt;while&lt;/code&gt; будет повторять блок кода, которые написан внутри него. Напишите &lt;code class=&quot;highlighter-rouge&quot;&gt;while&lt;/code&gt; после него поставьте фигурные скобки &lt;code class=&quot;highlighter-rouge&quot;&gt;{}&lt;/code&gt; и внутри этих скобок впишите первые 2 строки, остальное удалите.&lt;/p&gt;

&lt;div class=&quot;language-c# highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;Awake&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; 
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; 
	&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;Transform&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;point&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;Instantiate&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pointPrefab&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;			
		&lt;span class=&quot;n&quot;&gt;point&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;localPosition&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Vector3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;right&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;//		point = Instantiate(pointPrefab);&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;//		point.localPosition = Vector3.right * 2f;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Так же, как и оператор &lt;code class=&quot;highlighter-rouge&quot;&gt;if&lt;/code&gt; оператор &lt;code class=&quot;highlighter-rouge&quot;&gt;while&lt;/code&gt; должен иметь условие, которое указывается в круглых скобках. Как и в случае с &lt;code class=&quot;highlighter-rouge&quot;&gt;if&lt;/code&gt;, следующий за условием блок кода будет выполняться только в том случае, если выражение имеет значение &lt;code class=&quot;highlighter-rouge&quot;&gt;true&lt;/code&gt;. Если указанное условие истинно, то выполнится код, который описан внутри фигурных скобок, после этого программа вернется проверить выполнилось ли условие. Если нет, то цепочка действий будет повторяться до тех пор, пока условие не станет &lt;code class=&quot;highlighter-rouge&quot;&gt;false&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Поэтому мы должны создавать такое условие, которое точно выполнится через какой-то промежуток времени. Создание бесконечных циклов ни к чему хорошему не приводит. Программа просто зависает и перестает работать. Давайте добавим самое простое условие, которое точно не будет бесконечным циклом.&lt;/p&gt;

&lt;div class=&quot;language-c# highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; 
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;Transform&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;point&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;Instantiate&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pointPrefab&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;point&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;localPosition&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Vector3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;right&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;blockquote&gt;
  &lt;p&gt;Можем ли мы проинициализировать переменную внутри цикла?&lt;/p&gt;

  &lt;p&gt;Конечно. Каждый раз, когда цикл будет повторяться он будет создавать новую переменную заданного типа с заданным именем, а по завершении удалять ее. Переменные, определенные вне цикла так же можно использовать.&lt;/p&gt;

  &lt;p&gt;Но важно знать одну вещь: проинициализированная переменная внутри цикла будет доступна только в нем т.е. мы не сможем использовать эту переменную вне блока &lt;code class=&quot;highlighter-rouge&quot;&gt;while&lt;/code&gt;.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Ограничить количество итераций можно путем отслеживания того, сколько раз мы повторяли код. Мы можем использовать целочисленную переменную, чтобы отслеживать это. Пременная будет содержать в себе номер итерации цикла. Объявим новую переменную типа &lt;code class=&quot;highlighter-rouge&quot;&gt;int&lt;/code&gt; и назовем её &lt;code class=&quot;highlighter-rouge&quot;&gt;i&lt;/code&gt; от слова &lt;em&gt;iteration&lt;/em&gt;. Нам нужно чтобы эта переменная хранила в себе номер итерации. Если мы ее объявим внутри цикла, то она будет постоянно объявляться заново, поэтому сделаем это вне цикла.&lt;/p&gt;

&lt;div class=&quot;language-c# highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;Awake&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; 
	&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;Transform&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;point&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;Instantiate&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pointPrefab&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;point&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;localPosition&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Vector3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;right&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;На каждой итерации увеличиваем значение счетчика на единицу.&lt;/p&gt;
&lt;div class=&quot;language-c# highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;Awake&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; 
	&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;Transform&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;point&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;Instantiate&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pointPrefab&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;point&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;localPosition&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Vector3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;right&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Если мы сейчас запустим наш код, то это приведет в ошибке компиляции. Это произошло потому что наша переменная не проинициализирована. Мы как бы пытаемся прибавить единицу к неопределённому значению, чего сделать конечно же невозможно*. Нужно явно указать значение, к которому будет прибавляться единица.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;ul&gt;
    &lt;li&gt;Примечание от переводчика.&lt;/li&gt;
  &lt;/ul&gt;

  &lt;p&gt;Вы могли задаться вопросом: «Если мы не проинициализируем переменную и попытаемся узнать, чему она равна, то окажется что она равно нулю. Для чего тогда нам явно указывать то, что уже было сделано до нас?».&lt;/p&gt;

  &lt;p&gt;В других языках, например, C++, при объявлении переменной её значение вообще заполнено «мусором». Оно может быть равно любому числу, которое попадает в диапазон, покрываемый значением типа &lt;code class=&quot;highlighter-rouge&quot;&gt;int&lt;/code&gt;. При разработке на C# мы можем не задумываться об этом, мы знаем, что значение переменной по умолчанию равно нулю. Конструкцию &lt;code class=&quot;highlighter-rouge&quot;&gt;i = i + 1;&lt;/code&gt; можно расшифровать как: «Возьми значение переменной &lt;code class=&quot;highlighter-rouge&quot;&gt;i&lt;/code&gt; прибавь к нему единицу и получившееся значение присвой переменной &lt;code class=&quot;highlighter-rouge&quot;&gt;i&lt;/code&gt;.» Но какое именно значение переменной нужно взять? 0? 1? 100000? Откуда именно начинать отсчет, никому не понятно. Разработчики языка учли этот момент и сделали обязательным инициализацию переменной, которой потом происходят какие-либо манипуляции. Чтобы не возникало путаницы, чтобы любому человеку, который будет работать с этим кодом было понятно откуда именно мы ведем отсчет. Так же это сделано для безопасности кода, мы ведь не знаем действительно ли значение по умолчанию равно нулю. Понимаю, звучит абсурдно, но мы можем обходными путями добиться того чтобы наши переменные имели какое угодно значение по умолчанию. Но мы пишем код на высокоуровневом языке программирования, зачем нам об это вообще думать. Так вот и не думайте, за вас уже этот момент продумали. Просто явно укажите откуда именно вы хотите вести счет.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;language-c# highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Проговорим что нам нужно. Нам нужно чтобы цикл выполнился определённое количество раз. Для этого мы создали счетчик. Когда цикл начинает выполняться, то &lt;code class=&quot;highlighter-rouge&quot;&gt;i&lt;/code&gt; увеличивается на единицу. При первом проходе она равна 1, потом 2, потом 3 на 10 проходе она равна 9. Допустим я хочу, чтобы цикл закончил выполняться после 10 итераций. Значит нам нужно чтобы цикл выполнялся пока значение счетчика меньше 10. Математически это условие можно записать как &lt;script type=&quot;math/tex&quot;&gt;% &lt;![CDATA[
i  &lt; 10 %]]&gt;&lt;/script&gt;.&lt;/p&gt;

&lt;p&gt;После того как мы проговорили это, нужно прописать это условие в коде:&lt;/p&gt;

&lt;div class=&quot;language-c# highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; 
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;Transform&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;point&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;Instantiate&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pointPrefab&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;point&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;localPosition&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Vector3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;right&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Теперь после перехода в режим воспроизведения мы получим 10 кубов. Но все они окажутся в одной позиции. Чтобы переместить их в ряд вдоль оси X, умножьте правый вектор на &lt;code class=&quot;highlighter-rouge&quot;&gt;i&lt;/code&gt;.&lt;/p&gt;

&lt;div class=&quot;language-c# highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;point&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;localPosition&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Vector3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;right&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;center&gt;&lt;img src=&quot;\images\2018\02\BuildingGraph\ten-cubes.png&quot; /&gt;&lt;/center&gt;
&lt;p&gt;&lt;em&gt;&lt;center&gt;Десять кубов в ряд.&lt;/center&gt;&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Обратите внимание, что сейчас координаты первого куда по оси X начинаются с 1, а заканчиваются 10. Это не много не то что мы хотели. Поскольку счет мы начинаем с 0, то хотим чтобы наш первый куб был с координатой 0. Мы можем сдвинуть все точки на одну единицу влево, умножив наш вектор на &lt;code class=&quot;highlighter-rouge&quot;&gt;i-1&lt;/code&gt; вместо &lt;code class=&quot;highlighter-rouge&quot;&gt;i&lt;/code&gt;. Но подобные вещи в программировании принято называть костылями. Но у нас есть более элегантное решение.&lt;/p&gt;

&lt;div class=&quot;language-c# highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; 
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;//	i = i + 1;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;Transform&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;point&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;Instantiate&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pointPrefab&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;point&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;localPosition&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Vector3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;right&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;15-Лаконичный-синтаксис&quot;&gt;&lt;strong&gt;1.5 Лаконичный синтаксис&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;Использование циклов очень распространено в программировании. В любой ситуации где наши действия нужно выполнить несколько раз используется цикл. Чем сложнее код внутри цикла, тем сложнее понять, что он делает. Для упрощения чтения и понимания кода существует такая вещь как «синтаксический сахар».&lt;/p&gt;

&lt;p&gt;Например, давайте рассмотрим увеличение операцию инкремента. Увеличение счетчика на единицу мы можем написать так: &lt;code class=&quot;highlighter-rouge&quot;&gt;i = i + 1;&lt;/code&gt;, но можем и так &lt;code class=&quot;highlighter-rouge&quot;&gt;i += 1;&lt;/code&gt;. Подобные сокращения и называются синтаксическим сахаром.&lt;/p&gt;

&lt;div class=&quot;language-c# highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;//	i = i + 1;&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Но и в данной ситуации можно «добавить сахара» заменив &lt;code class=&quot;highlighter-rouge&quot;&gt;i += 1;&lt;/code&gt; на &lt;code class=&quot;highlighter-rouge&quot;&gt;++i;&lt;/code&gt;.&lt;/p&gt;

&lt;div class=&quot;language-c# highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;//	i += 1;&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Стоит так же сказать об интересной особенности использования данного сахара. Подобные конструкции могут использоваться в качестве выражений. Это означает, что вы можете написать что-то вроде &lt;code class=&quot;highlighter-rouge&quot;&gt;y = (x += 3)&lt;/code&gt;. Это можно расшифровать как: «Присвоить Y значение равное X + 3». Из этого можно сделать вывод что инкремент (увеличение) &lt;code class=&quot;highlighter-rouge&quot;&gt;i&lt;/code&gt; мы могли бы сделать внутри условия цикла &lt;code class=&quot;highlighter-rouge&quot;&gt;while&lt;/code&gt;, тем самым сократив блок кода.&lt;/p&gt;

&lt;div class=&quot;language-c# highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(++&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; 
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;Transform&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;point&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;Instantiate&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pointPrefab&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;point&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;localPosition&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Vector3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;right&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;//	++i;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Однако, сейчас мы увеличиваем &lt;code class=&quot;highlighter-rouge&quot;&gt;i&lt;/code&gt; до сравнения, а не после. Это приведет к меньшему числу итераций нежели хотим мы. Специально для таких ситуаций операторы инкремента и декремента также могут быть размещены после переменной, а не перед ней.&lt;/p&gt;

&lt;div class=&quot;language-c# highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;//while (++i &amp;lt; 10) {&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;++&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; 
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;Transform&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;point&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;Instantiate&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pointPrefab&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;point&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;localPosition&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Vector3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;right&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Хотя цикл &lt;code class=&quot;highlighter-rouge&quot;&gt;while&lt;/code&gt; работает для всех типов циклов, существует альтернативный синтаксис, особенно подходящий для итерации по диапазонам. Это цикл &lt;code class=&quot;highlighter-rouge&quot;&gt;for&lt;/code&gt;. Он работает так же, как и &lt;code class=&quot;highlighter-rouge&quot;&gt;while&lt;/code&gt;, за исключением того, что объявление переменной итератора и ее сравнение содержатся в круглых скобках и разделяются точкой с запятой.&lt;/p&gt;

&lt;div class=&quot;language-c# highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;//int i = 0;&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;//while (i++ &amp;lt; 10) {&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;++&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; 
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;Transform&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;point&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;Instantiate&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pointPrefab&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;point&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;localPosition&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Vector3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;right&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Фрагмент выше приведет к ошибке компиляции, потому что на самом деле есть три части. Третья часть отвечает за увеличение итератора, как бы сохраняя его отдельно от сравнения.&lt;/p&gt;

&lt;div class=&quot;language-c# highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;//for (int i = 0; i++ &amp;lt; 10) {&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;++)&lt;/span&gt; 
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;Transform&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;point&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;Instantiate&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pointPrefab&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;point&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;localPosition&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Vector3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;right&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;blockquote&gt;
  &lt;p&gt;Почему в цикле &lt;code class=&quot;highlighter-rouge&quot;&gt;for&lt;/code&gt; мы используем &lt;code class=&quot;highlighter-rouge&quot;&gt;i++&lt;/code&gt; а не &lt;code class=&quot;highlighter-rouge&quot;&gt;++i&lt;/code&gt;?&lt;/p&gt;

  &lt;p&gt;Поскольку выражение инкремента не используется ни для чего другого, не имеет значения, какую из двух этих версий мы используем. Мы могли бы также использовать &lt;code class=&quot;highlighter-rouge&quot;&gt;i += 1&lt;/code&gt; или &lt;code class=&quot;highlighter-rouge&quot;&gt;i = i + 1&lt;/code&gt;.&lt;/p&gt;

  &lt;p&gt;Классический цикл &lt;code class=&quot;highlighter-rouge&quot;&gt;for&lt;/code&gt; имеет форму &lt;code class=&quot;highlighter-rouge&quot;&gt;for (int i  = 0; i &amp;lt; someLimit; i++)&lt;/code&gt;. Вы будете сталкиваться с подобной записью во многих других скриптах и программах.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;16-Изменение-области-определения-функции&quot;&gt;&lt;strong&gt;1.6 Изменение &lt;a href=&quot;https://ru.wikipedia.org/wiki/Область_определения_функции&quot;&gt;области определения функции&lt;/a&gt;&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;На данный момент нашим кубам даны координаты по оси X от 0 до 9. Это не удобный диапазон для работы с функциями. Чаще всего используется диапазон от 0 до 1. Или если мы работаем с функцией, которая симметрична относительно нуля то ее диапазон обычно равен &lt;script type=&quot;math/tex&quot;&gt;(-1, +1)&lt;/script&gt;. Давайте расположим наши кубы в соответствующем диапазоне.&lt;/p&gt;

&lt;p&gt;Расположение десятка кубов на отрезке длиной в две единицы приведет к их перекрытию. Чтобы предотвратить это надо уменьшить масштаб кубов. Каждый куб имеет размер 1 по всем осям по умолчанию. Для того чтобы сделать их подходящего размера нам нужно уменьшить их масштаб до &lt;script type=&quot;math/tex&quot;&gt;\frac{2}{10} = \frac{1}{5}&lt;/script&gt;. Мы можем сделать это установив масштаб каждого куба равный &lt;code class=&quot;highlighter-rouge&quot;&gt;Vector3.one&lt;/code&gt; деленный на 5 т.е. принять значение масштаба для всех осей равный &lt;script type=&quot;math/tex&quot;&gt;\frac{1}{5}&lt;/script&gt;&lt;/p&gt;

&lt;div class=&quot;language-c# highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;++)&lt;/span&gt; 
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;Transform&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;point&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;Instantiate&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pointPrefab&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;point&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;localPosition&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Vector3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;right&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;point&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;localScale&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Vector3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;one&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;/&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;5f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;center&gt;&lt;img src=&quot;\images\2018\02\BuildingGraph\small-cubes.png&quot; /&gt;&lt;/center&gt;
&lt;p&gt;&lt;em&gt;&lt;center&gt;Маленькие кубики. &lt;/center&gt;&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Чтобы снова собрать кубики вместе разделите их позицию на 5.&lt;/p&gt;

&lt;div class=&quot;language-c# highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;point&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;localPosition&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Vector3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;right&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;/&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;5f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Теперь наши кубики располагаются в диапазоне от &lt;script type=&quot;math/tex&quot;&gt;(0,2)&lt;/script&gt;. Но нам нужен диапазон &lt;script type=&quot;math/tex&quot;&gt;(-1,+1)&lt;/script&gt;, поэтому надо он нашей формулы отнять единицу.&lt;/p&gt;

&lt;div class=&quot;language-c# highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;point&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;localPosition&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Vector3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;right&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;/&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;5f&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;–&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Сейчас у первого куба координата по оси X равна -1, в то время как последний куб имеет координату 0.8. Однако размер куба равен 0.2. Поскольку размер куб считается его центра, то левая сторона первого куба имеет координату X равной -1.1, в то время как правая сторона этого же куба имеет координату -0.9. Чтобы правильно заполнить диапазон &lt;script type=&quot;math/tex&quot;&gt;(-1,+1)&lt;/script&gt; нашими кубиками, мы должны сдвинуть их на половину куба вправо. Это можно сделать просто, добавив значение 0.5 к &lt;code class=&quot;highlighter-rouge&quot;&gt;i&lt;/code&gt; перед операцией деления. Более подробнее узнать о том, как приводить какие-либо значения к нужному диапазону можно узнать из статьи на Википедии: &lt;a href=&quot;https://en.wikipedia.org/wiki/Feature_scaling&quot;&gt;Feature scaling&lt;/a&gt;.&lt;/p&gt;

&lt;div class=&quot;language-c# highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;point&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;localPosition&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Vector3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;right&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;0.5f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;/&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;5f&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;1f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;17-Выносим-вектора-за-пределы-цикла&quot;&gt;&lt;strong&gt;1.7 Выносим вектора за пределы цикла&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;Хотя все кубы у нас имеют одинаковый масштаб, мы вычисляем его в каждой итерации цикла. С точки зрения производительности это не очень хорошо. Вместо этого мы могли бы вычислить его один раз перед циклом, сохранить его в переменной имеющей тип &lt;code class=&quot;highlighter-rouge&quot;&gt;Vector3&lt;/code&gt; и использовать эту переменную внутри цикла.&lt;/p&gt;

&lt;div class=&quot;language-c# highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;Awake&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; 
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;Vector3&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;scale&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Vector3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;one&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;/&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;5f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;++)&lt;/span&gt; 
	&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;Transform&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;point&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;Instantiate&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pointPrefab&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;point&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;localPosition&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Vector3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;right&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;0.5f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;/&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;5f&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;1f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;point&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;localScale&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;scale&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Мы также можем определить переменную для позиции перед циклом. Поскольку мы создаем линию вдоль оси X, нам нужно изменять только координату X внутри цикла. Таким образом нам больше не нужно умножать нашу позицию на &lt;code class=&quot;highlighter-rouge&quot;&gt;Vector3.right&lt;/code&gt;.&lt;/p&gt;

&lt;div class=&quot;language-c# highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;Vector3&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;scale&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Vector3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;one&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;/&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;5f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;Vector3&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;position&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;++)&lt;/span&gt; 
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;Transform&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;point&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;Instantiate&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pointPrefab&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;//	point.localPosition = Vector3.right * ((i + 0.5f) / 5f - 1f);&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;position&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;0.5f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;/&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;5f&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;1f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;point&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;localPosition&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;position&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;point&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;localScale&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;scale&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;blockquote&gt;
  &lt;p&gt;Можем ли мы изменить составляющие вектора так как мне нужно?&lt;/p&gt;

  &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Vector3&lt;/code&gt; это структура, которая содержит в себе три поля &lt;code class=&quot;highlighter-rouge&quot;&gt;x&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;y&lt;/code&gt; и &lt;code class=&quot;highlighter-rouge&quot;&gt;z&lt;/code&gt; типа &lt;code class=&quot;highlighter-rouge&quot;&gt;float&lt;/code&gt;. Эти поля публичные, значит мы можем изменить их.&lt;/p&gt;

  &lt;p&gt;Идея заключается в том, чтобы структуры должны быть неизменяемыми поскольку они как правило хранят в себе простые значения. Конечные структуры не должны изменяться. Если вы хотите использовать другое значение, создайте новую структуру поле или переменную как это мы делаем с числами. Если мы скажем что &lt;script type=&quot;math/tex&quot;&gt;x = 3&lt;/script&gt;, а потом &lt;script type=&quot;math/tex&quot;&gt;x = 5&lt;/script&gt;, то мы присвоим переменной X другое значение. Мы не использовали 3 чтобы получить 5, мы просто заменили одно значение другим. Хоть и структуры, содержащие в себе значения векторов и можно изменить в Unity, лучше избегать этого. Создайте новую переменную типа &lt;code class=&quot;highlighter-rouge&quot;&gt;Vector3&lt;/code&gt; и ей присвойте значение, взятое из структуры, а после изменяйте его как хотите. Манипуляции будут происходить только с объявленной вами переменной.&lt;/p&gt;

  &lt;p&gt;Чтобы получить представление о том, как работать с изменяемыми векторами нужно рассмотреть использование &lt;code class=&quot;highlighter-rouge&quot;&gt;Vector3&lt;/code&gt; в качестве удобной замены для использования трех отдельных значений &lt;code class=&quot;highlighter-rouge&quot;&gt;float&lt;/code&gt;. Вы можете получить к ним доступ независимо друг от друга, скопировать любое значение или объединить их в группу.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Код выше приведет к ошибке компиляции, жалуясь на использование неназначенной переменной. Это происходит потому что мы назначаем позицию чему-то, не установив его начальные координаты по осям Y и Z. Явно установите их, присвоив им значение нуля.&lt;/p&gt;

&lt;div class=&quot;language-c# highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;Vector3&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;position&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;position&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;y&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;0f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;position&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;z&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;0f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;++)&lt;/span&gt; 
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;err&quot;&gt;…&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;18-Выражаем-y-через-x&quot;&gt;&lt;strong&gt;1.8 Выражаем Y через X&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;Идея заключается в том, что позиции наших кубов можно выразить как &lt;script type=&quot;math/tex&quot;&gt;\left[\begin{array}{c}x\\f(x)\\0\end{array}\right]&lt;/script&gt; для отображения нашей функции. В настоящий момент координата Y равна нулю, что представляет собой тривиальную функцию &lt;script type=&quot;math/tex&quot;&gt;f(x) = 0&lt;/script&gt;. Чтобы наш график начал отображать хоть какую-либо зависимость мы должны изменить нашу функцию на &lt;script type=&quot;math/tex&quot;&gt;f(x) = x&lt;/script&gt; для начала. Для этого нужно присваивать координате Y значение внутри цикла, а не перед ним.&lt;/p&gt;

&lt;div class=&quot;language-c# highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;Vector3&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;position&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;//position.y = 0f;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;position&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;z&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;0f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;++)&lt;/span&gt; 
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;Transform&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;point&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;Instantiate&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pointPrefab&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;position&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;0.5f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;/&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;5f&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;1f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;position&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;y&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;position&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;point&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;localPosition&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;position&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;point&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;localScale&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;scale&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;center&gt;&lt;img src=&quot;\images\2018\02\BuildingGraph\y-equals-x.png&quot; /&gt;&lt;/center&gt;
&lt;p&gt;&lt;em&gt;&lt;center&gt;Y равен X. &lt;/center&gt;&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Не много менее очевидная функция &lt;script type=&quot;math/tex&quot;&gt;f(x) = x^2&lt;/script&gt;, которая определяет &lt;a href=&quot;https://ru.wikipedia.org/wiki/Парабола&quot;&gt;параболу&lt;/a&gt; с вершиной в нуле.&lt;/p&gt;
&lt;div class=&quot;language-c# highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;position&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;y&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;position&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;position&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;center&gt;&lt;img src=&quot;\images\2018\02\BuildingGraph\y-equals-x-squared.png&quot; /&gt;&lt;/center&gt;
&lt;p&gt;&lt;em&gt;&lt;center&gt;Y равен X в квадрате. &lt;/center&gt;&lt;/em&gt;
&lt;a href=&quot;\content\2018\02\BuildingGraph\creating-a-line-of-cubes.unitypackage&quot;&gt;1. unitypackage&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;2-Создаем-больше-кубов&quot;&gt;&lt;strong&gt;2. Создаем больше кубов.&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;Хотя на данный момент у нас есть готовый график, но на данный момент он уродлив. Потому что мы используем только десять кубов, предложенная линия выглядит очень блочной и разрозненной. Было бы лучше, если бы мы использовали больше кубиков меньшего размера.&lt;/p&gt;

&lt;h2 id=&quot;21--Различные-разрешения&quot;&gt;&lt;strong&gt;2.1.  Различные разрешения.&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;Вместо того, чтобы использовать фиксированное количество кубов, мы можем сделать его настраиваемым. Чтобы сделать это возможным, добавьте публичное целое поле, которое будет хранить в себе разрешение &lt;code class=&quot;highlighter-rouge&quot;&gt;Graph&lt;/code&gt; (разрешение в данном контексте подразумевает количество кубов, которое будет использоваться для отображения графика. Как монитор компьютера, чем больше разрешение, тем точнее картинка. Так же и тут чем выше разрешение, тем точнее график). Дайте ему значение по умолчанию 10, которое мы используем сейчас.&lt;/p&gt;

&lt;div class=&quot;language-c# highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;resolution&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;center&gt;&lt;img src=&quot;\images\2018\02\BuildingGraph\resolution-number.png&quot; /&gt;&lt;/center&gt;
&lt;p&gt;&lt;em&gt;&lt;center&gt;Поле Resolution &lt;/center&gt;&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Идея заключается в том, что мы можем изменить разрешение графа, изменив это значение с помощью созданного нами поля в инспекторе. Однако не все целые числа являются допустимыми. Как минимум, числа должны быть положительными. Мы можем поручить инспектору обеспечить соблюдение попадания в определенный диапазон для нашего поля. Это делается путем записи Range в квадратные скобки перед определением поля.&lt;/p&gt;

&lt;div class=&quot;language-c# highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;na&quot;&gt;[Range]&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;resolution&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Range&lt;/code&gt; -Тип атрибута, определяемый &lt;em&gt;Unity&lt;/em&gt;. Атрибут-это способ присоединения метаданных к структурам кода, в данном случае к полю. Инспектор Unity проверяет, есть ли у поля добавленный атрибут &lt;code class=&quot;highlighter-rouge&quot;&gt;Range&lt;/code&gt;. Если это так, он будет использовать ползунок вместо поля ввода по умолчанию для чисел. Однако для этого необходимо знать допустимый диапазон. Так &lt;code class=&quot;highlighter-rouge&quot;&gt;Range&lt;/code&gt; имеет два параметра, для минимального и максимального значения. Давайте используем 10 и 100. Кроме того, атрибуты обычно записываются выше объявляемого поля или метода, а не перед ними.&lt;/p&gt;

&lt;div class=&quot;language-c# highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;na&quot;&gt;[Range(10, 100)]&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;resolution&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;center&gt;&lt;img src=&quot;\images\2018\02\BuildingGraph\resolution-slider.png&quot; /&gt;&lt;/center&gt;
&lt;p&gt;&lt;em&gt;&lt;center&gt;Поле Resolution со слайдером&lt;/center&gt;&lt;/em&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Гарантирует ли это, что разрешение будет ограничено 10-100?&lt;/p&gt;

  &lt;p&gt;Нет, что что делает атрибут &lt;code class=&quot;highlighter-rouge&quot;&gt;Range&lt;/code&gt; это настраивает ползунок в инспекторе. Это в целом никак вообще не влияет на то какие значения будет принимать эта переменная. Мы можем в любом месте кода спокойно изменить значение этого поля на любое целое число, котором нам нравится. Но в нашем случае мы предполагаем, что значение регулируется только с помощью инспектора и нигде больше.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;22-Создание-различных-экземпляров&quot;&gt;&lt;strong&gt;2.2 Создание различных экземпляров.&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;Для того чтобы использовать разрешение, мы должны изменить количество кубов, которое мы создаем. Вместо использования циклов фиксированное количество раз в awake, количество итераций теперь ограничено разрешением. Теперь если разрешение установлено 50, мы создадим 50 кубов после входа в игровой режим.&lt;/p&gt;

&lt;div class=&quot;language-c# highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;resolution&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;++)&lt;/span&gt; 
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;err&quot;&gt;…&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Мы также должны отрегулировать масштаб и положение кубов чтобы оставить их в позиции &lt;script type=&quot;math/tex&quot;&gt;-1 -1&lt;/script&gt;. Размер каждого шага, который мы будем делать каждую итерацию сейчас равен &lt;script type=&quot;math/tex&quot;&gt;\frac{2}{resolution}&lt;/script&gt; вместо обычного &lt;script type=&quot;math/tex&quot;&gt;\frac{1}{5}&lt;/script&gt;. Сохраните это значение в переменной и используйте его для вычисления масштаба кубов и их координат по оси X.&lt;/p&gt;

&lt;div class=&quot;language-c# highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;Awake&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; 
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;kt&quot;&gt;float&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;step&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;2f&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;/&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;resolution&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;Vector3&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;scale&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Vector3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;one&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;step&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;Vector3&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;position&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;position&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;z&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;0f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;resolution&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;++)&lt;/span&gt; 
	&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;Transform&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;point&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;Instantiate&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pointPrefab&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;position&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;0.5f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;step&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;1f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;position&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;y&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;position&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;position&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;point&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;localPosition&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;position&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;point&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;localScale&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;scale&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;center&gt;&lt;img src=&quot;\images\2018\02\BuildingGraph\resolution-50.png&quot; /&gt;&lt;/center&gt;
&lt;p&gt;&lt;em&gt;&lt;center&gt;График со значением Resolution равным 50&lt;/center&gt;&lt;/em&gt;&lt;/p&gt;

&lt;h2 id=&quot;23-Устанавливаем-родителя&quot;&gt;&lt;strong&gt;2.3. Устанавливаем родителя&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;После открытия режима с разрешением в 50, множество созданных кубов окажутся на сцене.&lt;/p&gt;

&lt;center&gt;&lt;img src=&quot;\images\2018\02\BuildingGraph\many-root-objects.png&quot; /&gt;&lt;/center&gt;
&lt;p&gt;&lt;em&gt;&lt;center&gt;Все точки графика являются корневыми. &lt;/center&gt;&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Эти Кубы в настоящее время являются корневыми объектами, хотя по сути они должны являться потомками объекта &lt;em&gt;Graph&lt;/em&gt;. Мы можем установить эту связь после создания экземпляра куба, вызвав метод &lt;code class=&quot;highlighter-rouge&quot;&gt;SetParent&lt;/code&gt; из компонента куба &lt;code class=&quot;highlighter-rouge&quot;&gt;Transform&lt;/code&gt;. В качестве аргумента мы должны предоставить компонент &lt;code class=&quot;highlighter-rouge&quot;&gt;Transform&lt;/code&gt; объекта, который будет для наших кубов родителем. Мы можем напрямую получить доступ к компоненту &lt;code class=&quot;highlighter-rouge&quot;&gt;Transform&lt;/code&gt; объекта &lt;em&gt;Graph&lt;/em&gt; через его свойство &lt;code class=&quot;highlighter-rouge&quot;&gt;transform&lt;/code&gt;.&lt;/p&gt;

&lt;div class=&quot;language-c# highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;resolution&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;++)&lt;/span&gt; 
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;Transform&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;point&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;Instantiate&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pointPrefab&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;position&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;0.5f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;step&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;1f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;position&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;y&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;position&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;position&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;point&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;localPosition&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;position&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;point&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;localScale&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;scale&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;point&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;SetParent&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;transform&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;center&gt;&lt;img src=&quot;\images\2018\02\BuildingGraph\child-objects.png&quot; /&gt;&lt;/center&gt;
&lt;p&gt;&lt;em&gt;&lt;center&gt;Все точки графика стали дочерними к объекту Graph. &lt;/center&gt;&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Когда новый родитель установлен, Unity попытается сохранить объект в исходном положении, вращении и масштабе. В нашем случае, нам это не нужно. Мы можем указать это, подставляя &lt;code class=&quot;highlighter-rouge&quot;&gt;false&lt;/code&gt; в качестве второго аргумента &lt;code class=&quot;highlighter-rouge&quot;&gt;SetParent&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;\content\2018\02\BuildingGraph\creating-more-cubes.unitypackage&quot;&gt;2. unitypackage&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;3-Раскрасим-график&quot;&gt;&lt;strong&gt;3. Раскрасим график&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;Белый график выглядит не очень презентабельно. МЫ могли бы использовать другой сплошной цвет, но это тоже не очень интересно. Что мы можем сделать, так это использовать позицию точки для определения ее цвета.&lt;/p&gt;

&lt;p&gt;Простой способ настройки цвета каждого куба можно сделать через свойство цвета материала куба. Мы можем сделать это в цикле. Поскольку каждый куб будет иметь свой цвет, это означает, что мы будем иметь один уникальный материал для каждого объекта. Хоть данная идея и реализуема, она не очень эффективна. Было бы на много проще, если бы могли использовать один материал, который изменял бы свой цвет в зависимости от своего положения в пространстве. К сожалению, в Unity нет такого материала. Так что давайте сами его создадим.&lt;/p&gt;

&lt;h2 id=&quot;31-Создание-собственного-шейдера&quot;&gt;&lt;strong&gt;3.1 Создание собственного шейдера.&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;GPU (graphic processing unit) или графический процессор отвечает за рендер (отображение) 3D-объектов. Материалы в Unity определяются при помощи шейдеров, который позволяют настраивать его свойства. Нам нужно создать пользовательский шейдер для получения нужной функциональности. Создайте таковой через : &lt;em&gt;Assets / Create / Shader / Standard Surface Shader&lt;/em&gt; и дайте ему имя &lt;em&gt;ColoredPoint&lt;/em&gt;.&lt;/p&gt;

&lt;center&gt;&lt;img src=&quot;\images\2018\02\BuildingGraph\custom-shader-asset.png&quot; /&gt;&lt;/center&gt;
&lt;p&gt;&lt;em&gt;&lt;center&gt;Пользовательский шейдер &lt;/center&gt;&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Теперь у нас есть файл c расширением shader, который мы можем открыть как обычный скрипт с синтаксисом отличным от языка C#. Наш файл шейдера содержит код для определения качеств, которые присущи нашему материалу. Ниже представлено содержимое файла, которое генерируется Unity. Все строки с комментариями удалены для краткости.&lt;/p&gt;

&lt;div class=&quot;language-c# highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;Shader&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;Custom/ColoredPoint&quot;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;Properties&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;nf&quot;&gt;_Color&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Color&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Color&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
		&lt;span class=&quot;nf&quot;&gt;_MainTex&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Albedo (RGB)&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;2D&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;white&quot;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{}&lt;/span&gt;
		&lt;span class=&quot;nf&quot;&gt;_Glossiness&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Smoothness&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;Range&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;0.5&lt;/span&gt;
		&lt;span class=&quot;nf&quot;&gt;_Metallic&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Metallic&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;Range&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;0.0&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;SubShader&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;Tags&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;RenderType&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Opaque&quot;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;LOD&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;200&lt;/span&gt;
		
		&lt;span class=&quot;n&quot;&gt;CGPROGRAM&lt;/span&gt;
		&lt;span class=&quot;err&quot;&gt;#&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pragma&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;surface&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;surf&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Standard&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fullforwardshadows&lt;/span&gt;

		&lt;span class=&quot;err&quot;&gt;#&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pragma&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;target&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;3.0&lt;/span&gt;

		&lt;span class=&quot;n&quot;&gt;sampler2D&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_MainTex&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

		&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Input&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
			&lt;span class=&quot;n&quot;&gt;float2&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;uv_MainTex&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
		&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;

		&lt;span class=&quot;n&quot;&gt;half&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_Glossiness&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;half&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_Metallic&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;fixed4&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_Color&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

		&lt;span class=&quot;nf&quot;&gt;UNITY_INSTANCING_CBUFFER_START&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Props&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;UNITY_INSTANCING_CBUFFER_END&lt;/span&gt;

		&lt;span class=&quot;k&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;surf&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Input&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;IN&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;inout&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;SurfaceOutputStandard&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;o&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
			&lt;span class=&quot;n&quot;&gt;fixed4&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;tex2D&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_MainTex&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;IN&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;uv_MainTex&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_Color&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
			&lt;span class=&quot;n&quot;&gt;o&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Albedo&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;rgb&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
			&lt;span class=&quot;n&quot;&gt;o&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Metallic&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_Metallic&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
			&lt;span class=&quot;n&quot;&gt;o&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Smoothness&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_Glossiness&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
			&lt;span class=&quot;n&quot;&gt;o&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Alpha&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
		&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;ENDCG&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;FallBack&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;Diffuse&quot;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;blockquote&gt;
  &lt;p&gt;Как работает поверхностный шейдер?&lt;/p&gt;

  &lt;p&gt;Написание шейдеров, взаимодействующих с освещением, это сложная задача. Есть различные типы источников света, различные варианты теней, различные пути рендеринга - прямой (forward) и отложенный (deferred), и шейдер должен как-то управлять всей этой сложностью. Шейдеры поверхности в Unity – это подход к созданию кода, который упрощает написание. Если вы хотите узнать больше о шейдерах, вы можете ознакомиться с серией туторов по &lt;a href=&quot;http://catlikecoding.com/unity/tutorials/rendering/part-1/&quot;&gt;Рендерингу&lt;/a&gt; (пока не переведено)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Наш новый шейдер имеет: сплошной цвет, текстуру, а также глянцевую и металлическую поверхности. Поскольку мы будем определять цвет по позиции точки графика в пространстве, нам не понадобится ни сплошной цвет, ни текстура. В приведенном ниже коде все ненужные строки закомментированы. Оставим только альбедо со значением сплошного черного цвета и альфа-канал равный единице.&lt;/p&gt;

&lt;div class=&quot;language-c# highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;Shader&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;Custom/ColoredPoint&quot;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;Properties&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;//		_Color (&quot;Color&quot;, Color) = (1,1,1,1)&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;//		_MainTex (&quot;Albedo (RGB)&quot;, 2D) = &quot;white&quot; {}&lt;/span&gt;
		&lt;span class=&quot;nf&quot;&gt;_Glossiness&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Smoothness&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;Range&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;0.5&lt;/span&gt;
		&lt;span class=&quot;nf&quot;&gt;_Metallic&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Metallic&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;Range&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;0.0&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;SubShader&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;Tags&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;RenderType&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Opaque&quot;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;LOD&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;200&lt;/span&gt;
		
		&lt;span class=&quot;n&quot;&gt;CGPROGRAM&lt;/span&gt;
		&lt;span class=&quot;err&quot;&gt;#&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pragma&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;surface&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;surf&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Standard&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fullforwardshadows&lt;/span&gt;

		&lt;span class=&quot;err&quot;&gt;#&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pragma&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;target&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;3.0&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;//		sampler2D _MainTex;&lt;/span&gt;

		&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Input&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;//			float2 uv_MainTex;&lt;/span&gt;
		&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;

		&lt;span class=&quot;n&quot;&gt;half&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_Glossiness&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;half&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_Metallic&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;//		fixed4 _Color;&lt;/span&gt;

		&lt;span class=&quot;nf&quot;&gt;UNITY_INSTANCING_CBUFFER_START&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Props&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;UNITY_INSTANCING_CBUFFER_END&lt;/span&gt;

		&lt;span class=&quot;k&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;surf&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Input&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;IN&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;inout&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;SurfaceOutputStandard&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;o&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;//			fixed4 c = tex2D (_MainTex, IN.uv_MainTex) * _Color;&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;//			o.Albedo = c.rgb;&lt;/span&gt;
			&lt;span class=&quot;n&quot;&gt;o&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Metallic&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_Metallic&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
			&lt;span class=&quot;n&quot;&gt;o&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Smoothness&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_Glossiness&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;//			o.Alpha = c.a;&lt;/span&gt;
			&lt;span class=&quot;n&quot;&gt;o&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Alpha&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
		&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;ENDCG&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;FallBack&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;Diffuse&quot;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;blockquote&gt;
  &lt;p&gt;Что такое альбедо и альфа-канал?&lt;/p&gt;

  &lt;p&gt;Цвет диффузного отражения материала называется альбедо. В нем описывается сколько каналов красного, зеленого и синего отражено диффузно. Остальное поглощается.&lt;/p&gt;

  &lt;p&gt;Альфа-канал используется как мера непрозрачности. При альфа-канале равным нулю поверхность полностью прозрачная, в то время как при альфа-канале равным единице она полностью непрозрачна.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;На этом этапе шейдер не скомпилируется, поскольку поверхностные шейдеры не могут работать с пустой входной структурой. В ней мы определяем, какие пользовательские данные необходимы для окрашивания пикселей. В нашем случае, нам нужна позиция точки. Мы можем получить доступ к позиции объекта в глобальной системе координат, добавив &lt;code class=&quot;highlighter-rouge&quot;&gt;float3 worldPos;&lt;/code&gt; в структуру &lt;code class=&quot;highlighter-rouge&quot;&gt;Input&lt;/code&gt;.&lt;/p&gt;

&lt;div class=&quot;language-c# highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Input&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;float3&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;worldPos&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;blockquote&gt;
  &lt;p&gt;Говорит ли это о том, что перемещение объекта Graph повлияет на его цвет?&lt;/p&gt;

  &lt;p&gt;Да. При таком подходе окраска будет правильно только до тех пор, пока &lt;code class=&quot;highlighter-rouge&quot;&gt;Graph&lt;/code&gt; находится в начале координат.&lt;/p&gt;

  &lt;p&gt;Также обратите внимание, что эта позиция определяется для каждой вершины. В нашем случае для каждого угла куба. Цвет будет интерполирован по его граням. Чем больше кубики, тем более очевидным будет цветовой переход.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Теперь, когда у нас есть функционирующий шейдер, создайте для него материал с именем &lt;em&gt;Colored Point&lt;/em&gt;. Перетяните шейдер на материал или выберите в выпадающем меню &lt;em&gt;Custom / Colored Point&lt;/em&gt;.&lt;/p&gt;

&lt;center&gt;&lt;img src=&quot;\images\2018\02\BuildingGraph\colored-point-material.png&quot; /&gt;&lt;/center&gt;
&lt;p&gt;&lt;em&gt;&lt;center&gt;Материал для раскраски точек. &lt;/center&gt;&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Пусть префаб нашего куба использует этот материал вместо материала по умолчанию. Это можно сделать просто перетащим наш материала на префаб.&lt;/p&gt;

&lt;h2 id=&quot;32-Изменение-цвета-основанное-на-изменении-глобальных-координат&quot;&gt;&lt;strong&gt;3.2 Изменение цвета, основанное на изменении глобальных координат&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;Если мы нажмем кнопку воспроизведения, то наш график будет создать экземпляры черных кубов. Чтобы изменить их цвет, мы должны изменить переменную &lt;code class=&quot;highlighter-rouge&quot;&gt;o.Albedo&lt;/code&gt;. Вместо того чтобы присваивать ему ноль, присвойте свойству отвечающего за красный цвет значение координаты X.&lt;/p&gt;

&lt;div class=&quot;language-c# highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;//	o.Albedo = 0;&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;o&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Albedo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;r&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;IN&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;worldPos&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;center&gt;&lt;img src=&quot;\images\2018\02\BuildingGraph\colored-graph-x.png&quot; /&gt;&lt;/center&gt;
&lt;p&gt;&lt;em&gt;&lt;center&gt;График, цвет которого регулируется координатой X. &lt;/center&gt;&lt;/em&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Разве мы не должны инициализировать &lt;code class=&quot;highlighter-rouge&quot;&gt;o.Albedo&lt;/code&gt;?&lt;/p&gt;

  &lt;p&gt;Нам не нужно устанавливать значения для свойств отвечающие за зеленый и синий цвет, потому что они им уже было установлено значение нуля перед тем как был вызван метод &lt;code class=&quot;highlighter-rouge&quot;&gt;surf&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Кубы имеющие положительное значение координаты по оси X постепенно становятся красными. А вот кубы имеющие отрицательные значения по оси X остаются черными, потому что цвета не могут быть отрицательными. Чтобы получить более плавный переход в красный цвет, необходимо в двое сократить координаты X и прибавить 0.5.&lt;/p&gt;

&lt;div class=&quot;language-c# highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;o&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Albedo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;r&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;IN&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;worldPos&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;0.5&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;0.5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;center&gt;&lt;img src=&quot;\images\2018\02\BuildingGraph\colored-graph-x-normalized.png&quot; /&gt;&lt;/center&gt;
&lt;p&gt;&lt;em&gt;&lt;center&gt;Плавный переход &lt;/center&gt;&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Давайте также использовать координату по оси Y для регулирования свойства отвечающего за зеленый цвет. В файле шейдера это можно сделать одним простым движением, заменив &lt;code class=&quot;highlighter-rouge&quot;&gt;o.Albedo.r&lt;/code&gt; на &lt;code class=&quot;highlighter-rouge&quot;&gt;o.Albedo.rg&lt;/code&gt; и &lt;code class=&quot;highlighter-rouge&quot;&gt;IN.worldPos.x&lt;/code&gt; на &lt;code class=&quot;highlighter-rouge&quot;&gt;IN.worldPos.xy&lt;/code&gt;.&lt;/p&gt;

&lt;div class=&quot;language-c# highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;o&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Albedo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;rg&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;IN&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;worldPos&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;xy&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;0.5&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;0.5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;center&gt;&lt;img src=&quot;\images\2018\02\BuildingGraph\colored-graph-xy.png&quot; /&gt;&lt;/center&gt;
&lt;p&gt;&lt;em&gt;&lt;center&gt;Изменение цвета в зависимости от положения по осям X и Y&lt;/center&gt;&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Красный плюс зеленый равен желтому, поэтому наш график плавно переходит от светло-зеленого к желтому цвету. Поскольку график по оси Y начинает отображаться с позиции равной -1, то в этом положении он имеет темно-зеленый цвет. Чтобы проверить мое утверждение измените нашу функцию с квадратичной параболы на кубическую. Формула кубической параболы выглядит так: &lt;script type=&quot;math/tex&quot;&gt;f(x) = x^3&lt;/script&gt;.&lt;/p&gt;

&lt;div class=&quot;language-c# highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;position&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;y&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;position&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;position&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;position&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;center&gt;&lt;img src=&quot;\images\2018\02\BuildingGraph\x-cubed.png&quot; /&gt;&lt;/center&gt;
&lt;p&gt;&lt;em&gt;&lt;center&gt;Кубическая парабола лежащая в диапазоне (-1,+1)&lt;/center&gt;&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;\content\2018\02\BuildingGraph\coloring-the-graph.unitypackage&quot;&gt;3. unitypackage&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;4-Анимируем-график&quot;&gt;&lt;strong&gt;4. Анимируем график&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;Отображение графика в статическом положении безусловно полезно, но движущийся график более интересен для просмотра. Поэтому давайте добавим поддержку анимации для функций. Это делается путем добавления времени в качестве дополнительного параметра функции. Таким образом наша функция изменится с &lt;script type=&quot;math/tex&quot;&gt;f(x)&lt;/script&gt; на &lt;script type=&quot;math/tex&quot;&gt;f(x,t)&lt;/script&gt;.&lt;/p&gt;

&lt;h2 id=&quot;41-Отслеживание-точек&quot;&gt;&lt;strong&gt;4.1 Отслеживание точек&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;Чтобы заставить наш график двигаться, нам придется корректировать положения его точек в данный момент времени. Первое что приходит в голову это каждый раз удалять все точки и заново создавать, но уже в новой позиции. Отличная идея, но неэффективная. Гораздо лучше использовать уже созданные нами точки, просто корректируя их положение в зависимости от параметра времени. Сделать это проще всего можно путем добавления поля, которое будет содержать в себе ссылки на все наши точки. Создадим поле &lt;code class=&quot;highlighter-rouge&quot;&gt;points&lt;/code&gt; в скрипте &lt;code class=&quot;highlighter-rouge&quot;&gt;Graph&lt;/code&gt; типа &lt;code class=&quot;highlighter-rouge&quot;&gt;Transform&lt;/code&gt;.&lt;/p&gt;

&lt;div class=&quot;language-c# highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;Transform&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;points&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Созданное только что поле позволяет нам ссылаться на одну точку, но нам нужна не одна, а множество точек. В языке C# и во многих других языках уже существует готовая конструкция, позволяющая хранить в себе множество значений одного типа и называется она – массив. Для того чтобы превратить нашу обычную переменную в массив необходимо всего лишь добавить пару квадратных скобок после объявления типа переменной. Читаться такая конструкция будет как: «Создадим поле с именем &lt;code class=&quot;highlighter-rouge&quot;&gt;points&lt;/code&gt;, которое будет содержать в себе массив значений типа &lt;code class=&quot;highlighter-rouge&quot;&gt;Transform&lt;/code&gt;».&lt;/p&gt;

&lt;div class=&quot;language-c# highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;Transform&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[]&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;points&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Массив – это ссылочный тип данных, а не тип значений, потому при объявлении переменной мы обязаны передать ссылку на экземпляр данного массива, либо же объявить новый используя ключевое слово &lt;code class=&quot;highlighter-rouge&quot;&gt;new&lt;/code&gt;, далее указывается тип создаваемого экземпляра, который соответствует типу переменной, которой мы пытаемся присвоить значение &lt;code class=&quot;highlighter-rouge&quot;&gt;Transform[]&lt;/code&gt;. Мы ведь не хотим создавать массив при каждой итерации цикла, потому объявление сделаем перед циклом &lt;code class=&quot;highlighter-rouge&quot;&gt;for&lt;/code&gt;.&lt;/p&gt;
&lt;div class=&quot;language-c# highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;points&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Transform&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[];&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;resolution&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;++)&lt;/span&gt; 
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;err&quot;&gt;…&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Необходимо помнить одну очень важную особенность всех массивов: они создаются фиксированной длины. Размерность массива определяет сколько элементов может в нем храниться. Если нам нужно будет увеличить размерность массива, то нужно будет создавать новый экземпляр с нужной нам длиной. Размерность массива указывается внутри квадратных скобок при объявлении. В нашем случае его длина равна разрешению (&lt;code class=&quot;highlighter-rouge&quot;&gt;resolution&lt;/code&gt;).&lt;/p&gt;

&lt;div class=&quot;language-c# highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;points&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Transform&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;resolution&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Теперь, наконец-то, мы можем заполнить наш массив ссылками на наши точки. Доступ к элементам массива можно получить путем указания нужного индекса в квадратных скобках после переменной. Нумерация элементов массива начинается с нуля, так же, как и наш цикл. Таким образом, мы можем использовать итератор цикла для доступа к нужному нам элементу массива.&lt;/p&gt;

&lt;div class=&quot;language-c# highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;points&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Transform&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;resolution&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;resolution&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;++)&lt;/span&gt; 
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;err&quot;&gt;…&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;points&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;point&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;42-Перенос-логики-в-метод-update&quot;&gt;&lt;strong&gt;4.2 Перенос логики в метод Update.&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;Нельзя заставить двигаться график, прописав его создание в методе, который вызывается всего 1 раз. Чтобы у нас получилась красивая анимация нам нужно перенести часть логики в метод &lt;code class=&quot;highlighter-rouge&quot;&gt;Update&lt;/code&gt;. В результате нем не нужно будет вычислять положение точек в месте их создания. Однако инициализацию некоторых переменных, чье значение должно быть нулевым на момент их изменения мы сотавим в блоке &lt;code class=&quot;highlighter-rouge&quot;&gt;Awake&lt;/code&gt;. Код ниже отображает изменения в методе &lt;code class=&quot;highlighter-rouge&quot;&gt;Awake&lt;/code&gt;.&lt;/p&gt;

&lt;div class=&quot;language-c# highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;position&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;y&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;0f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;position&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;z&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;0f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;resolution&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;++)&lt;/span&gt; 
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;Transform&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;point&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;Instantiate&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pointPrefab&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;position&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;0.5f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;step&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;1f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;//	position.y = position.x * position.x * position.x;&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;point&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;localPosition&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;position&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;point&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;localScale&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;scale&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;point&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;SetParent&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;transform&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;points&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;point&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Добавьте пустой цикл &lt;code class=&quot;highlighter-rouge&quot;&gt;for&lt;/code&gt; в метод &lt;code class=&quot;highlighter-rouge&quot;&gt;Update&lt;/code&gt;&lt;/p&gt;

&lt;div class=&quot;language-c# highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;Update&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; 
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;resolution&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;++)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Теперь проговорим что нам нужно. Нам нужно пройтись по нашему массиву точек и установить каждой точке координаты по оси Y. Поскольку длина массива совпадает с &lt;code class=&quot;highlighter-rouge&quot;&gt;resolution&lt;/code&gt;, мы можем использовать эту переменную для граничного значения счетчика массива. Но мало ли что может произойти с нашим массивом, вдруг приедет хипстер на голубом самокате и изменит размерность массива? В реальности, конечно, такое маловероятно, но давайте просто воспользуемся встроенным C# свойством &lt;code class=&quot;highlighter-rouge&quot;&gt;Length&lt;/code&gt;, которое хранит в себе длину нашего массива.&lt;/p&gt;

&lt;div class=&quot;language-c# highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;points&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Length&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;++)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Мы проходим по всем элементам массива, получая текущую позицию для каждой точки. Далее получаем нужное нам значение, отвечающее за позицию в локальной системе координат.&lt;/p&gt;

&lt;div class=&quot;language-c# highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;points&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Length&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;++)&lt;/span&gt; 
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;Transform&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;point&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;points&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;Vector3&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;position&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;point&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;localPosition&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Далее получим значение для текущей точки в соответствии с нашей формулой &lt;script type=&quot;math/tex&quot;&gt;f(y) = x^3&lt;/script&gt;&lt;/p&gt;

&lt;div class=&quot;language-c# highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;points&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Length&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;++)&lt;/span&gt; 
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;Transform&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;point&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;points&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;Vector3&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;position&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;point&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;localPosition&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;position&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;y&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;position&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;position&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;position&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Поскольку &lt;code class=&quot;highlighter-rouge&quot;&gt;Vector3&lt;/code&gt; содержит в себе лишь значения (он не является игровым объектом), то значение получившихся координат нужно присвоить нашей точке.&lt;/p&gt;

&lt;div class=&quot;language-c# highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;points&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Length&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;++)&lt;/span&gt; 
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;Transform&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;point&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;points&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;Vector3&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;position&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;point&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;localPosition&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;position&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;y&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;position&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;position&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;position&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;point&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;localPosition&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;position&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;blockquote&gt;
  &lt;p&gt;А разве мы не можем сделать так: &lt;code class=&quot;highlighter-rouge&quot;&gt;point.localPosotion.y&lt;/code&gt;?&lt;/p&gt;

  &lt;p&gt;Если бы &lt;code class=&quot;highlighter-rouge&quot;&gt;localPosition&lt;/code&gt; было полем, то это было бы возможно. Мы могли бы напрямую задать координату Y. Однако &lt;code class=&quot;highlighter-rouge&quot;&gt;localPosition&lt;/code&gt; является свойством. Оно может передать и принять только значение вектора. Таким образом, мы пытаем скорректировать позицию в локальной системе координат, которая вообще никак не влияет на положение точки. И поскольку мы явно не сохранили его в переменно, операция бессмысленна и вызовет ошибку компилятора.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;43-Отобразим-синусоиду&quot;&gt;&lt;strong&gt;4.3 Отобразим синусоиду&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;С этого момента, если мы перейдем в режим воспроизведения, то точки нашего графика будут менять свое положение каждый кадр. Одна проблема: мы не замечаем никаких изменений, потому что они всегда остаются на одних и тех же позициях.  Для того чтобы изменить текущее положение дел надо наконец-то добавить зависимость нашей функции от времени. Однако стоит сразу сделать не большую оговорку: простое добавление времени приведет к тому что наша функция просто уползет куда-то в сторону бесконечности. Чтобы подобного не произошло мы должны использовать функцию, которая изменяется, но остается в фиксированном диапазоне. Функция синуса идеально подойдет для этого. В стандартной библиотеке Unity есть уже готовая структура для работы с математическими функциями - &lt;code class=&quot;highlighter-rouge&quot;&gt;Mathf&lt;/code&gt;. В ней есть метод &lt;code class=&quot;highlighter-rouge&quot;&gt;Sin&lt;/code&gt;, который возвращает значение синуса от переменной, которую мы передадим в качестве аргумента. В данном случае мы хотим отобразить функцию вида &lt;script type=&quot;math/tex&quot;&gt;f(y) = sin(x)&lt;/script&gt;, потому мы должный координате в оси Y присвоить значение синуса от координаты X.&lt;/p&gt;

&lt;div class=&quot;language-c# highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;position&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;y&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Mathf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;Sin&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;position&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;blockquote&gt;
  &lt;p&gt;Что за Mathf?&lt;/p&gt;

  &lt;p&gt;Это структура, содержащая в себе набор математических функций и констант для работы с числами и векторами. В пространстве имен &lt;code class=&quot;highlighter-rouge&quot;&gt;System&lt;/code&gt; уже есть подобная структура, которая называется &lt;code class=&quot;highlighter-rouge&quot;&gt;Math&lt;/code&gt;. Отличие в том, что &lt;code class=&quot;highlighter-rouge&quot;&gt;Mathf&lt;/code&gt; работает с числами типа &lt;code class=&quot;highlighter-rouge&quot;&gt;float&lt;/code&gt; и векторами, а &lt;code class=&quot;highlighter-rouge&quot;&gt;Math&lt;/code&gt; с числами типа &lt;code class=&quot;highlighter-rouge&quot;&gt;double&lt;/code&gt; и в ней вообще такого типа как вектор.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Синусоида меняется в диапазоне от &lt;script type=&quot;math/tex&quot;&gt;(-1,+1)&lt;/script&gt;. Данная функция циклична и повторяется каждые &lt;script type=&quot;math/tex&quot;&gt;2\pi&lt;/script&gt; юнита, что примерно равно 6.28. Если так же масштабировать параметр времени на &lt;script type=&quot;math/tex&quot;&gt;\pi&lt;/script&gt;, функция будет повторяться каждые две секунды. В итоге получим вот такую функцию: &lt;script type=&quot;math/tex&quot;&gt;f(x,t) = sin(\pi(x+t))&lt;/script&gt;, где &lt;script type=&quot;math/tex&quot;&gt;t&lt;/script&gt; это прошедшее время с момента запуска сцены. Этот параметр будет двигать синусоиду (волну), смещая ее в отрицательном направлении по оси X.&lt;/p&gt;

&lt;center&gt;&lt;img src=&quot;\content\2018\02\BuildingGraph\FlamboyantCheapHoki-small.gif&quot; /&gt;&lt;/center&gt;
&lt;p&gt;&lt;em&gt;&lt;center&gt;Анимированная функция&lt;/center&gt;&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Итоговый вариант от автора урока: &lt;a href=&quot;\content\2018\02\BuildingGraph\animating-the-graph.unitypackage&quot;&gt;4. unitypackage&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Итоговый вариант от переводчика: &lt;a href=&quot;http://catlikecoding.com/unity/tutorials/basics/building-a-graph/&quot;&gt;5. unitypackage&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Следующий урок: Математические поверхности&lt;/p&gt;

&lt;script id=&quot;dsq-count-scr&quot; src=&quot;//https-vangogih-github-io.disqus.com/count.js&quot; async=&quot;&quot;&gt;&lt;/script&gt;

&lt;script type=&quot;text/javascript&quot; src=&quot;https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML&quot;&gt;
&lt;/script&gt;</content><author><name></name></author><summary type="html">Построение графика. Математическая визуализация Создадим префаб. Создадим линию из кубов. Отобразим математическую функцию. Создадим свой собственный шейдер. Анимируем наш график. В этом уроке мы будем использовать игровые объекты для построения графиков по математическим формулам. Мы также сделаем функцию, зависящую от времени, в результате чего получится анимация графика. Этот урок предполагает, что вы ознакомились с уроком Игровые объекты и скрипты. Этот урок, как и прошлый был сделан в Unity версии 2017.1.0. Синусоида из кубов 1.Создадим линию из кубов Хорошее понимание математики имеет важное значение при программировании. На своем фундаментальном уровне математика – это манипулирование символами, представляющие числа. Решение уравнений сводится к переписыванию одного набора символов, который становится другим – обычно более коротким набором символов. Правила математики диктуют как именно это переписывание может быть сделано. Например, у нас есть функция . Мы можем заменить , скажем на 3. Тогда получится . Мы передали 3 как входное значение параметра , а на выходе получили значение 4 как результат выполнения некоторой математической функции. Так же мы можем сказать, что это функция map 3 к 4. В более коротком виде это можно записать так: . Мы можем создать множества пар формы . Например, (5,6), (8,9), (1,2), (6,7). Но легче понять функцию, когда мы упорядочиваем пары по входным-выходным значениям. (1,2), (2,3), (3,4) и т.д. Функция проста для понимания. сложна. Мы бы могли записать несколько пар ввода-вывода, но это, вероятно, не даст нам понимания о том, как выглядит график этой функции. Нам нужно будет записать множество точек, которые находятся близко друг к другу. Как результат мы получим море чисел, которые очень сложно разобрать. Вместо этого мы могли бы интерпретировать пары как двумерные координаты вида . Это 2D вектор где вверху представлены координаты по оси Х, а внизу координаты для оси Y. По другому еще это можно записать так: . Если мы будем использовать достаточное количество точек, то результатом соединения точек друг за другом станет график. График построенный на интервале от -2 до 2 Визуализация может быстро дать нам представление о том, как ведет себя функция. Это очень удобный инструмент, потому давайте сделаем подобное в Unity. Для начала создайте пустую сцену File / New Scene или используйте сцену по умолчанию, которая создается при создании нового проекта. 1.1 Префабы Графики создаются путем размещения точек по соответствующим координатам. Для этого нам понадобится 3D визуализация точки. Мы не будем изобретать велосипед, потому будем использовать объект, который доступен в Unity по умолчанию – куб. Добавим один на нашу сцену и удалим у него коллайдер, потому что нам не нужно чтобы куб взаимодействовал с другими объектами. Являются ли кубы лучшим решением для визуализации графиков? Можно так же использовать систему частиц или сегменты линий, но проще всего использовать отдельные кубы. Мы будем использовать скрипт, чтобы создать много экземпляров этого куба и расположить их правильно. Для этого мы будем использовать куб в качестве шаблона. Перетащите куб из окна иерархии в окно проекта. Это позволит создать новый объект со значком синего куба, этого объект более известен как префаб (Prefab). Это готовый игровой объект, который существует в проекте, но не на сцене. Префаб куба Префабы – удобный способ настройки игровых объектов. При изменении главного префаба, который находится в проекте, все его экземпляры в любой сцене изменяются одинаково. Например, изменение масштаба префаба так же изменит масштаб куба, который все еще находится на сцене. Однако каждый экземпляр использует свое собственное положение и поворот. Кроме того, свойства у каждого игрового объекта можно изменить, никак не повлияв на префаб, но это отходит от сути ради которой был создан префаб. При больших изменениях, таких как добавление или удаление компонента, связь между префабом и экземпляром будет нарушена. Мы хотим написать скрипт для создания экземпляров префаба, поэтому нам больше не нужен экземпляр куба, который в настоящее время находится на сцене. Просто удалите его. 1.2 Компонент Graph Нам понадобится скрипт на C# для того чтобы создать наш график. Давайте создадим один, и назовем его Graph. Мы начнем с простого класса, который будет расширять класс MonoBehavior , так его можно использовать как компонент для игровых объектов. Создадим публичное поле, которое будет ссылаться на префаб для создания точек, дадим ему имя pointPrefab. Так как нам понадобится доступ к компоненту Transform для позиционирования точек, то установим этот тип у нашего поля. using UnityEngine; public class Graph : MonoBehaviour { public Transform pointPrefab; } Добавим пустой игровой объект на сцену, с помощью GameObject /Create Empty, установим его в начале, и назовем его Graph. Добавим наш скрипт Graph к этому объекту, с помощью переноса или кнопки Add Component. Затем перетащим наш префаб из окна проекта в созданное нами поле Point Prefab. Теперь он ссылается на компонент префаба – Transform. Объект Graph с компонентом Graph, который содержит ссылку на префаб Cube 1.3 Создание экземпляров префаба Создание экземпляра объекта игры осуществляется через метод Instantiate. Это общедоступный метод, который мы получили из класса object, от которого неявно наследуется MonoBehaviour. Метод Instantiate клонирует любой объект и добавляет его на сцену. В качестве аргумента он принимает любой объект, который есть в Unity. Если мы укажем в качестве аргумента наш префаб, то в результате мы увидим, как наш куб появится на сцене. Давайте вызовем этот метод в момент, когда наш Graph «пробуждается». public class Graph : MonoBehaviour { public Transform pointPrefab; void Awake () { Instantiate(pointPrefab); } } Создание экземпляра префаба На данном этапе при переходе в режим воспроизведения будет создан один куб в начале координат, при условии, что позиция префаба будет равна нулю. Чтобы переместить его в другое место, нам нужно изменить положение нашего только что созданного экземпляра. Метод Instantiate возвращается ссылку на все, что он создал. Поскольку мы передали в метод ссылку на компонент Transform, то давайте попросим его вернуть нам ссылку на этот же компонент, но уже у экземпляра префаба. Создадим переменную типа Transform и присвоим ей возвращаемое значение метода Instantiate. void Awake () { Transform point = Instantiate(pointPrefab); } Теперь мы можем задать положение точки, назначив ей нужное нам значение 3D вектора. Вспомните как мы задавали положение стрелкам часов в предыдущем уроке Игровые объекты и скрипты. Точно так же мы будем делать и для точек графика. Мы будем изменять локальное положение через свойство localPosition, а не через position. 3D вектора создаются при помощи структуры Vector3. Поскольку это структура, то используется она в контексте значения, примерно так же как число, она не является объектом. Например, можно вручную установть координату X равной 1, оставив координаты Y и Z равные нулю, но можно использовать свойство Vector3.right которое хранит в себе значения для координат X,Y,Z равные (+1,0,0). Transform point = Instantiate(pointPrefab); point.localPosition = Vector3.right; Разве свойства не должны писаться с большой буквы? По негласному соглашению так и есть. Мы должны давать имена свойствам с заглавной буквы, но в Unity очень часто пренебрегают этим. При переходе в режим игры мы все равно получаем один куб, только в немного другой позиции. Давайте создадим второй экземпляр, сместив его немного вправо. Это можно сделать, умножив наш вектор на 2. Продублируйте строку с созданием экземпляра объекта и строку с изменением позиции, но умножив правый вектор на 2 Vector3.right *2. Transform point = Instantiate(pointPrefab); point.localPosition = Vector3.right; Transform point = Instantiate(pointPrefab); point.localPosition = Vector3.right * 2f; Можем ли мы перемножать структуры и числа? “Из под коробки” такого функционала нет, но можно добавить его. Это делается путем создания метода со специальным синтаксисом, который перегружает символ умножения *. В этом случае, то, что кажется простым умножением, но на самом деле является вызовом метода, что-то вроде Vector3.Multiply(Vector3.right, 2f). Возможность использовать методы, как если бы они были простыми операциям, делает написание кода более быстрым и легким для чтения. Это не особо важно, но приятно иметь такую возможность, так же, как возможность неявно использовать пространства имен. Такой более удобное написание называется синтаксическим сахаром. Но когда мы внедряем подобный сахар, то мы должны быть уверены, что подобное сокращение не приведет к двузначности в понимании нашего сокращения. Методы, должны выполнять только то, что определено конкретным символом (сложение, умножение, деление и т.д.). В случае векторов некоторые математические операторы четко определены, поэтому мы можем спокойно использовать сахар для векторов. Код, который мы только что написали приведет к ошибке компиляции, потому что мы пытаемся определить переменную point дважды. Если мы хотим использовать другую переменную, мы должны дать ей другое имя. Нам уже не нужна ссылка на первую точку (куб), поэтому просто создайте новый экземпляр точки использовав ту же переменную. Transform point = Instantiate(pointPrefab); point.localPosition = Vector3.right; // Transform point = Instantiate(pointPrefab); point = Instantiate(pointPrefab); point.localPosition = Vector3.right * 2f; Два экземпляра с координатой по оси X равной 1 и 2. 1.4 Циклы Давайте создадим больше точек, например, 10. Мы, конечно, можем просто продублировать код, который у нас уже есть еще 8 раз, но это очень неэффективно. В идеале, мы пишем код только для одной точки и поручаем программе выполнить его несколько раз с небольшими изменениями. Ключевое слово while будет повторять блок кода, которые написан внутри него. Напишите while после него поставьте фигурные скобки {} и внутри этих скобок впишите первые 2 строки, остальное удалите. void Awake () { while { Transform point = Instantiate(pointPrefab); point.localPosition = Vector3.right; } // point = Instantiate(pointPrefab); // point.localPosition = Vector3.right * 2f; } Так же, как и оператор if оператор while должен иметь условие, которое указывается в круглых скобках. Как и в случае с if, следующий за условием блок кода будет выполняться только в том случае, если выражение имеет значение true. Если указанное условие истинно, то выполнится код, который описан внутри фигурных скобок, после этого программа вернется проверить выполнилось ли условие. Если нет, то цепочка действий будет повторяться до тех пор, пока условие не станет false. Поэтому мы должны создавать такое условие, которое точно выполнится через какой-то промежуток времени. Создание бесконечных циклов ни к чему хорошему не приводит. Программа просто зависает и перестает работать. Давайте добавим самое простое условие, которое точно не будет бесконечным циклом. while (false) { Transform point = Instantiate(pointPrefab); point.localPosition = Vector3.right; } Можем ли мы проинициализировать переменную внутри цикла? Конечно. Каждый раз, когда цикл будет повторяться он будет создавать новую переменную заданного типа с заданным именем, а по завершении удалять ее. Переменные, определенные вне цикла так же можно использовать. Но важно знать одну вещь: проинициализированная переменная внутри цикла будет доступна только в нем т.е. мы не сможем использовать эту переменную вне блока while. Ограничить количество итераций можно путем отслеживания того, сколько раз мы повторяли код. Мы можем использовать целочисленную переменную, чтобы отслеживать это. Пременная будет содержать в себе номер итерации цикла. Объявим новую переменную типа int и назовем её i от слова iteration. Нам нужно чтобы эта переменная хранила в себе номер итерации. Если мы ее объявим внутри цикла, то она будет постоянно объявляться заново, поэтому сделаем это вне цикла. void Awake () { int i; while (false) { Transform point = Instantiate(pointPrefab); point.localPosition = Vector3.right; } } На каждой итерации увеличиваем значение счетчика на единицу. void Awake () { int i; while (false) { i = i + 1; Transform point = Instantiate(pointPrefab); point.localPosition = Vector3.right; } } Если мы сейчас запустим наш код, то это приведет в ошибке компиляции. Это произошло потому что наша переменная не проинициализирована. Мы как бы пытаемся прибавить единицу к неопределённому значению, чего сделать конечно же невозможно*. Нужно явно указать значение, к которому будет прибавляться единица. Примечание от переводчика. Вы могли задаться вопросом: «Если мы не проинициализируем переменную и попытаемся узнать, чему она равна, то окажется что она равно нулю. Для чего тогда нам явно указывать то, что уже было сделано до нас?». В других языках, например, C++, при объявлении переменной её значение вообще заполнено «мусором». Оно может быть равно любому числу, которое попадает в диапазон, покрываемый значением типа int. При разработке на C# мы можем не задумываться об этом, мы знаем, что значение переменной по умолчанию равно нулю. Конструкцию i = i + 1; можно расшифровать как: «Возьми значение переменной i прибавь к нему единицу и получившееся значение присвой переменной i.» Но какое именно значение переменной нужно взять? 0? 1? 100000? Откуда именно начинать отсчет, никому не понятно. Разработчики языка учли этот момент и сделали обязательным инициализацию переменной, которой потом происходят какие-либо манипуляции. Чтобы не возникало путаницы, чтобы любому человеку, который будет работать с этим кодом было понятно откуда именно мы ведем отсчет. Так же это сделано для безопасности кода, мы ведь не знаем действительно ли значение по умолчанию равно нулю. Понимаю, звучит абсурдно, но мы можем обходными путями добиться того чтобы наши переменные имели какое угодно значение по умолчанию. Но мы пишем код на высокоуровневом языке программирования, зачем нам об это вообще думать. Так вот и не думайте, за вас уже этот момент продумали. Просто явно укажите откуда именно вы хотите вести счет. int i = 0; Проговорим что нам нужно. Нам нужно чтобы цикл выполнился определённое количество раз. Для этого мы создали счетчик. Когда цикл начинает выполняться, то i увеличивается на единицу. При первом проходе она равна 1, потом 2, потом 3 на 10 проходе она равна 9. Допустим я хочу, чтобы цикл закончил выполняться после 10 итераций. Значит нам нужно чтобы цикл выполнялся пока значение счетчика меньше 10. Математически это условие можно записать как . После того как мы проговорили это, нужно прописать это условие в коде: int i = 0; while (i &amp;lt; 10) { i = i + 1; Transform point = Instantiate(pointPrefab); point.localPosition = Vector3.right; } Теперь после перехода в режим воспроизведения мы получим 10 кубов. Но все они окажутся в одной позиции. Чтобы переместить их в ряд вдоль оси X, умножьте правый вектор на i. point.localPosition = Vector3.right * i; Десять кубов в ряд. Обратите внимание, что сейчас координаты первого куда по оси X начинаются с 1, а заканчиваются 10. Это не много не то что мы хотели. Поскольку счет мы начинаем с 0, то хотим чтобы наш первый куб был с координатой 0. Мы можем сдвинуть все точки на одну единицу влево, умножив наш вектор на i-1 вместо i. Но подобные вещи в программировании принято называть костылями. Но у нас есть более элегантное решение. while (i &amp;lt; 10) { // i = i + 1; Transform point = Instantiate(pointPrefab); point.localPosition = Vector3.right * i; i = i + 1; } 1.5 Лаконичный синтаксис Использование циклов очень распространено в программировании. В любой ситуации где наши действия нужно выполнить несколько раз используется цикл. Чем сложнее код внутри цикла, тем сложнее понять, что он делает. Для упрощения чтения и понимания кода существует такая вещь как «синтаксический сахар». Например, давайте рассмотрим увеличение операцию инкремента. Увеличение счетчика на единицу мы можем написать так: i = i + 1;, но можем и так i += 1;. Подобные сокращения и называются синтаксическим сахаром. // i = i + 1; i += 1; Но и в данной ситуации можно «добавить сахара» заменив i += 1; на ++i;. // i += 1; ++i; Стоит так же сказать об интересной особенности использования данного сахара. Подобные конструкции могут использоваться в качестве выражений. Это означает, что вы можете написать что-то вроде y = (x += 3). Это можно расшифровать как: «Присвоить Y значение равное X + 3». Из этого можно сделать вывод что инкремент (увеличение) i мы могли бы сделать внутри условия цикла while, тем самым сократив блок кода. while (++i &amp;lt; 10) { Transform point = Instantiate(pointPrefab); point.localPosition = Vector3.right * i; // ++i; } Однако, сейчас мы увеличиваем i до сравнения, а не после. Это приведет к меньшему числу итераций нежели хотим мы. Специально для таких ситуаций операторы инкремента и декремента также могут быть размещены после переменной, а не перед ней. //while (++i &amp;lt; 10) { while (i++ &amp;lt; 10) { Transform point = Instantiate(pointPrefab); point.localPosition = Vector3.right * i; } Хотя цикл while работает для всех типов циклов, существует альтернативный синтаксис, особенно подходящий для итерации по диапазонам. Это цикл for. Он работает так же, как и while, за исключением того, что объявление переменной итератора и ее сравнение содержатся в круглых скобках и разделяются точкой с запятой. //int i = 0; //while (i++ &amp;lt; 10) { for (int i = 0; i++ &amp;lt; 10) { Transform point = Instantiate(pointPrefab); point.localPosition = Vector3.right * i; } Фрагмент выше приведет к ошибке компиляции, потому что на самом деле есть три части. Третья часть отвечает за увеличение итератора, как бы сохраняя его отдельно от сравнения. //for (int i = 0; i++ &amp;lt; 10) { for (int i = 0; i &amp;lt; 10; i++) { Transform point = Instantiate(pointPrefab); point.localPosition = Vector3.right * i; } Почему в цикле for мы используем i++ а не ++i? Поскольку выражение инкремента не используется ни для чего другого, не имеет значения, какую из двух этих версий мы используем. Мы могли бы также использовать i += 1 или i = i + 1. Классический цикл for имеет форму for (int i = 0; i &amp;lt; someLimit; i++). Вы будете сталкиваться с подобной записью во многих других скриптах и программах. 1.6 Изменение области определения функции На данный момент нашим кубам даны координаты по оси X от 0 до 9. Это не удобный диапазон для работы с функциями. Чаще всего используется диапазон от 0 до 1. Или если мы работаем с функцией, которая симметрична относительно нуля то ее диапазон обычно равен . Давайте расположим наши кубы в соответствующем диапазоне. Расположение десятка кубов на отрезке длиной в две единицы приведет к их перекрытию. Чтобы предотвратить это надо уменьшить масштаб кубов. Каждый куб имеет размер 1 по всем осям по умолчанию. Для того чтобы сделать их подходящего размера нам нужно уменьшить их масштаб до . Мы можем сделать это установив масштаб каждого куба равный Vector3.one деленный на 5 т.е. принять значение масштаба для всех осей равный for (int i = 0; i &amp;lt; 10; i++) { Transform point = Instantiate(pointPrefab); point.localPosition = Vector3.right * i; point.localScale = Vector3.one / 5f; } Маленькие кубики. Чтобы снова собрать кубики вместе разделите их позицию на 5. point.localPosition = Vector3.right * i / 5f; Теперь наши кубики располагаются в диапазоне от . Но нам нужен диапазон , поэтому надо он нашей формулы отнять единицу. point.localPosition = Vector3.right * (i / 5f – 1); Сейчас у первого куба координата по оси X равна -1, в то время как последний куб имеет координату 0.8. Однако размер куба равен 0.2. Поскольку размер куб считается его центра, то левая сторона первого куба имеет координату X равной -1.1, в то время как правая сторона этого же куба имеет координату -0.9. Чтобы правильно заполнить диапазон нашими кубиками, мы должны сдвинуть их на половину куба вправо. Это можно сделать просто, добавив значение 0.5 к i перед операцией деления. Более подробнее узнать о том, как приводить какие-либо значения к нужному диапазону можно узнать из статьи на Википедии: Feature scaling. point.localPosition = Vector3.right * ((i + 0.5f) / 5f - 1f); 1.7 Выносим вектора за пределы цикла Хотя все кубы у нас имеют одинаковый масштаб, мы вычисляем его в каждой итерации цикла. С точки зрения производительности это не очень хорошо. Вместо этого мы могли бы вычислить его один раз перед циклом, сохранить его в переменной имеющей тип Vector3 и использовать эту переменную внутри цикла. void Awake () { Vector3 scale = Vector3.one / 5f; for (int i = 0; i &amp;lt; 10; i++) { Transform point = Instantiate(pointPrefab); point.localPosition = Vector3.right * ((i + 0.5f) / 5f - 1f); point.localScale = scale; } } Мы также можем определить переменную для позиции перед циклом. Поскольку мы создаем линию вдоль оси X, нам нужно изменять только координату X внутри цикла. Таким образом нам больше не нужно умножать нашу позицию на Vector3.right. Vector3 scale = Vector3.one / 5f; Vector3 position; for (int i = 0; i &amp;lt; 10; i++) { Transform point = Instantiate(pointPrefab); // point.localPosition = Vector3.right * ((i + 0.5f) / 5f - 1f); position.x = (i + 0.5f) / 5f - 1f; point.localPosition = position; point.localScale = scale; } Можем ли мы изменить составляющие вектора так как мне нужно? Vector3 это структура, которая содержит в себе три поля x, y и z типа float. Эти поля публичные, значит мы можем изменить их. Идея заключается в том, чтобы структуры должны быть неизменяемыми поскольку они как правило хранят в себе простые значения. Конечные структуры не должны изменяться. Если вы хотите использовать другое значение, создайте новую структуру поле или переменную как это мы делаем с числами. Если мы скажем что , а потом , то мы присвоим переменной X другое значение. Мы не использовали 3 чтобы получить 5, мы просто заменили одно значение другим. Хоть и структуры, содержащие в себе значения векторов и можно изменить в Unity, лучше избегать этого. Создайте новую переменную типа Vector3 и ей присвойте значение, взятое из структуры, а после изменяйте его как хотите. Манипуляции будут происходить только с объявленной вами переменной. Чтобы получить представление о том, как работать с изменяемыми векторами нужно рассмотреть использование Vector3 в качестве удобной замены для использования трех отдельных значений float. Вы можете получить к ним доступ независимо друг от друга, скопировать любое значение или объединить их в группу. Код выше приведет к ошибке компиляции, жалуясь на использование неназначенной переменной. Это происходит потому что мы назначаем позицию чему-то, не установив его начальные координаты по осям Y и Z. Явно установите их, присвоив им значение нуля. Vector3 position; position.y = 0f; position.z = 0f; for (int i = 0; i &amp;lt; 10; i++) { … } 1.8 Выражаем Y через X Идея заключается в том, что позиции наших кубов можно выразить как для отображения нашей функции. В настоящий момент координата Y равна нулю, что представляет собой тривиальную функцию . Чтобы наш график начал отображать хоть какую-либо зависимость мы должны изменить нашу функцию на для начала. Для этого нужно присваивать координате Y значение внутри цикла, а не перед ним. Vector3 position; //position.y = 0f; position.z = 0f; for (int i = 0; i &amp;lt; 10; i++) { Transform point = Instantiate(pointPrefab); position.x = (i + 0.5f) / 5f - 1f; position.y = position.x; point.localPosition = position; point.localScale = scale; } Y равен X. Не много менее очевидная функция , которая определяет параболу с вершиной в нуле. position.y = position.x * position.x; Y равен X в квадрате. 1. unitypackage 2. Создаем больше кубов. Хотя на данный момент у нас есть готовый график, но на данный момент он уродлив. Потому что мы используем только десять кубов, предложенная линия выглядит очень блочной и разрозненной. Было бы лучше, если бы мы использовали больше кубиков меньшего размера. 2.1. Различные разрешения. Вместо того, чтобы использовать фиксированное количество кубов, мы можем сделать его настраиваемым. Чтобы сделать это возможным, добавьте публичное целое поле, которое будет хранить в себе разрешение Graph (разрешение в данном контексте подразумевает количество кубов, которое будет использоваться для отображения графика. Как монитор компьютера, чем больше разрешение, тем точнее картинка. Так же и тут чем выше разрешение, тем точнее график). Дайте ему значение по умолчанию 10, которое мы используем сейчас. public int resolution = 10; Поле Resolution Идея заключается в том, что мы можем изменить разрешение графа, изменив это значение с помощью созданного нами поля в инспекторе. Однако не все целые числа являются допустимыми. Как минимум, числа должны быть положительными. Мы можем поручить инспектору обеспечить соблюдение попадания в определенный диапазон для нашего поля. Это делается путем записи Range в квадратные скобки перед определением поля. [Range] public int resolution = 10; Range -Тип атрибута, определяемый Unity. Атрибут-это способ присоединения метаданных к структурам кода, в данном случае к полю. Инспектор Unity проверяет, есть ли у поля добавленный атрибут Range. Если это так, он будет использовать ползунок вместо поля ввода по умолчанию для чисел. Однако для этого необходимо знать допустимый диапазон. Так Range имеет два параметра, для минимального и максимального значения. Давайте используем 10 и 100. Кроме того, атрибуты обычно записываются выше объявляемого поля или метода, а не перед ними. [Range(10, 100)] public int resolution = 10; Поле Resolution со слайдером Гарантирует ли это, что разрешение будет ограничено 10-100? Нет, что что делает атрибут Range это настраивает ползунок в инспекторе. Это в целом никак вообще не влияет на то какие значения будет принимать эта переменная. Мы можем в любом месте кода спокойно изменить значение этого поля на любое целое число, котором нам нравится. Но в нашем случае мы предполагаем, что значение регулируется только с помощью инспектора и нигде больше. 2.2 Создание различных экземпляров. Для того чтобы использовать разрешение, мы должны изменить количество кубов, которое мы создаем. Вместо использования циклов фиксированное количество раз в awake, количество итераций теперь ограничено разрешением. Теперь если разрешение установлено 50, мы создадим 50 кубов после входа в игровой режим. for (int i = 0; i &amp;lt; resolution; i++) { … } Мы также должны отрегулировать масштаб и положение кубов чтобы оставить их в позиции . Размер каждого шага, который мы будем делать каждую итерацию сейчас равен вместо обычного . Сохраните это значение в переменной и используйте его для вычисления масштаба кубов и их координат по оси X. void Awake () { float step = 2f / resolution; Vector3 scale = Vector3.one * step; Vector3 position; position.z = 0f; for (int i = 0; i &amp;lt; resolution; i++) { Transform point = Instantiate(pointPrefab); position.x = (i + 0.5f) * step - 1f; position.y = position.x * position.x; point.localPosition = position; point.localScale = scale; } } График со значением Resolution равным 50 2.3. Устанавливаем родителя После открытия режима с разрешением в 50, множество созданных кубов окажутся на сцене. Все точки графика являются корневыми. Эти Кубы в настоящее время являются корневыми объектами, хотя по сути они должны являться потомками объекта Graph. Мы можем установить эту связь после создания экземпляра куба, вызвав метод SetParent из компонента куба Transform. В качестве аргумента мы должны предоставить компонент Transform объекта, который будет для наших кубов родителем. Мы можем напрямую получить доступ к компоненту Transform объекта Graph через его свойство transform. for (int i = 0; i &amp;lt; resolution; i++) { Transform point = Instantiate(pointPrefab); position.x = (i + 0.5f) * step - 1f; position.y = position.x * position.x; point.localPosition = position; point.localScale = scale; point.SetParent(transform); } Все точки графика стали дочерними к объекту Graph. Когда новый родитель установлен, Unity попытается сохранить объект в исходном положении, вращении и масштабе. В нашем случае, нам это не нужно. Мы можем указать это, подставляя false в качестве второго аргумента SetParent. 2. unitypackage 3. Раскрасим график Белый график выглядит не очень презентабельно. МЫ могли бы использовать другой сплошной цвет, но это тоже не очень интересно. Что мы можем сделать, так это использовать позицию точки для определения ее цвета. Простой способ настройки цвета каждого куба можно сделать через свойство цвета материала куба. Мы можем сделать это в цикле. Поскольку каждый куб будет иметь свой цвет, это означает, что мы будем иметь один уникальный материал для каждого объекта. Хоть данная идея и реализуема, она не очень эффективна. Было бы на много проще, если бы могли использовать один материал, который изменял бы свой цвет в зависимости от своего положения в пространстве. К сожалению, в Unity нет такого материала. Так что давайте сами его создадим. 3.1 Создание собственного шейдера. GPU (graphic processing unit) или графический процессор отвечает за рендер (отображение) 3D-объектов. Материалы в Unity определяются при помощи шейдеров, который позволяют настраивать его свойства. Нам нужно создать пользовательский шейдер для получения нужной функциональности. Создайте таковой через : Assets / Create / Shader / Standard Surface Shader и дайте ему имя ColoredPoint. Пользовательский шейдер Теперь у нас есть файл c расширением shader, который мы можем открыть как обычный скрипт с синтаксисом отличным от языка C#. Наш файл шейдера содержит код для определения качеств, которые присущи нашему материалу. Ниже представлено содержимое файла, которое генерируется Unity. Все строки с комментариями удалены для краткости. Shader &quot;Custom/ColoredPoint&quot; { Properties { _Color (&quot;Color&quot;, Color) = (1,1,1,1) _MainTex (&quot;Albedo (RGB)&quot;, 2D) = &quot;white&quot; {} _Glossiness (&quot;Smoothness&quot;, Range(0,1)) = 0.5 _Metallic (&quot;Metallic&quot;, Range(0,1)) = 0.0 } SubShader { Tags { &quot;RenderType&quot;=&quot;Opaque&quot; } LOD 200 CGPROGRAM #pragma surface surf Standard fullforwardshadows #pragma target 3.0 sampler2D _MainTex; struct Input { float2 uv_MainTex; }; half _Glossiness; half _Metallic; fixed4 _Color; UNITY_INSTANCING_CBUFFER_START(Props) UNITY_INSTANCING_CBUFFER_END void surf (Input IN, inout SurfaceOutputStandard o) { fixed4 c = tex2D (_MainTex, IN.uv_MainTex) * _Color; o.Albedo = c.rgb; o.Metallic = _Metallic; o.Smoothness = _Glossiness; o.Alpha = c.a; } ENDCG } FallBack &quot;Diffuse&quot; } Как работает поверхностный шейдер? Написание шейдеров, взаимодействующих с освещением, это сложная задача. Есть различные типы источников света, различные варианты теней, различные пути рендеринга - прямой (forward) и отложенный (deferred), и шейдер должен как-то управлять всей этой сложностью. Шейдеры поверхности в Unity – это подход к созданию кода, который упрощает написание. Если вы хотите узнать больше о шейдерах, вы можете ознакомиться с серией туторов по Рендерингу (пока не переведено) Наш новый шейдер имеет: сплошной цвет, текстуру, а также глянцевую и металлическую поверхности. Поскольку мы будем определять цвет по позиции точки графика в пространстве, нам не понадобится ни сплошной цвет, ни текстура. В приведенном ниже коде все ненужные строки закомментированы. Оставим только альбедо со значением сплошного черного цвета и альфа-канал равный единице. Shader &quot;Custom/ColoredPoint&quot; { Properties { // _Color (&quot;Color&quot;, Color) = (1,1,1,1) // _MainTex (&quot;Albedo (RGB)&quot;, 2D) = &quot;white&quot; {} _Glossiness (&quot;Smoothness&quot;, Range(0,1)) = 0.5 _Metallic (&quot;Metallic&quot;, Range(0,1)) = 0.0 } SubShader { Tags { &quot;RenderType&quot;=&quot;Opaque&quot; } LOD 200 CGPROGRAM #pragma surface surf Standard fullforwardshadows #pragma target 3.0 // sampler2D _MainTex; struct Input { // float2 uv_MainTex; }; half _Glossiness; half _Metallic; // fixed4 _Color; UNITY_INSTANCING_CBUFFER_START(Props) UNITY_INSTANCING_CBUFFER_END void surf (Input IN, inout SurfaceOutputStandard o) { // fixed4 c = tex2D (_MainTex, IN.uv_MainTex) * _Color; // o.Albedo = c.rgb; o.Metallic = _Metallic; o.Smoothness = _Glossiness; // o.Alpha = c.a; o.Alpha = 1; } ENDCG } FallBack &quot;Diffuse&quot; } Что такое альбедо и альфа-канал? Цвет диффузного отражения материала называется альбедо. В нем описывается сколько каналов красного, зеленого и синего отражено диффузно. Остальное поглощается. Альфа-канал используется как мера непрозрачности. При альфа-канале равным нулю поверхность полностью прозрачная, в то время как при альфа-канале равным единице она полностью непрозрачна. На этом этапе шейдер не скомпилируется, поскольку поверхностные шейдеры не могут работать с пустой входной структурой. В ней мы определяем, какие пользовательские данные необходимы для окрашивания пикселей. В нашем случае, нам нужна позиция точки. Мы можем получить доступ к позиции объекта в глобальной системе координат, добавив float3 worldPos; в структуру Input. struct Input { float3 worldPos; }; Говорит ли это о том, что перемещение объекта Graph повлияет на его цвет? Да. При таком подходе окраска будет правильно только до тех пор, пока Graph находится в начале координат. Также обратите внимание, что эта позиция определяется для каждой вершины. В нашем случае для каждого угла куба. Цвет будет интерполирован по его граням. Чем больше кубики, тем более очевидным будет цветовой переход. Теперь, когда у нас есть функционирующий шейдер, создайте для него материал с именем Colored Point. Перетяните шейдер на материал или выберите в выпадающем меню Custom / Colored Point. Материал для раскраски точек. Пусть префаб нашего куба использует этот материал вместо материала по умолчанию. Это можно сделать просто перетащим наш материала на префаб. 3.2 Изменение цвета, основанное на изменении глобальных координат Если мы нажмем кнопку воспроизведения, то наш график будет создать экземпляры черных кубов. Чтобы изменить их цвет, мы должны изменить переменную o.Albedo. Вместо того чтобы присваивать ему ноль, присвойте свойству отвечающего за красный цвет значение координаты X. // o.Albedo = 0; o.Albedo.r = IN.worldPos.x; График, цвет которого регулируется координатой X. Разве мы не должны инициализировать o.Albedo? Нам не нужно устанавливать значения для свойств отвечающие за зеленый и синий цвет, потому что они им уже было установлено значение нуля перед тем как был вызван метод surf Кубы имеющие положительное значение координаты по оси X постепенно становятся красными. А вот кубы имеющие отрицательные значения по оси X остаются черными, потому что цвета не могут быть отрицательными. Чтобы получить более плавный переход в красный цвет, необходимо в двое сократить координаты X и прибавить 0.5. o.Albedo.r = IN.worldPos.x * 0.5 + 0.5; Плавный переход Давайте также использовать координату по оси Y для регулирования свойства отвечающего за зеленый цвет. В файле шейдера это можно сделать одним простым движением, заменив o.Albedo.r на o.Albedo.rg и IN.worldPos.x на IN.worldPos.xy. o.Albedo.rg = IN.worldPos.xy * 0.5 + 0.5; Изменение цвета в зависимости от положения по осям X и Y Красный плюс зеленый равен желтому, поэтому наш график плавно переходит от светло-зеленого к желтому цвету. Поскольку график по оси Y начинает отображаться с позиции равной -1, то в этом положении он имеет темно-зеленый цвет. Чтобы проверить мое утверждение измените нашу функцию с квадратичной параболы на кубическую. Формула кубической параболы выглядит так: . position.y = position.x * position.x * position.x; Кубическая парабола лежащая в диапазоне (-1,+1) 3. unitypackage 4. Анимируем график Отображение графика в статическом положении безусловно полезно, но движущийся график более интересен для просмотра. Поэтому давайте добавим поддержку анимации для функций. Это делается путем добавления времени в качестве дополнительного параметра функции. Таким образом наша функция изменится с на . 4.1 Отслеживание точек Чтобы заставить наш график двигаться, нам придется корректировать положения его точек в данный момент времени. Первое что приходит в голову это каждый раз удалять все точки и заново создавать, но уже в новой позиции. Отличная идея, но неэффективная. Гораздо лучше использовать уже созданные нами точки, просто корректируя их положение в зависимости от параметра времени. Сделать это проще всего можно путем добавления поля, которое будет содержать в себе ссылки на все наши точки. Создадим поле points в скрипте Graph типа Transform. Transform points; Созданное только что поле позволяет нам ссылаться на одну точку, но нам нужна не одна, а множество точек. В языке C# и во многих других языках уже существует готовая конструкция, позволяющая хранить в себе множество значений одного типа и называется она – массив. Для того чтобы превратить нашу обычную переменную в массив необходимо всего лишь добавить пару квадратных скобок после объявления типа переменной. Читаться такая конструкция будет как: «Создадим поле с именем points, которое будет содержать в себе массив значений типа Transform». Transform[] points; Массив – это ссылочный тип данных, а не тип значений, потому при объявлении переменной мы обязаны передать ссылку на экземпляр данного массива, либо же объявить новый используя ключевое слово new, далее указывается тип создаваемого экземпляра, который соответствует типу переменной, которой мы пытаемся присвоить значение Transform[]. Мы ведь не хотим создавать массив при каждой итерации цикла, потому объявление сделаем перед циклом for. points = new Transform[]; for (int i = 0; i &amp;lt; resolution; i++) { … } Необходимо помнить одну очень важную особенность всех массивов: они создаются фиксированной длины. Размерность массива определяет сколько элементов может в нем храниться. Если нам нужно будет увеличить размерность массива, то нужно будет создавать новый экземпляр с нужной нам длиной. Размерность массива указывается внутри квадратных скобок при объявлении. В нашем случае его длина равна разрешению (resolution). points = new Transform[resolution]; Теперь, наконец-то, мы можем заполнить наш массив ссылками на наши точки. Доступ к элементам массива можно получить путем указания нужного индекса в квадратных скобках после переменной. Нумерация элементов массива начинается с нуля, так же, как и наш цикл. Таким образом, мы можем использовать итератор цикла для доступа к нужному нам элементу массива. points = new Transform[resolution]; for (int i = 0; i &amp;lt; resolution; i++) { … points[i] = point; } 4.2 Перенос логики в метод Update. Нельзя заставить двигаться график, прописав его создание в методе, который вызывается всего 1 раз. Чтобы у нас получилась красивая анимация нам нужно перенести часть логики в метод Update. В результате нем не нужно будет вычислять положение точек в месте их создания. Однако инициализацию некоторых переменных, чье значение должно быть нулевым на момент их изменения мы сотавим в блоке Awake. Код ниже отображает изменения в методе Awake. position.y = 0f; position.z = 0f; for (int i = 0; i &amp;lt; resolution; i++) { Transform point = Instantiate(pointPrefab); position.x = (i + 0.5f) * step - 1f; // position.y = position.x * position.x * position.x; point.localPosition = position; point.localScale = scale; point.SetParent(transform, false); points[i] = point; } Добавьте пустой цикл for в метод Update void Update () { for (int i = 0; i &amp;lt; resolution; i++) {} } Теперь проговорим что нам нужно. Нам нужно пройтись по нашему массиву точек и установить каждой точке координаты по оси Y. Поскольку длина массива совпадает с resolution, мы можем использовать эту переменную для граничного значения счетчика массива. Но мало ли что может произойти с нашим массивом, вдруг приедет хипстер на голубом самокате и изменит размерность массива? В реальности, конечно, такое маловероятно, но давайте просто воспользуемся встроенным C# свойством Length, которое хранит в себе длину нашего массива. for (int i = 0; i &amp;lt; points.Length; i++) {} Мы проходим по всем элементам массива, получая текущую позицию для каждой точки. Далее получаем нужное нам значение, отвечающее за позицию в локальной системе координат. for (int i = 0; i &amp;lt; points.Length; i++) { Transform point = points[i]; Vector3 position = point.localPosition; } Далее получим значение для текущей точки в соответствии с нашей формулой for (int i = 0; i &amp;lt; points.Length; i++) { Transform point = points[i]; Vector3 position = point.localPosition; position.y = position.x * position.x * position.x; } Поскольку Vector3 содержит в себе лишь значения (он не является игровым объектом), то значение получившихся координат нужно присвоить нашей точке. for (int i = 0; i &amp;lt; points.Length; i++) { Transform point = points[i]; Vector3 position = point.localPosition; position.y = position.x * position.x * position.x; point.localPosition = position; } А разве мы не можем сделать так: point.localPosotion.y? Если бы localPosition было полем, то это было бы возможно. Мы могли бы напрямую задать координату Y. Однако localPosition является свойством. Оно может передать и принять только значение вектора. Таким образом, мы пытаем скорректировать позицию в локальной системе координат, которая вообще никак не влияет на положение точки. И поскольку мы явно не сохранили его в переменно, операция бессмысленна и вызовет ошибку компилятора. 4.3 Отобразим синусоиду С этого момента, если мы перейдем в режим воспроизведения, то точки нашего графика будут менять свое положение каждый кадр. Одна проблема: мы не замечаем никаких изменений, потому что они всегда остаются на одних и тех же позициях. Для того чтобы изменить текущее положение дел надо наконец-то добавить зависимость нашей функции от времени. Однако стоит сразу сделать не большую оговорку: простое добавление времени приведет к тому что наша функция просто уползет куда-то в сторону бесконечности. Чтобы подобного не произошло мы должны использовать функцию, которая изменяется, но остается в фиксированном диапазоне. Функция синуса идеально подойдет для этого. В стандартной библиотеке Unity есть уже готовая структура для работы с математическими функциями - Mathf. В ней есть метод Sin, который возвращает значение синуса от переменной, которую мы передадим в качестве аргумента. В данном случае мы хотим отобразить функцию вида , потому мы должный координате в оси Y присвоить значение синуса от координаты X. position.y = Mathf.Sin(position.x); Что за Mathf? Это структура, содержащая в себе набор математических функций и констант для работы с числами и векторами. В пространстве имен System уже есть подобная структура, которая называется Math. Отличие в том, что Mathf работает с числами типа float и векторами, а Math с числами типа double и в ней вообще такого типа как вектор. Синусоида меняется в диапазоне от . Данная функция циклична и повторяется каждые юнита, что примерно равно 6.28. Если так же масштабировать параметр времени на , функция будет повторяться каждые две секунды. В итоге получим вот такую функцию: , где это прошедшее время с момента запуска сцены. Этот параметр будет двигать синусоиду (волну), смещая ее в отрицательном направлении по оси X. Анимированная функция Итоговый вариант от автора урока: 4. unitypackage Итоговый вариант от переводчика: 5. unitypackage Следующий урок: Математические поверхности</summary></entry><entry><title type="html">Unity3D Урок №1. Игровые объекты и скрипты</title><link href="http://localhost:4000/jekyll/update/2018/01/17/Game-Objects-and-Scripts.html" rel="alternate" type="text/html" title="Unity3D Урок №1. Игровые объекты и скрипты" /><published>2018-01-17T19:00:00+03:00</published><updated>2018-01-17T19:00:00+03:00</updated><id>http://localhost:4000/jekyll/update/2018/01/17/Game-Objects-and-Scripts</id><content type="html" xml:base="http://localhost:4000/jekyll/update/2018/01/17/Game-Objects-and-Scripts.html">&lt;p&gt;Привет. В один прекрасный день, пытаясь решить одну свою проблему, связанную с Unity3D, я наткнулся на блог одного человека. В этом блоге было представлено множество разных уроков по Unity3D. Сам парень из Дании и производство подобных статей для него является бизнесом. Он делает реально крутой контент, который ну просто грех не перевести на русский язык. Я связался с ним и попросил разрешения на перевод, на что он дал добро. Потому я запускаю большой цикл статей с переводом его уроков по Unity3D.&lt;/p&gt;

&lt;p&gt;Перейдя на его сайт Вы сможете ознакомиться с его статьями в оригинале. Я не прошу и не буду просить денег за свою работу, но если Вы разделяете мое мнение насчет годности контента этого талантливейшего разработчика, то Вы можете отблагодарить его за работу просто присоединивших к платформе Patreon и указать сумму ежемесячного взноса, либо же сделать единовременно пожертвование. В каждой переведенной мною статье я буду напоминать о том, что можно отблагодарить этого человека.&lt;/p&gt;

&lt;p&gt;Ссылка на его блог: &lt;a href=&quot;http://catlikecoding.com/&quot;&gt;http://catlikecoding.com/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Ссылка где можно отблагодарить: &lt;a href=&quot;https://www.patreon.com/catlikecoding&quot;&gt;https://www.patreon.com/catlikecoding&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Вот что пишет автор на странице &lt;a href=&quot;https://www.patreon.com/catlikecoding&quot;&gt;https://www.patreon.com/catlikecoding&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Привет! Я Jasper Flick с сайта Catlike Coding.
Я делаю высококачественные уроки, которые позволят Вам узнать все о программировании с использованием языка C# в Unity. Мои уроки поданы в текстовом формате потому что считаю, что текст — это лучшее средство для данной тематики (для раскрытия данной темы). Так же они содержат набольшие вставки (картинки, анимации) которые, как я считаю, добавляют ценности.&lt;/p&gt;

&lt;p&gt;Я в Patreon с Мая 2014 года и в настоящее время выпускаю по 2 урока в месяц. Сейчас я работаю над двумя разделами, шестиугольная карта (Hex Map) и рендеринг (Rendering).&lt;/p&gt;

&lt;p&gt;Создание таких уроков отнимает очень много времени. Время, которое мне в основном приходится тратить на то чтобы не остаться голодным и т.п. Ваша поддержка — значит то, что я могу тратить больше времени на создание уроков, что улучшает их качество и количество.
Используйте Patreon для того чтобы сделать залог некоторой суммы денег, которую вы бы хотели дать мне, как спасибо за каждый новый урок. Нет пожертвований, нет уроков. Как бы плати сколько хочешь, но перед этим сказав сколько именно ты хочешь заплатить. Вы можете заранее выбрать одну из сумм залога или установить собственную. Не волнуйтесь, вы можете в любой момент изменить свою сумму, а также установить месячный лимит.&lt;/p&gt;

&lt;p&gt;Не хотите заморачиваться с Patreon? Всегда можно сделать единовременное &lt;a href=&quot;http://catlikecoding.com/unity/tutorials/donating.html&quot;&gt;пожертвование&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Это было не большое вступление, а теперь занавес, мы начинаем.&lt;/p&gt;

&lt;h2 id=&quot;Игровые-объекты-и-скрипты-Создание-часов&quot;&gt;&lt;strong&gt;Игровые объекты и скрипты. Создание часов&lt;/strong&gt;&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;Создадим часы из простых объектов&lt;/li&gt;
  &lt;li&gt;Напишем скрипты на C#&lt;/li&gt;
  &lt;li&gt;Заставим стрелки часов вращаться для отображения времени&lt;/li&gt;
  &lt;li&gt;Добавим плавности&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;В этом уроке мы создадим простые часы и запрограммируем их так чтобы они отображали время. Вам нужны будут только минимальные знания о редакторе Unity. Если вы до этого хотя бы пару минут игрались с Unity и знаете, как работать с окном &lt;em&gt;Scene&lt;/em&gt;, то этого будет достаточно.&lt;/p&gt;

&lt;p&gt;Данный урок сделан с использованием Unity версии 2017.1.0.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;\images\2018\01\GameObjectsAndScripts\tutorial-image.jpg&quot; alt=&quot;Пришло время создать часы&quot; /&gt;
&lt;em&gt;&lt;center&gt;Пришло время создать часы&lt;/center&gt;&lt;/em&gt;&lt;/p&gt;

&lt;h2 id=&quot;1-Создадим-часы&quot;&gt;&lt;strong&gt;1. Создадим часы&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;Откройте Unity и создайте новый 3D проект. Вам не понадобятся какие-либо уникальные ассеты с готовыми компонентами, аналитика вам тоже не понадобится, потому ее можно просто отключить. Если вы еще не настроили редактор, то у Вас будет установлено расположение окон по умолчанию.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;\images\2018\01\GameObjectsAndScripts\default-layout.png&quot; alt=&quot;_Вариант расположения окон по умолчанию_&quot; /&gt;
&lt;em&gt;&lt;center&gt;Вариант расположения окон по умолчанию&lt;/center&gt;&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Я использую другой вариант 2 к 3 (2 by 3) который вы можете выбрать в правом верхнем углу редактора. Изменим не много окно &lt;em&gt;Project&lt;/em&gt; нажав на кнопку в правом верхнем углу и в выпадающем меню выбрав &lt;em&gt;One Column Layout&lt;/em&gt;. Так же советую отключить показ координатной сетки &lt;em&gt;Show Grid&lt;/em&gt; во вкладке &lt;em&gt;Scene&lt;/em&gt;. Этот пункт можно найти в выпадающем меню на вкладке &lt;em&gt;Scene&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;\images\2018\01\GameObjectsAndScripts\2-by-3.png&quot; alt=&quot;_Измененное расположение окон_&quot; /&gt;
&lt;em&gt;&lt;center&gt;Измененное расположение окон&lt;/center&gt;&lt;/em&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;Почему окно с игрой маленькое и черными границами по краям?&lt;/strong&gt;&lt;/p&gt;

  &lt;p&gt;Такое может произойти есть вы используете монитор с большим разрешением и с нестандартным соотношением сторон. Для того чтобы избавиться от этого стоит на вкладке Game нажать на кнопку, которая находится рядом с Display 1. В выпавшем меню нужно убрать галку &lt;em&gt;Low Resolution Aspect Ratios&lt;/em&gt; и установить &lt;em&gt;Free Aspect&lt;/em&gt;.&lt;/p&gt;

  &lt;center&gt;&lt;img src=&quot;\images\2018\01\GameObjectsAndScripts\low-resolution-aspect-ratios.png&quot; width=&quot;300px&quot; /&gt;&lt;/center&gt;

  &lt;p&gt;&lt;em&gt;&lt;center&gt;Low resolution aspect ratios отключена&lt;/center&gt;&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;11-Создадим-игровой-объект-game-object&quot;&gt;&lt;strong&gt;1.1 Создадим игровой объект (Game Object)&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;По умолчанию в сцене присутствуют 2 игровых объекта. Эти объекты находятся во вкладке Hierarchy и именно их иконки вы можете наблюдать во вкладке Scene. Первое это &lt;em&gt;Main Camera&lt;/em&gt;, используется для отображения всех объектов на сцене. Окно &lt;em&gt;Game&lt;/em&gt; отображается все что попадает в поле зрения камеры. Второй это &lt;em&gt;Directional Light&lt;/em&gt; этот компонент добавляет базовый свет на сцену (он как солнце освещает всю сцену равномерно из одной точки).&lt;/p&gt;

&lt;p&gt;Создадим собственный игровой объект выбрав в строке меню &lt;em&gt;GameObject / CreateEmpty&lt;/em&gt;. Так же подобное вы можете сделать просто, нажав правой клавишей мыши на свободное место в окне &lt;em&gt;Hierarchy&lt;/em&gt;. Давайте дадим только что добавленному объекту имя, для этого нажмите ПКМ на только что добавленном объекте и выберете &lt;em&gt;Rename&lt;/em&gt;. Поскольку мы создаем часы, то назовем объект соответствующе - &lt;em&gt;Clock&lt;/em&gt;.&lt;/p&gt;

&lt;center&gt;&lt;img src=&quot;\images\2018\01\GameObjectsAndScripts\hierarchy.png&quot; /&gt;&lt;/center&gt;
&lt;p&gt;&lt;em&gt;&lt;center&gt;Вкладка Hierarchy с объектом Clock&lt;/center&gt;&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Познакомимся с окном Inspector. В этом окне отображаются компоненты, которые есть у нашего игрового объекта. При выборе нашего объекта &lt;em&gt;Clock&lt;/em&gt; он будет содержать заголовок с именем объекта и параметрами конфигурации. По умолчанию объект включен, не является статическим, не имеет тега и принадлежит слою &lt;em&gt;Default&lt;/em&gt;. Эти настройки отлично подойдут нам. Ниже приведен список всех компонентов игрового объекта. На любом созданном объекте всегда присутствует компонент &lt;em&gt;Transform&lt;/em&gt;.&lt;/p&gt;

&lt;center&gt;&lt;img src=&quot;\images\2018\01\GameObjectsAndScripts\inspector.png&quot; width=&quot;450px&quot; /&gt;&lt;/center&gt;
&lt;p&gt;&lt;em&gt;&lt;center&gt;Вкладка Inspector с выбранными часами&lt;/center&gt;&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Компонент &lt;em&gt;Transform&lt;/em&gt; хранит в себе позицию, углы поворота, масштаб в 3D пространстве. Убедитесь, что координаты и угол поворота у наших часов равен 0, а масштаб 1.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;em&gt;Что насчет 2D объектов?&lt;/em&gt;&lt;/p&gt;

  &lt;p&gt;При работе в 2D вместо 3D игнорируется одно из трех измерений. Объекты, специально предназначенные для 2D-подобных элементов пользовательского интерфейса, обычно имеют &lt;em&gt;Rect Transform&lt;/em&gt;, который является специализированным компонентом &lt;em&gt;Transform&lt;/em&gt; для 2D объектов.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;12-Создадим-основу-для-часов&quot;&gt;&lt;strong&gt;1.2 Создадим основу для часов.&lt;/strong&gt;&lt;/h2&gt;

&lt;p&gt;Хоть у нас и есть объект часы, на сцене мы не видим ничего. Хорошо, давайте добавим на сцену 3D модель, которая будет отображаться на нашей сцене. В Unity «из-под коробки» есть несколько примитивных объектов, которые мы можем использовать для того чтобы создать наши часы. Давайте начнем. Добавим на нашу сцену цилиндр нажав на &lt;em&gt;GameObject/3DObject/Cylinder&lt;/em&gt;.  Убедитесь, что он имеет те же значения Transform что и объект &lt;em&gt;Clock&lt;/em&gt;.&lt;/p&gt;

&lt;center&gt;
&lt;img src=&quot;\images\2018\01\GameObjectsAndScripts\cylinder.png&quot; width=&quot;170&quot; height=&quot;160&quot; /&gt;
&lt;img src=&quot;\images\2018\01\GameObjectsAndScripts\cylinder-inspector.png&quot; width=&quot;320&quot; height=&quot;229&quot; /&gt;
&lt;/center&gt;
&lt;p&gt;&lt;em&gt;&lt;center&gt;Игровой объект, представляющий собой цилиндр&lt;/center&gt;&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Наш только что добавленный объект имеет несколько незнакомых нам компонентов. Первый это &lt;em&gt;Mesh Filter&lt;/em&gt;, этот компонент просто содержит в себе ссылку на &lt;em&gt;Mesh (сетку)&lt;/em&gt; цилиндра. Второй это &lt;em&gt;Capsule Collider&lt;/em&gt;, который предназначен для взаимодействия объектов. Без этого компонента все объекты будут просто проходить насквозь друг через друга и никак не взаимодействовать между собой. Третий компонент это &lt;em&gt;Mesh Renderer&lt;/em&gt;. Этот компонент обеспечивает визуализацию нашего объекта, путем наложения текстуры на сетку.  Он так же контролирует какой материал вы используете для отрисовки, по умолчанию устанавливается &lt;em&gt;Default-Material&lt;/em&gt;, но вы всегда можете его изменить в соответствующем компоненте, который расположен ниже &lt;em&gt;Mesh Renderer&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Если вы уже успели покликать по нашему объекту, то вы наверняка заметили, что наш объект представляет собой цилиндр, а вот коллайдер у нас имеет форму капсулы. Так произошло потому что в Unity нет готового компонента с коллайдером в форме цилиндра. Но собственно нас это не волнует, потому просто удалим этот компонент. Если же вам вдруг понадобится сделать коллайдер именно у цилиндра или у другого объекта, форма которого более сложная, то воспользуйтесь компонентом &lt;em&gt;Mesh Collider&lt;/em&gt;. Компоненты можно удалить с помощью выпадающего меню со знаком шестеренки в правом верхнем углу.&lt;/p&gt;

&lt;center&gt;&lt;img src=&quot;\images\2018\01\GameObjectsAndScripts\cylinder-no-collider.png&quot; width=&quot;450&quot; /&gt;&lt;/center&gt;
&lt;p&gt;&lt;em&gt;&lt;center&gt;Наш объект без коллайдера&lt;/center&gt;&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Для того чтобы превратить наш цилиндр в нечто похожее на часы, необходимо сделать циферблат, путем сплющивания нашего цилиндра. Это делается уменьшением значения &lt;em&gt;Scale&lt;/em&gt; по оси Y до 0,1, а X, Z увеличением на 10.&lt;/p&gt;

&lt;center&gt;
&lt;img src=&quot;\images\2018\01\GameObjectsAndScripts\cylinder-scaled-scene.png&quot; width=&quot;230&quot; height=&quot;170&quot; /&gt;
&lt;img src=&quot;\images\2018\01\GameObjectsAndScripts\cylinder-scaled-inspector.png&quot; width=&quot;320&quot; height=&quot;76&quot; /&gt;
&lt;/center&gt;
&lt;p&gt;&lt;em&gt;&lt;center&gt;Растянутый цилиндр&lt;/center&gt;&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Изменим имя нашего цилиндра на &lt;em&gt;Face&lt;/em&gt;. Поскольку сделанный нами циферблат является частью часов, то укажем это в иерархии. Для этого переместим наш &lt;em&gt;Face&lt;/em&gt; на объект &lt;em&gt;Clock&lt;/em&gt;.&lt;/p&gt;

&lt;center&gt;&lt;img src=&quot;\images\2018\01\GameObjectsAndScripts\child-object.png&quot; /&gt;&lt;/center&gt;
&lt;p&gt;&lt;em&gt;&lt;center&gt;Face является дочерним к объекту Clock.&lt;/center&gt;&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Дочерние объекты копируют преобразования родительского объекта. Это значит, что если мы изменим положение часов, то положение циферблата изменится вместе с ним, как будто они стали единым целым. Тоже самое касается вращения и масштаба. Это можно использовать для создания сложных иерархий объектов.&lt;/p&gt;

&lt;h2 id=&quot;13-Создание-циферблата&quot;&gt;&lt;strong&gt;1.3 Создание циферблата&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;Теперь сделаем градуировку на нашем циферблате, по которой можно будет ориентироваться во времени или по-другому контур часов. 
Добавим объект Куб на сцену кликнув &lt;em&gt;GameObject / 3D Object / Cube&lt;/em&gt;. Изменим масштаб на &lt;em&gt;(0.5, 0.2, 1)&lt;/em&gt; сделав его длинным узким блоком похожий на брусок. Установим ему позицию &lt;em&gt;(0, 0.2, 4)&lt;/em&gt;. Это положение соответствует 12 часам. Назовите его &lt;em&gt;Hour Indicator&lt;/em&gt;.&lt;/p&gt;

&lt;center&gt;
&lt;img src=&quot;\images\2018\01\GameObjectsAndScripts\indicator-scene.png&quot; width=&quot;300&quot; height=&quot;214&quot; /&gt;
&lt;img src=&quot;\images\2018\01\GameObjectsAndScripts\indicator-inspector.png&quot; width=&quot;320&quot; height=&quot;229&quot; /&gt;
&lt;/center&gt;
&lt;p&gt;&lt;em&gt;&lt;center&gt;Отметка 12 часов&lt;/center&gt;&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Пока нашу отметку очень сложно увидеть, потому что она сливается с циферблатом. Для того чтобы изменить текущее положение дел нужно нажать &lt;em&gt;Assets / Create / Material&lt;/em&gt; и создать новый материал или сделать аналогичные действия в окне &lt;em&gt;Project&lt;/em&gt;. Это создаст нам материал, который дублирует материал по умолчанию. Изменим &lt;em&gt;Albedo&lt;/em&gt; на что-то более темное, установив значение 73 для красного, зеленого и синего. В результате мы получим темно-серый материал. Давайте дадим ему соответствующее имя – &lt;em&gt;Clock dark&lt;/em&gt;.&lt;/p&gt;

&lt;center&gt;
&lt;img src=&quot;\images\2018\01\GameObjectsAndScripts\dark-material.png&quot; width=&quot;556&quot; height=&quot;130&quot; /&gt;
&lt;img src=&quot;\images\2018\01\GameObjectsAndScripts\color-popup.png&quot; width=&quot;220&quot; height=&quot;356&quot; /&gt;
&lt;/center&gt;
&lt;p&gt;&lt;em&gt;&lt;center&gt;Темный материал и всплывающее окно с выбором цвета&lt;/center&gt;&lt;/em&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;em&gt;Что за альбедо такое?&lt;/em&gt;&lt;/p&gt;

  &lt;p&gt;Альбедо происходит от латинского слова белизна. Это просто цвет материала.&lt;/p&gt;

  &lt;p&gt;Прим. От переводчика: как бы по факту это не совсем так. Почему назвали именно альбедо, а не просто цвет сложно сказать, но Вы можете почитать сами и внести ясности в данный вопрос&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Перетащите этот материал на нашу 12 часовую отметку или просто переместите наш материал в ячейку &lt;em&gt;Element 0&lt;/em&gt; компонента &lt;em&gt;Mesh Renderer&lt;/em&gt;.&lt;/p&gt;

&lt;center&gt;&lt;img src=&quot;\images\2018\01\GameObjectsAndScripts\dark-indicator.png&quot; width=&quot;300&quot; /&gt;&lt;/center&gt;
&lt;p&gt;&lt;em&gt;&lt;center&gt;Отметка 12 часов темно-серого цвета&lt;/center&gt;&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Наша отметка корректно показывает 12 часов, но что если мы хотим показать 1 час на часах? Все 12 часов располагаются на круге 360°, разделив 360° на 12 отметок получим 30°. Получается, что каждую отметку нам нужно будет поворачивать на 30° по оси Y. Давайте сделаем это.&lt;/p&gt;

&lt;center&gt;
&lt;img src=&quot;\images\2018\01\GameObjectsAndScripts\rotated-scene.png&quot; width=&quot;250&quot; height=&quot;188&quot; /&gt;
&lt;img src=&quot;\images\2018\01\GameObjectsAndScripts\rotated-inspector.png&quot; width=&quot;320&quot; height=&quot;76&quot; /&gt;
&lt;/center&gt;
&lt;p&gt;&lt;em&gt;&lt;center&gt;Повернутая часовая отметка, но неправильно расположенная&lt;/center&gt;&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Наша отметка повернута на правильный угол, но расположена она все еще на позиции 12 часовой отметки. Это произошло потому мы вращали объект относительно его собственное локальной исходной точки, которая является его положением в пространстве.&lt;/p&gt;

&lt;p&gt;Мы должны переместить отметку вдоль кромки циферблата так чтобы наша отметка занимала положение часовой отметки. Вместо того чтобы высчитывать вручную положение в пространстве каждой отметки мы можем использовать иерархию объектов. Для начала сбросьте параметр поворота у нашей отметки (измените его на 0).  Затем создайте новый пустой объект с координатами, поворотом равными 0 и масштабом равным 1. Сделайте нашу отметку дочерней к пустому только что созданному объекту.&lt;/p&gt;

&lt;center&gt;&lt;img src=&quot;\images\2018\01\GameObjectsAndScripts\temporary-parent.png&quot; /&gt;&lt;/center&gt;
&lt;p&gt;&lt;em&gt;&lt;center&gt;Временный родитель&lt;/center&gt;&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Теперь установим у родителя значение поворота по оси Y равное 30°. Таким образом наша отметка будет вращаться вокруг пустого объекта родителя, а это именно то что нам нужно.&lt;/p&gt;

&lt;center&gt;&lt;img src=&quot;\images\2018\01\GameObjectsAndScripts\rotated-correct.png&quot; width=&quot;300&quot; /&gt;&lt;/center&gt;
&lt;p&gt;&lt;em&gt;&lt;center&gt;Правильное положение часовой отметки&lt;/center&gt;&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Продублируйте нашего временного родителя используя сочетанием клавиш &lt;em&gt;Ctrl+D&lt;/em&gt; или воспользовавшись контекстным меню во вкладке &lt;em&gt;hierarchy&lt;/em&gt;. В каждом дубликате увеличьте значение поворота по оси Y на 30°. Сделайте подобным образом все 12 отметок.&lt;/p&gt;

&lt;center&gt;&lt;img src=&quot;\images\2018\01\GameObjectsAndScripts\12-hour-indicators.png&quot; width=&quot;300&quot; /&gt;&lt;/center&gt;
&lt;p&gt;&lt;em&gt;&lt;center&gt;Циферблат со всеми часовыми отметками&lt;/center&gt;&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Нам больше не понадобятся временные родители. Выберите все отметки часов использовав &lt;em&gt;Ctrl+ЛКМ&lt;/em&gt; и сделайте их дочерними к нашим часам. Теперь объясню, как такое получилось. Если перед тем как сделать объект дочерним к часам вы посмотрите на компонент &lt;em&gt;Transform&lt;/em&gt; у отметки, то вы заметите что у всех объектов одинаковое значения как координат, так и углов поворота. А после того как вы поменяете у него родителя, то эта значения изменятся. Это произошла трансформация из локальной системы координат в глобальную. Раньше наши отметки получали координаты и угол поворота от временного родителя, сейчас же их координаты преобразовались в локальные координаты для объекта &lt;em&gt;Clock&lt;/em&gt; сохранив углы поворота.&lt;/p&gt;

&lt;center&gt;&lt;img src=&quot;\images\2018\01\GameObjectsAndScripts\periphery-children.png&quot; /&gt;&lt;/center&gt;
&lt;p&gt;&lt;em&gt;&lt;center&gt;Получившаяся иерархия&lt;/center&gt;&lt;/em&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;em&gt;У меня значения координат равно 90,0000001. Это правильно?&lt;/em&gt;&lt;/p&gt;

  &lt;p&gt;Это произошло потому что координаты, углы поворота и масштаб являются числами с плавающей точкой (float). Этот тип переменных имеет ограниченную точность, потому может вызвать незначительные отклонения, связанные с округлением. Переживать по этому поводу не стоит, поскольку отклонение 0,0000001 настолько мало что не оказывает никакого заметного влияния.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;14-Создадим-стрелки-часов&quot;&gt;&lt;strong&gt;1.4 Создадим стрелки часов&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;Мы можем использовать тот же подход чтобы создать стрелки часов. Создайте новый куб и назовите его Arm, сразу перетяните на него созданный нами материал и удалите коллайдер. Установите масштаб равный &lt;em&gt;(0.3, 0.2, 2.5)&lt;/em&gt; таким образом сделав его уже и длиннее чем наша отметка. Установите координаты &lt;em&gt;(0, 0.2, 0.75)&lt;/em&gt; при такой установке стрелка будет направлена в сторону 12 часов, а другая сторона стрелки будет не много смещена относительно центра часов. Со стороны это выглядит как не большой противовес.&lt;/p&gt;

&lt;center&gt;
&lt;img src=&quot;\images\2018\01\GameObjectsAndScripts\hours-arm-scene.png&quot; width=&quot;250&quot; height=&quot;200&quot; /&gt;
&lt;img src=&quot;\images\2018\01\GameObjectsAndScripts\hours-arm-inspector.png&quot; width=&quot;320&quot; height=&quot;229&quot; /&gt;
&lt;/center&gt;
&lt;p&gt;&lt;em&gt;&lt;center&gt;Часовая стрелка&lt;/center&gt;&lt;/em&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Куда делась иконка с солнцем?&lt;/p&gt;

  &lt;p&gt;Я переместил свет не много в сторону чтобы он больше не загромождал сцену. Directional Light освещается сцену равномерно независимо от его положения.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Чтобы заставить нашу стрелку правильно вращаться, создайте родительский пустой объект для него по аналогии с отметками. Убедитесь, что родитель имеет координаты и углы поворота равные 0, а масштаб равный 1. Проверить необходимо, потому что вращать стрелку мы будет чуть позже. Сделайте стрелку дочерним к пустому объекту, назовите родительский объект Hours Arm, после сделайте его дочерним к часам. Теперь стрелка является как бы «внуком» часов.&lt;/p&gt;

&lt;center&gt;&lt;img src=&quot;\images\2018\01\GameObjectsAndScripts\hours-arm-hierarchy.png&quot; /&gt;&lt;/center&gt;
&lt;p&gt;&lt;em&gt;&lt;center&gt;Колонка hierarchy после всех действий&lt;/center&gt;&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Продублируйте Hours Arm дважды для создания минутной и секундной стрелки. Переименуйте их в &lt;em&gt;Minutes Arm&lt;/em&gt; и &lt;em&gt;Seconds Arm&lt;/em&gt; соответственно. Минутная стрелка должная быть длиннее и уже, чем часовая, для этого проставим значения масштаба равные &lt;em&gt;(0.2, 0.15, 4)&lt;/em&gt; и координат равные &lt;em&gt;(0, 0.375, 1)&lt;/em&gt;. Таким образом наша стрелка будет расположена выше часовой стрелки.&lt;/p&gt;

&lt;p&gt;Для секундной стрелки установим значения для масштаба равные &lt;em&gt;(0.1, 0.1, 5)&lt;/em&gt; и координат &lt;em&gt;(0, 0.5, 1.25)&lt;/em&gt;. Выделим нашу секундную стрелку на общем фоне путем создания нового материала красного цвета со значением &lt;em&gt;Albedo&lt;/em&gt; равным &lt;em&gt;(197,0,0)&lt;/em&gt; и применим этот материал на нашей стрелке.&lt;/p&gt;

&lt;center&gt;
&lt;img src=&quot;\images\2018\01\GameObjectsAndScripts\all-arms-scene.png&quot; width=&quot;250&quot; height=&quot;188&quot; /&gt;
&lt;img src=&quot;\images\2018\01\GameObjectsAndScripts\all-arms-hierarchy.png&quot; width=&quot;120&quot; height=&quot;154&quot; /&gt;
&lt;/center&gt;
&lt;p&gt;&lt;em&gt;&lt;center&gt;Часы со всеми стрелками&lt;/center&gt;&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Наши часы полностью готовы. Если вы до этого не создавали и не сохраняли вашу сцену, то самое время это сделать, нажав &lt;em&gt;File / Save Scene&lt;/em&gt; имя сцены выбирайте сами. Я назвал ее просто &lt;em&gt;Scene&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Прим. От переводчика:&lt;/strong&gt; сцены в Unity это как отдельные уровни одной большой игры. У вас может быть несколько сцен, на которых будут разные уровни. После завершения одного вы можете запускать другой, обеспечивая тем самым смену локаций. Заведите себе привычку при создании любого проекта первым делом создать сцену. Сохраняйте эту сцену каждые 5-10 минут нажатием клавиш Ctrl+S. Это не раз вас спасет если вы работаете не на самом мощном компьютере.&lt;/p&gt;

&lt;center&gt;&lt;img src=&quot;\images\2018\01\GameObjectsAndScripts\saved-scene.png&quot; /&gt;&lt;/center&gt;
&lt;p&gt;&lt;em&gt;&lt;center&gt;Сохраненная сцена&lt;/center&gt;&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Если вы застряли, хотите сравнить или пропустить блок с созданием часов, то вы можете &lt;a href=&quot;http://catlikecoding.com/unity/tutorials/basics/game-objects-and-scripts/building-a-simple-clock/building-a-simple-clock.unitypackage&quot;&gt;скачать&lt;/a&gt; сделанный мною вариант. Вы можете присоединить мой вариант к своему проекту через вкладку &lt;em&gt;Assets / Import Package / Custom Package&lt;/em&gt;. Далее нажмите &lt;em&gt;Import&lt;/em&gt; и запустите мою сцену.&lt;/p&gt;

&lt;h2 id=&quot;2-Анимируем-часы&quot;&gt;&lt;strong&gt;2. Анимируем часы&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;Замечательно! Часы есть. Запустим сцену нажав на кнопку &lt;em&gt;Play&lt;/em&gt;. Если у вас камера направлена прямо на часы, то вы заметите что часы не идут. Нажмем снова на &lt;em&gt;Play&lt;/em&gt;, остановим игру и проясним ситуацию. На данный момент мы просто создали иерархию объектов, которые просто расположены на сцене. Ничего более. Если бы в Unity был уже готовый компонент, который мы могли бы прикрепить к часам, и он начал бы сразу бы работать, было бы круто, но такого компонента нет. Потому нам придется его создать самим. Компоненты создаются с помощью скриптов. Добавим новый скрипт нажав _ Assets / Create / C# Script_ и назвав его &lt;em&gt;Clock&lt;/em&gt;.&lt;/p&gt;

&lt;center&gt;
&lt;img src=&quot;\images\2018\01\GameObjectsAndScripts\clock-project.png&quot; width=&quot;90&quot; height=&quot;70&quot; /&gt;
&lt;img src=&quot;\images\2018\01\GameObjectsAndScripts\clock-inspector.png&quot; width=&quot;320&quot; height=&quot;156&quot; /&gt;
&lt;/center&gt;
&lt;p&gt;&lt;em&gt;&lt;center&gt;Наш скрипт во вкладке проект и во вкладке с компонентами &lt;/center&gt;&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;При выборе скрипта инспектор покажет содержимое скрипта и там же можно найти кнопку &lt;em&gt;Open&lt;/em&gt; для того чтобы открыть наш файл в редакторе. Или просто сделай двойной клик по файлу, и он откроется в редакторе. Наш скрипт будет содержать в себе шаблон кода по умолчанию. Этот код представлен ниже.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c#&quot; data-lang=&quot;c#&quot;&gt;&lt;span class=&quot;k&quot;&gt;using&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;System.Collections&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;using&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;System.Collections.Generic&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;using&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;UnityEngine&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Clock&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;MonoBehaviour&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;c1&quot;&gt;// Use this for initialization&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;Start&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;		
	&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
	&lt;span class=&quot;c1&quot;&gt;// Update is called once per frame&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;Update&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;	
	&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Этот код написан на языке C#. Это язык программирования используется в Unity для создания скриптов. Для того чтобы более подробно разобраться с тем как работает код, удалим все что нам сгенерировал Unity с начнем сначала.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;А что насчет JavaScript?&lt;/p&gt;

  &lt;p&gt;Unity так же поддерживает другой язык программирования, обычно называемый JavaScript, но его фактическое название – UnityScript. Unity 2017.1.0 до сих пор поддерживает его, но в версии Unity 2017.2.0 из меню для добавления компонентов была убрана возможность создать JavaScript. Как бы можно точно сказать, что поддержка этого языка полностью прекращена в Unity.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;21-Введение-в-скриптинг&quot;&gt;&lt;strong&gt;2.1 Введение в скриптинг&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;Пустой скрипт, в котором нет ни единой строчки не будет работать в Unity. Мы назвали наш файл &lt;em&gt;Clock&lt;/em&gt; и Unity ждет того что в данном скрипте будет указано то, что должны делать наши часы. Мы не даем определение для одного экземпляра компонента. Вместо этого мы определяем общий класс или тип, известный как &lt;code class=&quot;highlighter-rouge&quot;&gt;Clock&lt;/code&gt;. После того как мы это сделаем, мы можем создать несколько таких компонентов в Unity.&lt;/p&gt;

&lt;p&gt;В C# мы определяем тип &lt;code class=&quot;highlighter-rouge&quot;&gt;Clock&lt;/code&gt; начиная с определения класса. Нужно явно указать какую структуру мы будем использовать для определения наших часов.  &lt;em&gt;Строки кода в которых что-то изменилось будут закоментированы. Когда мы начинаем работу с полностью пустым файлом первое что мы должны объявить это &lt;code class=&quot;highlighter-rouge&quot;&gt;class Clock&lt;/code&gt;. При желании можете поиграться со знаками табуляции нажав пробел или _Tab&lt;/em&gt;,&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c#&quot; data-lang=&quot;c#&quot;&gt;&lt;span class=&quot;err&quot;&gt;с&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;lass&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Clock&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;blockquote&gt;
  &lt;p&gt;Что такое класс с технической точки зрения?&lt;/p&gt;

  &lt;p&gt;Класс представляет собой шаблон, по которому определяется форма объекта. В нем указываются данные и код, который будет оперировать этими данными. В C# используется спецификация класса для построения объектов, которые являются экземплярами класса. Следовательно, класс, по существу, представляет собой ряд схематических описаний способа построения объекта. При этом очень важно подчеркнуть, что класс является логической абстракцией. Физическое представление класса появится в оперативной памяти лишь после того, как будет создан объект этого класса.&lt;/p&gt;

  &lt;p&gt;Классы и структуры — это, по сути, шаблоны, по которым можно создавать объекты. Каждый объект содержит данные и методы, манипулирующие этими данными.&lt;/p&gt;

  &lt;p&gt;Прим. От переводчика: у автора написано примерно такое же определение, но в более сжатой форме. Его определение очень сложно перевести так, чтобы оно было понятно читателю. Потому данное определение я сформулировал самостоятельно исходя из контекста автора. При необходимости прочитайте это в оригинале.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Поскольку мы не хотим ограничивать доступ к нашему классу, проставим модификатор доступа к &lt;code class=&quot;highlighter-rouge&quot;&gt;Clock&lt;/code&gt;. Это делается путем подставленные префикса &lt;code class=&quot;highlighter-rouge&quot;&gt;public&lt;/code&gt; перед определением класса.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c#&quot; data-lang=&quot;c#&quot;&gt;&lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;с&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;lass&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Clock&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;blockquote&gt;
  &lt;p&gt;Что такое модификатор доступа по умолчанию для классов?&lt;/p&gt;

  &lt;p&gt;Если мы не проставим самостоятельно модификатор доступа, то будет выбран модификатор по умолчанию ` internal class Clock`. Это ограничивает доступ к коду из одной сборки, что становится актуальным при использовании кода, упакованного в несколько DLL файлов.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;На данном этапе наш код до сих пор не компилируется. Мы указали что есть некий класс &lt;code class=&quot;highlighter-rouge&quot;&gt;Clock&lt;/code&gt; но мы не указали что он должен делать. Для компилятора необходимо явно указать область, в которой будет прописан код нашего класса. Эти самый границы обозначаются фигурными скобками &lt;code class=&quot;highlighter-rouge&quot;&gt;{}&lt;/code&gt;, давайте добавим их&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c#&quot; data-lang=&quot;c#&quot;&gt;&lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;с&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;lass&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Clock&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Теперь наш скрипт скомпилируется. Нажмите &lt;em&gt;Ctrl+S&lt;/em&gt; для того чтобы сохранить изменения в файле и вернитесь в окно редактора Unity. Unity «увидела» что файл был изменен и сразу перекомпилировала его. Давайте выберем наш скрипт. И в инспекторе мы можем увидеть надпись, которой до этого не было, которая говорит нам о том, что наш класс не содержит &lt;code class=&quot;highlighter-rouge&quot;&gt;MonoBehaviour&lt;/code&gt;.&lt;/p&gt;

&lt;center&gt;
&lt;img src=&quot;\images\2018\01\GameObjectsAndScripts\non-component.png&quot; /&gt;
&lt;/center&gt;
&lt;p&gt;&lt;em&gt;&lt;center&gt;Отсутствует  MonoBehaviour &lt;/center&gt;&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Это означает что мы не можем использовать этот скрипт для создания компонента в Unity. На данном этапе наш класс &lt;code class=&quot;highlighter-rouge&quot;&gt;Clock&lt;/code&gt; определяет универсальный тип объекта в C#. Для того чтобы наш компонент мог что-либо сделать (в данном случае нам нужно заставить стрелки часов вращаться) нужно реализовать методы, которые есть в классе &lt;code class=&quot;highlighter-rouge&quot;&gt;MonoBehaviour&lt;/code&gt;.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Что за MonoBehaviour?&lt;/p&gt;

  &lt;p&gt;Идея заключается в том, что мы можем программировать наши собственные компоненты, чтобы добавить пользовательского &lt;strong&gt;поведения&lt;/strong&gt; (от англ. Behaviour) для наших игровых объектов. Приставка Mono была добавлена в следствии того что ранее Unity использовал проекты типа mono что является кроссплатформенным расширением файлов в .NET framework. Потому и MonoBehaviour. Это старое название, которое пришло к нам из первых версий Unity.  Узнать о Mono подробнее можно &lt;a href=&quot;https://ru.wikipedia.org/wiki/Mono&quot;&gt;тут&lt;/a&gt;.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Чтобы превратить &lt;code class=&quot;highlighter-rouge&quot;&gt;Clock&lt;/code&gt; в подтип &lt;code class=&quot;highlighter-rouge&quot;&gt;MonoBehaviour&lt;/code&gt; мы должны явно это указать через знак двоеточия. Это позволяет нашим &lt;code class=&quot;highlighter-rouge&quot;&gt;Clock&lt;/code&gt; унаследовать весь функционал ` MonoBehaviour `.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c#&quot; data-lang=&quot;c#&quot;&gt;&lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;с&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;lass&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Clock&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;MonoBehaviour&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Однако, это все равно приводит к ошибке компиляции. Компилятор жалуется, что не может найти тип &lt;code class=&quot;highlighter-rouge&quot;&gt;MonoBehaviour&lt;/code&gt;. Это произошло потому что &lt;code class=&quot;highlighter-rouge&quot;&gt;MonoBehaviour&lt;/code&gt; находится в пространстве имен &lt;code class=&quot;highlighter-rouge&quot;&gt;UnityEngine&lt;/code&gt;. Чтобы получить доступ к нему необходимо явно указать что мы хотим использовать &lt;code class=&quot;highlighter-rouge&quot;&gt;MonoBehaviour&lt;/code&gt; из пространства имен &lt;code class=&quot;highlighter-rouge&quot;&gt;UnityEngine&lt;/code&gt;.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c#&quot; data-lang=&quot;c#&quot;&gt;&lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;с&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;lass&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Clock&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;UnityEngine&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;MonoBehaviour&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;blockquote&gt;
  &lt;p&gt;Что такое пространство имен?&lt;/p&gt;

  &lt;p&gt;Пространство имен это как домен для сайта, но только в коде. Как домен может иметь субдомен, так и пространство имен может иметь подпространство имен. Большая проблема данной аналогии в том, что путь к сайту в программировании записывается наоборот. Вместо forum.unity3d.com мы имеем com.unity3d.forum. Код написанный разработчиками не нужно ниоткуда качать т.к. он сразу есть в Unity. Пространства имен используются для организации кода и предотвращения смешивания имен функции.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Поскольку неудобно всегда использовать префикс &lt;code class=&quot;highlighter-rouge&quot;&gt;UnityEngine&lt;/code&gt;, мы можем сказать компилятору чтобы он выполнял поиск в этом пространстве имен. Это делается путем добавления строки &lt;code class=&quot;highlighter-rouge&quot;&gt;using UnityEngine;&lt;/code&gt; в заголовок скрипта. Знак точки с запятой &lt;code class=&quot;highlighter-rouge&quot;&gt;:&lt;/code&gt; здесь очень важен потому что он явно говорит компилятору где именно закончилась команда.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c#&quot; data-lang=&quot;c#&quot;&gt;&lt;span class=&quot;k&quot;&gt;using&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;UnityEngine&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;с&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;lass&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Clock&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;MonoBehaviour&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Ну теперь наконец-то мы можем прикрепить наш компонент к объекту. Это можно легко сделать просто, перетащив наш скрипт на нужный нам объект, либо нажать на объекте кнопку &lt;em&gt;Add Component&lt;/em&gt;, которая находится во вкладке &lt;em&gt;Inpector&lt;/em&gt;.&lt;/p&gt;

&lt;center&gt;
&lt;img src=&quot;\images\2018\01\GameObjectsAndScripts\clock-with-component.png&quot; /&gt;
&lt;/center&gt;
&lt;p&gt;&lt;em&gt;&lt;center&gt;Объект Clock с прикрепленным к нему скриптом &lt;/center&gt;&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Теперь у нас создан экземпляр объекта C#, использующий наш класс &lt;code class=&quot;highlighter-rouge&quot;&gt;Clock&lt;/code&gt; в качестве шаблона. В результате чего мы видим неизменяемое поле Script со значением Clock.&lt;/p&gt;

&lt;h2 id=&quot;22-Получим-стрелки-часов&quot;&gt;&lt;strong&gt;2.2 Получим стрелки часов&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;Для того чтобы поворачивать наши стрелки необходимо передать информацию о них нашему скрипту &lt;code class=&quot;highlighter-rouge&quot;&gt;Clock&lt;/code&gt;. Давайте начнем с часовой стрелки. Все игровые объекты могут быть повернуты путем изменения углов поворота в соответствующем компоненте &lt;em&gt;Transform&lt;/em&gt;. Поэтому нашему скрипту необходимо явно указать на то какой компонент нам необходимо получить. Это можно сделать путем добавления поля с данными внутрь блока с кодом.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Hours transform&lt;/code&gt; будет подходящим именем для нашего поля. Для того чтобы Unity мог правильно распарсить имена наших переменных, то стоит их называть в соответствии со стилем написания составных слов, при котором несколько слов пишутся слитно без пробелов, при этом каждое слово внутри фразы пишется с заглавной буквы - &lt;em&gt;CamelCase&lt;/em&gt;. В нашем случае будет правильно назвать наше поле &lt;code class=&quot;highlighter-rouge&quot;&gt;hoursTransform&lt;/code&gt;.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c#&quot; data-lang=&quot;c#&quot;&gt;&lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;с&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;lass&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Clock&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;MonoBehaviour&lt;/span&gt; 
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;hoursTransform&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;blockquote&gt;
  &lt;p&gt;Куда делась строка с using?&lt;/p&gt;

  &lt;p&gt;Она все еще тут. Фрагменты кода, которые будут приведены будут содержать фрагменты, в которых что-либо изменилось. потому если вы части кода не видите, то значит он остается без изменений.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Так же обязательно мы должны указать тип нашего поля. В данном случае мы хотим получить компонент &lt;code class=&quot;highlighter-rouge&quot;&gt;UnityEngine.Transform&lt;/code&gt; который содержит в себе информацию взятую из компонента &lt;em&gt;Transform&lt;/em&gt;.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c#&quot; data-lang=&quot;c#&quot;&gt;&lt;span class=&quot;n&quot;&gt;Transform&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;hoursTransform&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Наш класс теперь определяет поле, которое должно содержать ссылку на объект, тип которого должен быть &lt;code class=&quot;highlighter-rouge&quot;&gt;Transform&lt;/code&gt;. Нам нужно убедиться, что мы передаем ссылку на компонент &lt;code class=&quot;highlighter-rouge&quot;&gt;Transform&lt;/code&gt; объекта &lt;em&gt;Hours Arm&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Но пока мы не можем этого сделать, потому что у нас не указан модификатор доступа к данному полю. Вся загвоздка тут в том, что если мы явно не прописываем этот модификатор, то по умолчанию он проставляется как &lt;code class=&quot;highlighter-rouge&quot;&gt;private&lt;/code&gt;, что означает что получить доступ к данному полю мы можем только внутри нашего класса и никак не можем получить из вне. Поэтому давайте изменим модификатор доступа, добавив ключевое слово &lt;code class=&quot;highlighter-rouge&quot;&gt;public&lt;/code&gt;.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c#&quot; data-lang=&quot;c#&quot;&gt;&lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Transform&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;hoursTransform&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;blockquote&gt;
  &lt;p&gt;Разве публичные поля это не плохо?&lt;/p&gt;

  &lt;p&gt;В целом, консенсус заключается в том, чтобы избежать создания открытых полей при создании программ. Однако в Unity публичные поля нужны для того чтобы передать ссылку на элементы сцены, которые мы хотим каким-либо образом изменить. Можно обойтись и без публичных полей, но тогда вам придется изрядно с этим заморочиться и написать алгоритм, который рекурсивно проходит по всей иерархии и ищет ваши объекты по имени или тегам.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;После того как мы проставили наш модификатор доступа, то мы должны увидеть соответствующее поле в окне &lt;em&gt;Inspector&lt;/em&gt;. Это работает именно так. Вы пишете код, сохраняете его, Unity видит что файл был изменен, заново его компилирует, и обновляет его.&lt;/p&gt;

&lt;center&gt;
&lt;img src=&quot;\images\2018\01\GameObjectsAndScripts\hours-transform-field.png&quot; /&gt;
&lt;/center&gt;
&lt;p&gt;&lt;em&gt;&lt;center&gt;Поле Hours Transform типа Transform&lt;/center&gt;&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Для того чтобы передать ссылку на нужный нам компонент, необходимо найти нужный нам объект в иерархии и просто перетащить его в созданное нами поле. Но есть и другой способ. Необходимо просто нажать на кружок рядом с полем и выбрать в выпадающем меню нужный нам компонент.&lt;/p&gt;

&lt;center&gt;
&lt;img src=&quot;\images\2018\01\GameObjectsAndScripts\hours-transform-connected.png&quot; /&gt;
&lt;/center&gt;
&lt;p&gt;&lt;em&gt;&lt;center&gt;Ссылка на компонент Transform объекта Hours Arms передана&lt;/center&gt;&lt;/em&gt;&lt;/p&gt;

&lt;h2 id=&quot;23-Получим-все-стрелки-часов&quot;&gt;&lt;strong&gt;2.3 Получим все стрелки часов&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;Сделаем то же самое для минутной и секундной стрелки.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c#&quot; data-lang=&quot;c#&quot;&gt;&lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Transform&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;hoursTransform&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Transform&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;minutesTransform&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Transform&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;secondsTransform&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Эти объявления полей можно сделать более краткими, поскольку они имеют один и тот же модификатор доступа и тип. Объявление всех этих переменных можно свернуть в одну строчку. Для этого нужно просто записывать все переменные друг за другом, отделяя их друг от друга запятыми.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c#&quot; data-lang=&quot;c#&quot;&gt;&lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Transform&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;hoursTransform&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;minutesTransform&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;secondsTransform&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// public Transform minutesTransform;&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// public Transform secondsTransform;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;blockquote&gt;
  &lt;p&gt;Что означает //?&lt;/p&gt;

  &lt;p&gt;Два слэша идущих друг за другом это комментирование. Весь текст которых находится на этой строчке после двух слэшей просто игнорируется компилятором. Используется это для того чтобы добавлять какой-либо текст, не являющийся кодом в файл с кодом. Комментарии нужны для того чтобы дать понять другим людям или вам самим что делает тот или иной блок кода. Не стоит комментировать каждую строчку кода, это только затруднит чтение.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Теперь передайте ссылки на наши объекты так же как мы сделали это с часовой стрелкой.&lt;/p&gt;

&lt;center&gt;
&lt;img src=&quot;\images\2018\01\GameObjectsAndScripts\arms-connected.png&quot; /&gt;
&lt;/center&gt;
&lt;p&gt;&lt;em&gt;&lt;center&gt;Ссылки на все объекты переданы&lt;/center&gt;&lt;/em&gt;&lt;/p&gt;

&lt;h2 id=&quot;24-Какой-сейчас-час&quot;&gt;&lt;strong&gt;2.4 Какой сейчас час?&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;Теперь, когда мы явно указали ссылки на все объекты с которыми мы хотим что-либо сделать, мы можем перейти к следующему шагу – узнать который сейчас час. Чтобы сделать это мы должны прописать код, который будет делать то что нам нужно. Это делается путем добавления метода в наш класс &lt;code class=&quot;highlighter-rouge&quot;&gt;Clock&lt;/code&gt;. Метод этот должен определенное имя &lt;code class=&quot;highlighter-rouge&quot;&gt;Awake&lt;/code&gt; и название такое он имеет потому что мы предполагаем, что наш код должен выполнится, как только запустится наша сцена.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c#&quot; data-lang=&quot;c#&quot;&gt;&lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Clock&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;MonoBehaviour&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Transform&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;hoursTransform&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; 
	&lt;span class=&quot;n&quot;&gt;minutesTransform&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; 
	&lt;span class=&quot;n&quot;&gt;secondsTransform&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;Awake&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Методы несколько похожи на математические функции, для примера &lt;script type=&quot;math/tex&quot;&gt;f(x) = 2x + 3&lt;/script&gt;. Эта функция берет некоторое число, умножает его на 2 и прибавляет 3. Она берет одно число на вход и возвращает тоже одно число. В случае метода это больше похоже на &lt;script type=&quot;math/tex&quot;&gt;f(p) = c&lt;/script&gt;, где &lt;script type=&quot;math/tex&quot;&gt;p&lt;/script&gt; представляет собой входные параметры, а &lt;script type=&quot;math/tex&quot;&gt;с&lt;/script&gt; это выполнение кода. Такое объяснение может показаться слишком абстрактным, потому что не понятно какой результат выполнения нашей функции. Но на самом деле наша функция может и не возвращать никакого результата, она может просто выполнять код, который прописан внутри метода и все. Для того чтобы создать такой метод, то перед именем метода должен стоять префикс &lt;code class=&quot;highlighter-rouge&quot;&gt;void&lt;/code&gt; (в дословном переводе «пустой»).&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c#&quot; data-lang=&quot;c#&quot;&gt;&lt;span class=&quot;k&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Awake&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Отлично. Но есть еще одна загвоздка. Компилятор ожидает что наш метод может принимать на вход какие-либо параметры. Но в нашем случае метод не принимает на вход никаких параметров и мы обязательно должны это указать поставив круглые скобки после имени нашего метода &lt;code class=&quot;highlighter-rouge&quot;&gt;()&lt;/code&gt;.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c#&quot; data-lang=&quot;c#&quot;&gt;&lt;span class=&quot;k&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;Awake&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Теперь у нас есть валидный метод, который ничего не делает. Как бы Unity увидит наши поля, которые прописаны выше, увидит &lt;code class=&quot;highlighter-rouge&quot;&gt;Awake&lt;/code&gt; метод и сделает то что написано в &lt;code class=&quot;highlighter-rouge&quot;&gt;{}&lt;/code&gt; скобках. Если в нашем скрипте присутствует метод &lt;code class=&quot;highlighter-rouge&quot;&gt;Awake&lt;/code&gt; и этот скрипт наследуется от ` MonoBehaviour`, то фрагмент кода написанный внутри этого метода выполняется сразу, как только компонент содержащий наш скрипт будет создан или загружен на сцену.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Почему у нашего метода Awake нет модификатора доступа?&lt;/p&gt;

  &lt;p&gt;Метод Awake и набор некоторых других методов считаются особенными конкретно для Unity. Unity найдет и вызовет этот метод тогда, когда это будет нужно Unity. Мы не должны вызывать эти методы самостоятельно, Unity сам все поймет, распарсит и запустит помеченные нами методы именно в тот момент, в который нам надо.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Чтобы проверить как именно это работает давайте заставим нашу программу выводить сообщение в консоль. Как раз класс &lt;code class=&quot;highlighter-rouge&quot;&gt;UnityEngine.Debug&lt;/code&gt; имеет публичный метод &lt;code class=&quot;highlighter-rouge&quot;&gt;Log&lt;/code&gt;, который поможет решить нашу задачу. Давайте просто выведем простой текст в консоль. Текст, который мы хотим вывести обернем в &lt;code class=&quot;highlighter-rouge&quot;&gt;“”&lt;/code&gt;. И не забудьте про &lt;code class=&quot;highlighter-rouge&quot;&gt;;&lt;/code&gt;, которая вспомните сами для чего нам нужна :)&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c#&quot; data-lang=&quot;c#&quot;&gt;&lt;span class=&quot;k&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;Awake&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;Debug&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;Log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;“&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Test&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;”&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Нажмите на кнопку &lt;em&gt;Play&lt;/em&gt; в редакторе. И вы увидите, как текст, написанный нами, отобразится во вкладке &lt;em&gt;Console&lt;/em&gt;. Либо же вы можете нажать &lt;em&gt;Window / Console&lt;/em&gt;. В консоль может выводится вся информация, связанная с работой самой программы и кода, который вы написали. Если вы допустите ошибку при написании, то Unity выбросит вам исключение, которое отобразится в консоли.&lt;/p&gt;

&lt;p&gt;Теперь, когда мы знаем, что наш метод работает, давайте узнаем текущее время. Пространство имен &lt;code class=&quot;highlighter-rouge&quot;&gt;UnityEngine&lt;/code&gt; содержит в себе класс &lt;code class=&quot;highlighter-rouge&quot;&gt;Time&lt;/code&gt;, который в свою очередь содержит свойство &lt;code class=&quot;highlighter-rouge&quot;&gt;time&lt;/code&gt;. Очевидно, даже очень, давайте закодим и посмотрим, что у нас получится.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c#&quot; data-lang=&quot;c#&quot;&gt;&lt;span class=&quot;k&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;Awake&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;Debug&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;Log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Time&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;time&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;blockquote&gt;
  &lt;p&gt;Что такое свойство?&lt;/p&gt;

  &lt;p&gt;Свойство – это метод, который притворяется полем. У свойств можно проставить свои модификаторы доступа, позволяющие только читать, только записывать или и читать, и записывать данные. Негласно программисты стараются избегать использования свойств, но в Unity не всегда следуют этому негласному правилу.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;После запуска мы увидим в консоли цифру 0. Это произошло потому что &lt;code class=&quot;highlighter-rouge&quot;&gt;Time.time&lt;/code&gt; возвращает время, которое прошло со времени запуска сцены. А поскольку, как мы говорили ранее, вывод в консоль происходит в момент инициализации компонента, а наш компонент инициализируется во время запуска сцены, а это значит, что времени с момента запуска сцены прошло ровно 0.&lt;/p&gt;

&lt;p&gt;Для того чтобы получить доступ к системному времени компьютера, на котором мы работаем, мы можем использовать структуру &lt;code class=&quot;highlighter-rouge&quot;&gt;DateTime&lt;/code&gt;. Данная структура не относится к Unity и находится в пространстве имен &lt;code class=&quot;highlighter-rouge&quot;&gt;System&lt;/code&gt;. Эта структура является частью .Net framework.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Что такое структура?&lt;/p&gt;

  &lt;p&gt;Как вам должно быть уже известно, классы относятся к ссылочным типам данных. Это означает, что объекты конкретного класса доступны по ссылке, в отличие от значений простых типов, доступных непосредственно. Но иногда прямой доступ к объектам как к значениям простых типов оказывается полезно иметь, например, ради повышения эффективности программы. Ведь каждый доступ к объектам (даже самым мелким) по ссылке связан с дополнительными издержками на расход вычислительных ресурсов и оперативной памяти.&lt;/p&gt;

  &lt;p&gt;Для разрешения подобных затруднений в C# предусмотрена структура, которая подобна классу, но относится к типу значения, а не к ссылочному типу данных. Т.е. структуры отличаются от классов тем, как они сохраняются в памяти и как к ним осуществляется доступ (классы — это ссылочные типы, размещаемые в куче, структуры — типы значений, размещаемые в стеке), а также некоторыми свойствами (например, структуры не поддерживают наследование). Из соображений производительности вы будете использовать структуры для небольших типов данных. Однако в отношении синтаксиса структуры очень похожи на классы.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;DateTime&lt;/code&gt; имеет публичное свойство &lt;code class=&quot;highlighter-rouge&quot;&gt;Now&lt;/code&gt;. Оно создает значение &lt;code class=&quot;highlighter-rouge&quot;&gt;DateTime&lt;/code&gt;, которое содержит текущую системную дату и время. Let’s code it.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c#&quot; data-lang=&quot;c#&quot;&gt;&lt;span class=&quot;k&quot;&gt;using&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;using&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;UnityEngine&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Clock&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;MonoBehaviour&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Transform&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;hoursTransform&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;minutesTransform&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;secondsTransform&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;Awake&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; 
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;Debug&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;Log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;DateTime&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Now&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Теперь каждый раз при запуске нашей сцены у нас в консоли прописывается время, когда мы входим в &lt;em&gt;Play mode&lt;/em&gt;.&lt;/p&gt;

&lt;h2 id=&quot;25-Поворачиваем-наши-стрелки&quot;&gt;&lt;strong&gt;2.5 Поворачиваем наши стрелки&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;Следующий шаг — это поворот стрелок, основанный на текущем времени. По сложившейся традиции начнем мы с часовой стрелки. &lt;code class=&quot;highlighter-rouge&quot;&gt;DateTime&lt;/code&gt; имеет еще одно интересное свойство, которое будет для нас полезно. Вызов свойства &lt;code class=&quot;highlighter-rouge&quot;&gt;hour&lt;/code&gt; возвращает нам количество часов в данный момент времени. У меня он вернет час дня.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c#&quot; data-lang=&quot;c#&quot;&gt;&lt;span class=&quot;k&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;Awake&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; 
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;Debug&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;Log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;DateTime&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Now&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Hour&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Мы можем использовать это свойство для предания вращения нашим стрелкам. Вращение объектов в Unity описывается при помощи кватернионов (quaternions). Вызовем публичный метод &lt;code class=&quot;highlighter-rouge&quot;&gt;Quaternion.Euler&lt;/code&gt;. В качестве аргументов данный метод принимает углы поворота по осям X, Y и Z и возвращает он соответствующий этим аргументам кватернион.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c#&quot; data-lang=&quot;c#&quot;&gt;&lt;span class=&quot;k&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;Awake&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; 
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;//Debug.Log(DateTime.Now.Hour);&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;Quaternion&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;Euler&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;DateTime&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Now&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Hour&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;blockquote&gt;
  &lt;p&gt;Что такое кватернион?&lt;/p&gt;

  &lt;p&gt;Кватернионы базируются на комплексных числах и используются для описания поворота объекта в 3D пространстве. Их труднее понять, чем простые 3D векторы, но они имею ряд полезных свойств. Например, они не будут повержены эффекту &lt;a href=&quot;https://ru.wikipedia.org/wiki/Складывание_рамок&quot;&gt;складывания рамок&lt;/a&gt;&lt;/p&gt;

  &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;UnityEngine.Quaternion&lt;/code&gt; используется как простое значение. Это структура, не класс.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Все три аргумента это действительные числа, которые представлены в C# как числа с плавающей точкой. Чтобы явно объявить, что мы передаем методу числа с плавающей точкой, нужно к каждому нулю добавить суффикс &lt;code class=&quot;highlighter-rouge&quot;&gt;f&lt;/code&gt;.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c#&quot; data-lang=&quot;c#&quot;&gt;&lt;span class=&quot;n&quot;&gt;Quaternion&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;Euler&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;0f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;DateTime&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Now&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Hour&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;0f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;На часах наши отметки расположены по кругу через каждый 30°. Чтобы наше вращение стрелок было правильным мы должны умножить текущее значение часов на 30.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c#&quot; data-lang=&quot;c#&quot;&gt;&lt;span class=&quot;n&quot;&gt;Quaternion&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;Euler&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;0f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;DateTime&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Now&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Hour&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;30f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;0f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Чтобы было ясно, что мы преобразуем часы в градусы, мы можем определить поле с соответствующим именем для коэффициента преобразования.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c#&quot; data-lang=&quot;c#&quot;&gt;&lt;span class=&quot;kt&quot;&gt;float&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;degreesPerHour&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;30f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Transform&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;hoursTransform&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;minutesTransform&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;secondsTransform&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;Awake&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;Quaternion&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;Euler&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;0f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;DateTime&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Now&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Hour&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;degreesPerHour&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;0f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Поскольку данный коэффициент преобразования не будет нами больше изменяться, то мы можем объявить его константой.  Делаем это путем добавления префикса &lt;code class=&quot;highlighter-rouge&quot;&gt;const&lt;/code&gt;.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c#&quot; data-lang=&quot;c#&quot;&gt;&lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;float&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;degreesPerHour&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;30f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;blockquote&gt;
  &lt;p&gt;Что особенного в константах?&lt;/p&gt;

  &lt;p&gt;Ключевое слово const обозначает что значение нашей переменной будет постоянно и его не нужно изменять. Как фундаментальные константы, которые существуют в реальном мире, такие как число Авогадро, постоянная Планка, число ПИ, число Эйлера и т.п. Особенность констант в том, что значение нашей константе присваивается в момент компиляции и не может быть изменено в процессы выполнения самой программы.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Отлично, у нас есть строка, которая описывает то, как должен вращаться наш объект. Но если мы запустим сцену, то увидим, что ничего не произошло. Дело все в том, что мы не указали что именно мы хотим вращать. А вращать мы хотим часовую стрелку и вращать мы ее будем относительно ее центра координат. У нашего поля &lt;code class=&quot;highlighter-rouge&quot;&gt;hoursTransform&lt;/code&gt; есть свойство, которое описывает поворот нашего объекта относительно центра координат &lt;code class=&quot;highlighter-rouge&quot;&gt;localRotation&lt;/code&gt; и необходимо этому свойству присвоить значение, полученное нами выше. Как бы поворачиваем нашу часовую стрелку относительно начала координат на кватернион полученный из текущего значения часов, умноженные на угловой интервал расположения часовых отметок.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c#&quot; data-lang=&quot;c#&quot;&gt;&lt;span class=&quot;k&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;Awake&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;hoursTransform&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;localRotation&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;Quaternion&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;Euler&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;0f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;DateTime&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Now&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Hour&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;degreesPerHour&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;0f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;center&gt;
&lt;img src=&quot;\images\2018\01\GameObjectsAndScripts\hours-arm-rotated.png&quot; /&gt;
&lt;/center&gt;
&lt;p&gt;&lt;em&gt;&lt;center&gt;Часовая стрелка показывает 4 часа&lt;/center&gt;&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Запустив нашу сцену, мы увидим, что наша часовая стрелка заняла правильное положение и отображает текущее значение часов. Давайте теперь сделаем все то же самое для минутной и секундной стрелки, но с не большим уточнением. Поскольку часовых отметок на часах 12, а минутных и секундных отметок 60, то стоит объявить для каждой стрелки свою константу, чтобы они вращались правильно. &lt;script type=&quot;math/tex&quot;&gt;360° / 60 = 6°&lt;/script&gt; именно на столько градусов должна поворачиваться минутная и секундная стрелка.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c#&quot; data-lang=&quot;c#&quot;&gt;&lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;float&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;degreesPerHour&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;30f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;degreesPerMinute&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;6f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;degreesPerSecond&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;6f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

	&lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Transform&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;hoursTransform&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;minutesTransform&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;secondsTransform&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

	&lt;span class=&quot;k&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;Awake&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;hoursTransform&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;localRotation&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt;
			&lt;span class=&quot;n&quot;&gt;Quaternion&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;Euler&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;0f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;DateTime&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Now&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Hour&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;degreesPerHour&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;0f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;minutesTransform&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;localRotation&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt;
			&lt;span class=&quot;n&quot;&gt;Quaternion&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;Euler&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;0f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;DateTime&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Now&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Minute&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;degreesPerMinute&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;0f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;secondsTransform&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;localRotation&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt;
			&lt;span class=&quot;n&quot;&gt;Quaternion&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;Euler&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;0f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;DateTime&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Now&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Second&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;degreesPerSecond&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;0f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;center&gt;
&lt;img src=&quot;\images\2018\01\GameObjectsAndScripts\all-arms-rotated.png&quot; /&gt;
&lt;/center&gt;
&lt;p&gt;&lt;em&gt;&lt;center&gt;Часы показывают 16:29:06&lt;/center&gt;&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Теперь взглянем на наш код внимательно и увидим, что у нас &lt;code class=&quot;highlighter-rouge&quot;&gt;DateTime.Now&lt;/code&gt; используется трижды для часов, минут и секунд. Чисто теоретически из-за того, что наше свойство вызывается трижды в разных строчках кода, то может возникнуть коллизия, связанная с задержкой выполнения какой-либо из строчки кода. Например, каким-то неведанным образом после того как выполнится ` DateTime.Now.Minute ` произойдет задержка в пару секунд, и следующая строка выполнится позже, а если это еще произойдет на 59 секунде, то наша минутная стрелка целую секунду будет показывать неправильное время.  Для того чтобы такого не случилось нужно чтобы при каждом вызове нашего метода ` Quaternion.Euler&lt;code class=&quot;highlighter-rouge&quot;&gt; значение времени было одинаковым независимо от того, когда выполнится строчка кода, которая отвечает за поворот стрелки. Для этого объявим внутри метода &lt;/code&gt;Awake` переменную в которую поместим текущее время.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c#&quot; data-lang=&quot;c#&quot;&gt;&lt;span class=&quot;k&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;Awake&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
 &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;DateTime&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;time&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;DateTime&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Now&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;hoursTransform&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;localRotation&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;Quaternion&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;Euler&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;0f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;time&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Hour&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;degreesPerHour&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;0f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;minutesTransform&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;localRotation&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;Quaternion&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;Euler&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;0f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;time&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Minute&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;degreesPerMinute&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;0f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;secondsTransform&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;localRotation&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;Quaternion&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;Euler&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;0f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;time&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Second&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;degreesPerSecond&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;0f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;h2 id=&quot;26-Заводим-наши-часы&quot;&gt;&lt;strong&gt;2.6 «Заводим» наши часы&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;Если вы из любопытства уже успели запустить нашу сцену, то вы заметили, что наши часы не идут. Они показали время, в которое был проинициализирован наш скрипт и остановились. Как будто их нужно завести для того чтобы они снова начали показывать актуальное время.&lt;/p&gt;

&lt;p&gt;Для того чтобы завести наши часы, нужно чтобы наш код выполнялся не в момент инициализации компонента, а каждый кадр. Но подождите, что нам придется опять писать много сложно кода чтобы заставить наши часы отображать время? – Нет, в Unity есть готовая реализация как метода &lt;code class=&quot;highlighter-rouge&quot;&gt;Awake&lt;/code&gt; так и метода, который вызывается каждый кадр и выполняет весь код что написан внутри него. Метод этот называется &lt;code class=&quot;highlighter-rouge&quot;&gt;Update&lt;/code&gt;. И для того чтобы все заработало достаточно будет заменить &lt;code class=&quot;highlighter-rouge&quot;&gt;Awake&lt;/code&gt; на &lt;code class=&quot;highlighter-rouge&quot;&gt;Update&lt;/code&gt;.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c#&quot; data-lang=&quot;c#&quot;&gt;&lt;span class=&quot;k&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;Update&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;DateTime&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;time&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;DateTime&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Now&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;hoursTransform&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;localRotation&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;Quaternion&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;Euler&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;0f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;time&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Hour&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;degreesPerHour&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;0f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;minutesTransform&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;localRotation&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;Quaternion&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;Euler&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;0f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;time&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Minute&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;degreesPerMinute&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;0f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;secondsTransform&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;localRotation&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;Quaternion&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;Euler&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;0f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;time&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Second&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;degreesPerSecond&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;0f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;center&gt;
&lt;video class=&quot;video&quot; id=&quot;video-cooperativeradiantichneumonfly&quot; alt=&quot;Clock GIF&quot; height=&quot;372&quot; width=&quot;492&quot; autoplay=&quot;&quot; loop=&quot;&quot; playsinline=&quot;&quot; preload=&quot;auto&quot; poster=&quot;https://thumbs.gfycat.com/CooperativeRadiantIchneumonfly-mobile.jpg&quot; tabindex=&quot;-1&quot;&gt;&lt;source src=&quot;https://giant.gfycat.com/CooperativeRadiantIchneumonfly.webm&quot; type=&quot;video/webm&quot; /&gt;&lt;source src=&quot;https://giant.gfycat.com/CooperativeRadiantIchneumonfly.mp4&quot; type=&quot;video/mp4&quot; /&gt;&lt;meta itemprop=&quot;contentUrl&quot; content=&quot;https://giant.gfycat.com/CooperativeRadiantIchneumonfly.mp4&quot; /&gt;&lt;/video&gt;
&lt;/center&gt;
&lt;p&gt;&lt;em&gt;&lt;center&gt;Часы наконец-то показывают актуальное время&lt;/center&gt;&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;В случае если мы не хотим чтобы наш скрипт работал. Вместо того чтобы удалять компонент или править сам компонент, можно просто отключить наш компонент нажав на галочку рядом с именем нашего компонента&lt;/p&gt;

&lt;center&gt;
&lt;img src=&quot;\images\2018\01\GameObjectsAndScripts\enabled-toggle.png&quot; /&gt;
&lt;/center&gt;
&lt;p&gt;&lt;em&gt;&lt;center&gt;Компонент с включенным переключателем&lt;/center&gt;&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;## &lt;strong&gt;2.7 Непрерывное вращение&lt;/strong&gt;
Сейчас наши стрелки часов двигаются с прерыванием. Но вы наверняка в рольном мире видели часы, в которых строки часов идут плавно без рывков. Давайте добавим маленькую фичу нашим часам.&lt;/p&gt;

&lt;p&gt;Для этого создадим еще одно публичное поле в классе &lt;code class=&quot;highlighter-rouge&quot;&gt;Clock&lt;/code&gt; и назовем его &lt;code class=&quot;highlighter-rouge&quot;&gt;continuous&lt;/code&gt;. И поскольку это будет переключатель, который хранит в себе 2 состояния (плавное движение стрелок включено, плавное движение стрелок выключено), то объявим тип у этого поля &lt;code class=&quot;highlighter-rouge&quot;&gt;bool&lt;/code&gt;.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c#&quot; data-lang=&quot;c#&quot;&gt;&lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Transform&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;hoursTransform&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;minutesTransform&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;secondsTransform&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;bool&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;continuous&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Булева переменная может иметь всего 2 значения &lt;code class=&quot;highlighter-rouge&quot;&gt;true&lt;/code&gt; или &lt;code class=&quot;highlighter-rouge&quot;&gt;false&lt;/code&gt; (истина или ложь), которые соответствуют нашем случае положению включено и выключено. По умолчанию переменная типа &lt;code class=&quot;highlighter-rouge&quot;&gt;bool&lt;/code&gt; имеет значение &lt;code class=&quot;highlighter-rouge&quot;&gt;false&lt;/code&gt;, поэтому вернитесь в окно Unity и поставьте галочку.&lt;/p&gt;

&lt;center&gt;
&lt;img src=&quot;\images\2018\01\GameObjectsAndScripts\continuous-option.png&quot; /&gt;
&lt;/center&gt;
&lt;p&gt;&lt;em&gt;&lt;center&gt;Плавное вращение стрелок включено&lt;/center&gt;&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Теперь нам нужно написать две разных реализации вращения стрелок. Но сначала не много подготовимся к этому. Продублируйте метод &lt;code class=&quot;highlighter-rouge&quot;&gt;Update&lt;/code&gt; со всем имеющимся в нем кодом. Теперь у нас есть 2 метода &lt;code class=&quot;highlighter-rouge&quot;&gt;Update&lt;/code&gt;. Переименуем их. Один назовем &lt;code class=&quot;highlighter-rouge&quot;&gt;UpdateContinuous&lt;/code&gt;, второй &lt;code class=&quot;highlighter-rouge&quot;&gt;UpdateDiscrete&lt;/code&gt;.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c#&quot; data-lang=&quot;c#&quot;&gt;&lt;span class=&quot;k&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;UpdateContinuous&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; 
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;DateTime&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;time&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;DateTime&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Now&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;hoursTransform&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;localRotation&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt;
			&lt;span class=&quot;n&quot;&gt;Quaternion&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;Euler&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;0f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;time&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Hour&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;degreesPerHour&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;0f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;minutesTransform&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;localRotation&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt;
			&lt;span class=&quot;n&quot;&gt;Quaternion&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;Euler&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;0f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;time&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Minute&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;degreesPerMinute&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;0f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;secondsTransform&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;localRotation&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt;
			&lt;span class=&quot;n&quot;&gt;Quaternion&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;Euler&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;0f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;time&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Second&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;degreesPerSecond&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;0f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;UpdateDiscrete&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; 
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;DateTime&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;time&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;DateTime&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Now&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;hoursTransform&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;localRotation&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt;
			&lt;span class=&quot;n&quot;&gt;Quaternion&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;Euler&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;0f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;time&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Hour&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;degreesPerHour&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;0f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;minutesTransform&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;localRotation&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt;
			&lt;span class=&quot;n&quot;&gt;Quaternion&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;Euler&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;0f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;time&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Minute&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;degreesPerMinute&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;0f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;secondsTransform&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;localRotation&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt;
			&lt;span class=&quot;n&quot;&gt;Quaternion&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;Euler&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;0f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;time&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Second&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;degreesPerSecond&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;0f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Теперь создайте метод &lt;code class=&quot;highlighter-rouge&quot;&gt;Update&lt;/code&gt; и давайте поговорим. Поскольку у нас есть переключатель, который хранит в себе 2 значения (включено и выключено) и мы хотим, чтобы при нажатии на эту кнопку режим отображения времени у нас менялся. Иначе говоря, если наше поле &lt;code class=&quot;highlighter-rouge&quot;&gt;continuous&lt;/code&gt; имеет значение &lt;code class=&quot;highlighter-rouge&quot;&gt;true&lt;/code&gt;, тогда вращать стрелки плавно, иначе вращать их с прерываниями.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c#&quot; data-lang=&quot;c#&quot;&gt;&lt;span class=&quot;k&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;Update&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; 
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;continuous&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; 
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;nf&quot;&gt;UpdateContinuous&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; 
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;nf&quot;&gt;UpdateDiscrete&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;blockquote&gt;
  &lt;p&gt;Где может быть объявлен метод Update?&lt;/p&gt;

  &lt;p&gt;Внутри класса Clock. будет ли он расположен выше или ниже относительно других методов не имеет значения. Однако существует негласное правило, которое гласит что, каждый метод должен идти в порядке его выполнения. Это упрощает чтение и понимание ваше кода другими людьми. В нашем случае лучше всего расположить метод Update в самом верху, после него расположить метод UpdateContinuous, а после UpdateDiscrete, в соответствии с порядком вызова, который мы указали в методе Update.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Не спешите пока запускать нашу сцену. Пока код в наших методах одинаковый и переключение не даст видимого эффекта. Для того чтобы все заработало нужно не много изменить наш метод ` UpdateContinuous`.&lt;/p&gt;

&lt;p&gt;Класс &lt;code class=&quot;highlighter-rouge&quot;&gt;DateTime&lt;/code&gt; не содержит в себе удобных дробных данных. Но к нашему счастью у него есть свойство TimeOfDay, которое содержит в себе значение типа &lt;code class=&quot;highlighter-rouge&quot;&gt;TimeSpan&lt;/code&gt;, которое содержит в себе данные в нужном нам формате. А именно &lt;code class=&quot;highlighter-rouge&quot;&gt;TotalHours&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;TotalMinutes&lt;/code&gt; и &lt;code class=&quot;highlighter-rouge&quot;&gt;TotalSeconds&lt;/code&gt;.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c#&quot; data-lang=&quot;c#&quot;&gt;&lt;span class=&quot;k&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;UpdateContinuous&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; 
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;TimeSpan&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;time&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;DateTime&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Now&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;TimeOfDay&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;hoursTransform&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;localRotation&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;Quaternion&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;Euler&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;0f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;time&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;TotalHours&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;degreesPerHour&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;0f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;minutesTransform&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;localRotation&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;Quaternion&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;Euler&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;0f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;time&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;TotalMinutes&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;degreesPerMinute&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;0f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;secondsTransform&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;localRotation&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;Quaternion&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;Euler&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;0f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;time&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;TotalSeconds&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;degreesPerSecond&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;0f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Кажется, что на этом все, но если мы сохраним наши изменения и вернемся в окно редактора, то увидим в консоли ошибку компиляции. Произошло это потому что наши значения аргументов имеют тип &lt;em&gt;double&lt;/em&gt;. Это тот же самый тип &lt;em&gt;float&lt;/em&gt; только хранить он в себе может в 2 раза больше значащих цифр после запятой. Ну и что? – Скажете вы. А дело все в том, что Unity работает только с типом &lt;em&gt;float&lt;/em&gt; и нам придется под это подстроиться.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;А достаточно ли точности в этом типе?&lt;/p&gt;

  &lt;p&gt;Для большинства игр да. Проблемы начинают возникать тогда, когда вы начнете работать с очень большими рассеяниями или масштабами. Когда настанет такой момента, вам придется применять такие трюки как телепортация, чтобы сохранить локальную игровую зону в глобальных координатах. Хотя использование двойной точности решить эту проблему, это так же удвоит размер потребляемой памяти, что приведет к другим проблемам связанные с производительностью. Следовательно, лучше использовать float и прикручивать костыли по мере необходимости, нежели постоянно иметь проблему с производительностью.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Решить данную проблему мы можем очень и очень просто путем преобразования значений наших аргументов в тип &lt;em&gt;float&lt;/em&gt;. Это преобразование просто отбросит числа, которые не помещаются в 4 бита. Этот процесс называется принудительное приведение типов и делается он путем добавления круглых скобок перед нашим аргументом с написанным внутри значением типа переменной в который необходимо сделать преобразование.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c#&quot; data-lang=&quot;c#&quot;&gt;&lt;span class=&quot;n&quot;&gt;hoursTransform&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;localRotation&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;Quaternion&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;Euler&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;0f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;float&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;time&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;TotalHours&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;degreesPerHour&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;0f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;minutesTransform&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;localRotation&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;Quaternion&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;Euler&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;0f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;float&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;time&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;TotalMinutes&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;degreesPerMinute&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;0f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;secondsTransform&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;localRotation&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;Quaternion&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;Euler&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;0f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;float&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;time&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;TotalSeconds&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;degreesPerSecond&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;0f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;center&gt;&lt;video class=&quot;video&quot; id=&quot;video-glitteringoilyfieldmouse&quot; alt=&quot;Continuous Clock GIF&quot; height=&quot;376&quot; width=&quot;500&quot; autoplay=&quot;&quot; loop=&quot;&quot; playsinline=&quot;&quot; preload=&quot;auto&quot; poster=&quot;https://thumbs.gfycat.com/GlitteringOilyFieldmouse-mobile.jpg&quot; tabindex=&quot;-1&quot;&gt;&lt;source src=&quot;https://giant.gfycat.com/GlitteringOilyFieldmouse.webm&quot; type=&quot;video/webm&quot; /&gt;&lt;source src=&quot;https://giant.gfycat.com/GlitteringOilyFieldmouse.mp4&quot; type=&quot;video/mp4&quot; /&gt;&lt;meta itemprop=&quot;contentUrl&quot; content=&quot;https://giant.gfycat.com/GlitteringOilyFieldmouse.mp4&quot; /&gt;&lt;/video&gt;&lt;/center&gt;
&lt;p&gt;&lt;em&gt;&lt;center&gt;Часы с плавным вращением стрелок&lt;/center&gt;&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Скачать вариант сделаный автором можно по ссылке: &lt;a href=&quot;http://catlikecoding.com/unity/tutorials/basics/game-objects-and-scripts/animating-the-clock/animating-the-clock.unitypackage&quot;&gt;1.unitypackage&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Скачать вариант сделанный переводчиком можно по ссылке: &lt;a href=&quot;\content\2018\01\GameObjectsAndScripts\Clock.unitypackage&quot;&gt;2.unitypackage&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;На этом все. Спасибо за внимание.&lt;/p&gt;

&lt;script id=&quot;dsq-count-scr&quot; src=&quot;//https-vangogih-github-io.disqus.com/count.js&quot; async=&quot;&quot;&gt;&lt;/script&gt;

&lt;script type=&quot;text/javascript&quot; src=&quot;https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML&quot;&gt;
&lt;/script&gt;</content><author><name></name></author><summary type="html">Привет. В один прекрасный день, пытаясь решить одну свою проблему, связанную с Unity3D, я наткнулся на блог одного человека. В этом блоге было представлено множество разных уроков по Unity3D. Сам парень из Дании и производство подобных статей для него является бизнесом. Он делает реально крутой контент, который ну просто грех не перевести на русский язык. Я связался с ним и попросил разрешения на перевод, на что он дал добро. Потому я запускаю большой цикл статей с переводом его уроков по Unity3D.</summary></entry><entry><title type="html">Проба пера. Слепая печать.</title><link href="http://localhost:4000/jekyll/update/2018/01/03/hello-world.html" rel="alternate" type="text/html" title="Проба пера. Слепая печать." /><published>2018-01-03T04:24:17+03:00</published><updated>2018-01-03T04:24:17+03:00</updated><id>http://localhost:4000/jekyll/update/2018/01/03/hello-world</id><content type="html" xml:base="http://localhost:4000/jekyll/update/2018/01/03/hello-world.html">&lt;p&gt;Привет. Этот пост скорее не большая проба пера, нежели чем реально что-то серьезное.&lt;/p&gt;

&lt;p&gt;Вы когда-нибудь задумывались над тем на сколько скорость набора текста/кода влияет на вашу производительность? На сколько знание hotkeys реально делает взаимодействие с Вашим компьютером быстрее? Пробовали ли Вы полностью отказаться от использования мыши?&lt;/p&gt;

&lt;p&gt;Вопросы на первый взгляд очень скучные, но, однако, позвольте Вас сразу прервать. На данный момент я набираю текст со скоростью примерно в 200-220 символов в минуту используя метод слепой печати. Предположим, что данная статья будет состоять из 10000 символов, значит на то чтобы написать её у меня уедет 50 минут. Это и без того довольно много времени с учетом того что текст еще нужно перечитать перед публикацией, внести правки, проверить ошибки и т.д.. В условиях нынешних реалий приходится постоянно куда-то спешить и вот так просто тратить каждый день по несколько часов на то чтобы выражать свои мысли непозволительная роскошь. А если Вы программист и не умеете печатать в слепую, у меня для Вас плохие новости. Неумение выжимать из своего компьютера максимум для программиста просто первый признак того что Вы не желаете стать профессионалом в пользовании компьютером и в разработке ПО.&lt;/p&gt;

&lt;p&gt;Представим, что у Вас есть пример реализации кода строчек так примерно на 1000. С учетом всех изменений и непрерывного написания программы без использования метода слепой печати у Вас может уйти слишком много времени на написание простого кода. Ну например вы создаете класс в котором 20 полей, 5 конструкторов, 2 публичных и 10 приватных методов. Вы набираете методы пальчиками? Еще и смотря на клавиатуру? Плохо… Неэффективно… Уволить!&lt;/p&gt;

&lt;p&gt;Я сам пишу программы на языке C# используя IDE Rider 2017.3 (на 03.01.2018). и использование как hotkeys так и сниппетов для автоматической генерации кода значительно упрощает жизнь. Сниппеты подбираются и настраиваются индивидуально под Вот самые &lt;code class=&quot;highlighter-rouge&quot;&gt;часто используемые hotkeys&lt;/code&gt;:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-hotkeys&quot; data-lang=&quot;hotkeys&quot;&gt;Shift+Alt+ArrowUp/ArrowDown - позволяет перемещать строки кода, которые находятся на строке где стоит курсор вверх вниз по коду
Ctrl + Q - быстрая документация 
Ctrl + N - быстрый поиск по всей IDE (Google внутри IDE)
Ctrl + L - удалить сроку на которой расположен курсор
Ctrl + H - замена текста в локальном файле, который в данный момент открыт в IDE
Ctrl + Shift + H - замена текста во всем проекте
Ctrl + Ctrl + ArrowUp/ArrowDown (двойное нажатие на CTRL) - режим иультикурсора, который позволяет &quot;разможить&quot; курсор сразу на несколько строк
Ctrl + W - интелектуальное выделение слов
Crtl + F - поиск слов 
Crtl + . - закомментировать/раскомментировать код
F2 - переименовать переменную, класс, метод, интерфейс и т.д.
Ctrl+  Shift + R - удобная менюшка для быстрого рефакторинга кода
F5 - запуск программы в режиме Debug
Ctrl + F5 - запуск программы в режиме Run
Ctrl + Shift + F5 - остановка выполения программы
Alt + 1 - вкладка с проектом
Alt + 2 - список закладок и точек останова
Alt + 3 - окошко Find usages (найти использование)
Alt + 8 - окошко UnitTests
Ctrl + tab - перключение между вклаками 
Ctrl+K - коммит
Ctrl + T,R - запустить UnitTest&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Если вообще не понятно о чем вообще идет речь, то вот подробнейшая инструкция с чего стоит начать&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Инструкция:&lt;/code&gt;&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;Переходите по ссылке и скачиваете &lt;a href=&quot;https://yadi.sk/d/KyT2iMtO3RAYSx&quot;&gt;Stamina&lt;/a&gt;.&lt;/li&gt;
  &lt;li&gt;Начинаете уроки. По порядку никуда не спеша.&lt;/li&gt;
  &lt;li&gt;Повторяете 2 пункт раза 3-7 в неделю.&lt;/li&gt;
  &lt;li&gt;Через месяц получаете профит.&lt;/li&gt;
  &lt;li&gt;Через 2 месяца активное тренировки скорость печати вырастает до 200-250 символов в минуту&lt;/li&gt;
  &lt;li&gt;Через пол года до 300-350&lt;/li&gt;
  &lt;li&gt;Предела нет, продолжай совершенствоваться, чем быстрее печатаешь, тем лучше.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Если вы любите посидеть и попереписываться в VK, Telegram, Facebook и подобном, то увеличив скорость набора текста получится не только больше писать и всегда иметь преимущество перед человеком, который набирает текст медленнее Вас (например, в жарком споре, когда пишутся огромные серенады), но и экономить кучу времени переключаясь между задачами. Когда Вам нужно просто быстро ответить с минимальными затратами по времени чтобы не потерять концентрацию.&lt;/p&gt;

&lt;p&gt;Спасибо за внимание!&lt;/p&gt;

&lt;div id=&quot;disqus_thread&quot;&gt;&lt;/div&gt;
&lt;script&gt;

var disqus_config = function () {
this.page.url = https://vangogih.github.io/;  // Replace PAGE_URL with your page's canonical URL variable
this.page.identifier = /jekyll/update/2018/01/03/hello-world.html; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
};
*/
(function() { // DON'T EDIT BELOW THIS LINE
var d = document, s = d.createElement('script');
s.src = 'https://https-vangogih-github-io.disqus.com/embed.js';
s.setAttribute('data-timestamp', +new Date());
(d.head || d.body).appendChild(s);
})();
&lt;/script&gt;

&lt;noscript&gt;Please enable JavaScript to view the &lt;a href=&quot;https://disqus.com/?ref_noscript&quot;&gt;comments powered by Disqus.&lt;/a&gt;&lt;/noscript&gt;

&lt;script id=&quot;dsq-count-scr&quot; src=&quot;//https-vangogih-github-io.disqus.com/count.js&quot; async=&quot;&quot;&gt;&lt;/script&gt;</content><author><name></name></author><summary type="html">Привет. Этот пост скорее не большая проба пера, нежели чем реально что-то серьезное. Вы когда-нибудь задумывались над тем на сколько скорость набора текста/кода влияет на вашу производительность? На сколько знание hotkeys реально делает взаимодействие с Вашим компьютером быстрее? Пробовали ли Вы полностью отказаться от использования мыши? Вопросы на первый взгляд очень скучные, но, однако, позвольте Вас сразу прервать. На данный момент я набираю текст со скоростью примерно в 200-220 символов в минуту используя метод слепой печати. Предположим, что данная статья будет состоять из 10000 символов, значит на то чтобы написать её у меня уедет 50 минут. Это и без того довольно много времени с учетом того что текст еще нужно перечитать перед публикацией, внести правки, проверить ошибки и т.д.. В условиях нынешних реалий приходится постоянно куда-то спешить и вот так просто тратить каждый день по несколько часов на то чтобы выражать свои мысли непозволительная роскошь. А если Вы программист и не умеете печатать в слепую, у меня для Вас плохие новости. Неумение выжимать из своего компьютера максимум для программиста просто первый признак того что Вы не желаете стать профессионалом в пользовании компьютером и в разработке ПО. Представим, что у Вас есть пример реализации кода строчек так примерно на 1000. С учетом всех изменений и непрерывного написания программы без использования метода слепой печати у Вас может уйти слишком много времени на написание простого кода. Ну например вы создаете класс в котором 20 полей, 5 конструкторов, 2 публичных и 10 приватных методов. Вы набираете методы пальчиками? Еще и смотря на клавиатуру? Плохо… Неэффективно… Уволить! Я сам пишу программы на языке C# используя IDE Rider 2017.3 (на 03.01.2018). и использование как hotkeys так и сниппетов для автоматической генерации кода значительно упрощает жизнь. Сниппеты подбираются и настраиваются индивидуально под Вот самые часто используемые hotkeys: Shift+Alt+ArrowUp/ArrowDown - позволяет перемещать строки кода, которые находятся на строке где стоит курсор вверх вниз по коду Ctrl + Q - быстрая документация Ctrl + N - быстрый поиск по всей IDE (Google внутри IDE) Ctrl + L - удалить сроку на которой расположен курсор Ctrl + H - замена текста в локальном файле, который в данный момент открыт в IDE Ctrl + Shift + H - замена текста во всем проекте Ctrl + Ctrl + ArrowUp/ArrowDown (двойное нажатие на CTRL) - режим иультикурсора, который позволяет &quot;разможить&quot; курсор сразу на несколько строк Ctrl + W - интелектуальное выделение слов Crtl + F - поиск слов Crtl + . - закомментировать/раскомментировать код F2 - переименовать переменную, класс, метод, интерфейс и т.д. Ctrl+ Shift + R - удобная менюшка для быстрого рефакторинга кода F5 - запуск программы в режиме Debug Ctrl + F5 - запуск программы в режиме Run Ctrl + Shift + F5 - остановка выполения программы Alt + 1 - вкладка с проектом Alt + 2 - список закладок и точек останова Alt + 3 - окошко Find usages (найти использование) Alt + 8 - окошко UnitTests Ctrl + tab - перключение между вклаками Ctrl+K - коммит Ctrl + T,R - запустить UnitTest Если вообще не понятно о чем вообще идет речь, то вот подробнейшая инструкция с чего стоит начать Инструкция: Переходите по ссылке и скачиваете Stamina. Начинаете уроки. По порядку никуда не спеша. Повторяете 2 пункт раза 3-7 в неделю. Через месяц получаете профит. Через 2 месяца активное тренировки скорость печати вырастает до 200-250 символов в минуту Через пол года до 300-350 Предела нет, продолжай совершенствоваться, чем быстрее печатаешь, тем лучше. Если вы любите посидеть и попереписываться в VK, Telegram, Facebook и подобном, то увеличив скорость набора текста получится не только больше писать и всегда иметь преимущество перед человеком, который набирает текст медленнее Вас (например, в жарком споре, когда пишутся огромные серенады), но и экономить кучу времени переключаясь между задачами. Когда Вам нужно просто быстро ответить с минимальными затратами по времени чтобы не потерять концентрацию. Спасибо за внимание! Please enable JavaScript to view the comments powered by Disqus.</summary></entry></feed>