<!doctype html>
<!-- The Time Machine GitHub pages theme was designed and developed by Jon Rohan, on Feb 7, 2012. -->
<!-- Follow him for fun. http://twitter.com/jonrohan. Tail his code on https://github.com/jonrohan -->
<html lang="en-US">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">

  <link rel="stylesheet" href="/assets/css/style.css?v=">
  <script type="text/javascript" src="https://ajax.googleapis.com/ajax/libs/jquery/1.7.1/jquery.min.js"></script>
  <script type="text/javascript" src="/assets/js/script.js"></script>

<!-- Begin Jekyll SEO tag v2.4.0 -->
<title>Unity3D Урок №2. Построение графика. Математическая визуализация | Блог Маслёнка</title>
<meta name="generator" content="Jekyll v3.6.2" />
<meta property="og:title" content="Unity3D Урок №2. Построение графика. Математическая визуализация" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="Построение графика. Математическая визуализация" />
<meta property="og:description" content="Построение графика. Математическая визуализация" />
<link rel="canonical" href="http://localhost:4000/jekyll/update/2018/02/18/Building-Graph.html" />
<meta property="og:url" content="http://localhost:4000/jekyll/update/2018/02/18/Building-Graph.html" />
<meta property="og:site_name" content="Блог Маслёнка" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2018-02-18T19:00:00+03:00" />
<script type="application/ld+json">
{"description":"Построение графика. Математическая визуализация","@type":"BlogPosting","url":"http://localhost:4000/jekyll/update/2018/02/18/Building-Graph.html","headline":"Unity3D Урок №2. Построение графика. Математическая визуализация","dateModified":"2018-02-18T19:00:00+03:00","datePublished":"2018-02-18T19:00:00+03:00","mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/jekyll/update/2018/02/18/Building-Graph.html"},"@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->

  <meta name="description" content="All contents under (CC) BY-NC-SA license, unless otherwise noted. ">

  <meta name="viewport" content="width=device-width,initial-scale=1">

</head>

<body>

  <div class="wrapper">
    <header>
	  <a class="title" href = "http://localhost:4000"> Блог Маслёнка </a>
    </header>
    <div id="container">
      <p class="tagline">All contents under (CC) BY-NC-SA license, unless otherwise noted. </p>
      <div id="main" role="main">
        <article class="markdown-body">
          <h2 id="Построение-графика-Математическая-визуализация"><strong>Построение графика. Математическая визуализация</strong></h2>

<ul>
  <li>Создадим префаб.</li>
  <li>Создадим линию из кубов.</li>
  <li>Отобразим математическую функцию.</li>
  <li>Создадим свой собственный шейдер.</li>
  <li>Анимируем наш график.</li>
</ul>

<p>В этом уроке мы будем использовать игровые объекты для построения графиков по математическим формулам. Мы также сделаем функцию, зависящую от времени, в результате чего получится анимация графика.</p>

<p>Этот урок предполагает, что вы ознакомились с уроком <a href="/jekyll/update/2018/01/17/Game-Objects-and-Scripts.html">Игровые объекты и скрипты</a>. Этот урок, как и прошлый был сделан в Unity версии 2017.1.0.</p>

<center><img src="\images\2018\02\BuildingGraph\tutorial-image.jpg" /></center>
<p><em><center>Синусоида из кубов</center></em></p>

<h2 id="1Создадим-линию-из-кубов"><strong>1.Создадим линию из кубов</strong></h2>

<p>Хорошее понимание математики имеет важное значение при программировании. На своем фундаментальном уровне математика – это манипулирование символами, представляющие числа. Решение уравнений сводится к переписыванию одного набора символов, который становится другим – обычно более коротким набором символов. Правила математики диктуют как именно это переписывание может быть сделано.</p>

<p>Например, у нас есть функция <script type="math/tex">f(x) = x + 1</script>. Мы можем заменить <script type="math/tex">x</script>, скажем на 3. Тогда получится <script type="math/tex">f(3) = 3 + 1 = 4</script>. Мы передали 3 как входное значение параметра <script type="math/tex">x</script>, а на выходе получили значение 4 как результат выполнения некоторой математической функции. Так же мы можем сказать, что это функция <a href="https://ru.wikipedia.org/wiki/Map">map</a> 3 к 4. В более коротком виде это можно записать так: <script type="math/tex">(3,4)</script>. Мы можем создать множества пар формы <script type="math/tex">(x, f(x))</script>. Например, (5,6), (8,9), (1,2), (6,7). Но легче понять функцию, когда мы упорядочиваем пары по входным-выходным значениям. (1,2), (2,3), (3,4) и т.д.</p>

<p>Функция <script type="math/tex">f(x) = x + 1</script> проста для понимания. <script type="math/tex">f(x) = (x -1)^4 + 5x^3 – 8x^2 + 3x</script> сложна. Мы бы могли записать несколько пар ввода-вывода, но это, вероятно, не даст нам понимания о том, как выглядит график этой функции. Нам нужно будет записать множество точек, которые находятся близко друг к другу. Как результат мы получим море чисел, которые очень сложно разобрать. Вместо этого мы могли бы интерпретировать пары как двумерные координаты вида <script type="math/tex">\left[\begin{array}{c}x\\f(x)\end{array}\right]</script>. Это 2D вектор где вверху представлены координаты по оси Х, а внизу координаты для оси Y. По другому еще это можно записать так: <script type="math/tex">y = f(x)</script>. Если мы будем использовать достаточное количество точек, то результатом соединения точек друг за другом станет график.</p>

<center><img src="\images\2018\02\BuildingGraph\graph.png" /></center>
<p><em>График <script type="math/tex">y = (x -1)^4 + 5x^3 – 8x^2 + 3x</script> построенный на интервале от -2 до 2</em></p>

<p>Визуализация может быстро дать нам представление о том, как ведет себя функция. Это очень удобный инструмент, потому давайте сделаем подобное в Unity. Для начала создайте пустую сцену <em>File / New Scene</em> или используйте сцену по умолчанию, которая создается при создании нового проекта.</p>

<h2 id="11-Префабы"><strong>1.1 Префабы</strong></h2>
<p>Графики создаются путем размещения точек по соответствующим координатам. Для этого нам понадобится 3D визуализация точки. Мы не будем изобретать велосипед, потому будем использовать объект, который доступен в Unity по умолчанию – куб. Добавим один на нашу сцену и удалим у него коллайдер, потому что нам не нужно чтобы куб взаимодействовал с другими объектами.</p>

<blockquote>
  <p>Являются ли кубы лучшим решением для визуализации графиков?</p>

  <p>Можно так же использовать систему частиц или сегменты линий, но проще всего использовать отдельные кубы.</p>
</blockquote>

<p>Мы будем использовать скрипт, чтобы создать много экземпляров этого куба и расположить их правильно. Для этого мы будем использовать куб в качестве шаблона. Перетащите куб из окна иерархии в окно проекта. Это позволит создать новый объект со значком синего куба, этого объект более известен как <em>префаб (Prefab)</em>. Это готовый игровой объект, который существует в проекте, но не на сцене.</p>

<center><img src="\images\2018\02\BuildingGraph\prefab.png" /></center>
<p><em><center>Префаб куба</center></em></p>

<p>Префабы – удобный способ настройки игровых объектов. При изменении главного префаба, который находится в проекте, все его экземпляры в любой сцене изменяются одинаково. Например, изменение масштаба префаба так же изменит масштаб куба, который все еще находится на сцене. Однако каждый экземпляр использует свое собственное положение и поворот. Кроме того, свойства у каждого игрового объекта можно изменить, никак не повлияв на префаб, но это отходит от сути ради которой был создан префаб. При больших изменениях, таких как добавление или удаление компонента, связь между префабом и экземпляром будет нарушена.</p>

<p>Мы хотим написать скрипт для создания экземпляров префаба, поэтому нам больше не нужен экземпляр куба, который в настоящее время находится на сцене. Просто удалите его.</p>

<h2 id="12-Компонент-graph"><strong>1.2 Компонент Graph</strong></h2>
<p>Нам понадобится скрипт на C# для того чтобы создать наш график. Давайте создадим один, и назовем его Graph. Мы начнем с простого класса, который будет расширять класс <code class="highlighter-rouge">MonoBehavior</code> , так его можно использовать как компонент для игровых объектов. Создадим публичное поле, которое будет ссылаться на префаб для создания точек, дадим ему имя <code class="highlighter-rouge">pointPrefab</code>. Так как нам понадобится доступ к компоненту <code class="highlighter-rouge">Transform</code> для позиционирования точек, то установим этот тип у нашего поля.</p>
<div class="language-c# highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">using</span> <span class="nn">UnityEngine</span><span class="p">;</span>
<span class="k">public</span> <span class="k">class</span> <span class="nc">Graph</span> <span class="p">:</span> <span class="n">MonoBehaviour</span> 
<span class="p">{</span>
	<span class="k">public</span> <span class="n">Transform</span> <span class="n">pointPrefab</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>
<p>Добавим пустой игровой объект на сцену, с помощью <em>GameObject /Create Empty</em>, установим его в начале, и назовем его Graph. Добавим наш скрипт Graph к этому объекту, с помощью переноса или кнопки <em>Add Component</em>. Затем перетащим наш префаб из окна проекта в созданное нами поле <em>Point Prefab</em>. Теперь он ссылается на компонент префаба –  <em>Transform</em>.</p>
<center><img src="\images\2018\02\BuildingGraph\graph-with-prefab.png" /></center>
<p><em><center>Объект Graph с компонентом Graph, который содержит ссылку на префаб Cube</center></em></p>

<h2 id="13-Создание-экземпляров-префаба"><strong>1.3 Создание экземпляров префаба</strong></h2>
<p>Создание экземпляра объекта игры осуществляется через метод <em>Instantiate</em>. Это общедоступный метод, который мы получили из класса <em>object</em>, от которого неявно наследуется <em>MonoBehaviour</em>. Метод <em>Instantiate</em> клонирует любой объект и добавляет его на сцену. В качестве аргумента он принимает любой объект, который есть в <em>Unity</em>. Если мы укажем в качестве аргумента наш префаб, то в результате мы увидим, как наш куб появится на сцене. Давайте вызовем этот метод в момент, когда наш <code class="highlighter-rouge">Graph</code> «пробуждается».</p>
<div class="language-c# highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">public</span> <span class="k">class</span> <span class="nc">Graph</span> <span class="p">:</span> <span class="n">MonoBehaviour</span> 
<span class="p">{</span>
	<span class="k">public</span> <span class="n">Transform</span> <span class="n">pointPrefab</span><span class="p">;</span>
	<span class="k">void</span> <span class="nf">Awake</span> <span class="p">()</span> 
	<span class="p">{</span>
		<span class="nf">Instantiate</span><span class="p">(</span><span class="n">pointPrefab</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<center><img src="\images\2018\02\BuildingGraph\instantiated-prefab.png" /></center>
<p><em><center>Создание экземпляра префаба</center></em></p>

<p>На данном этапе при переходе в режим воспроизведения будет создан один куб в начале координат, при условии, что позиция префаба будет равна нулю. Чтобы переместить его в другое место, нам нужно изменить положение нашего только что созданного экземпляра. Метод <code class="highlighter-rouge">Instantiate</code> возвращается ссылку на все, что он создал. Поскольку мы передали в метод ссылку на компонент <em>Transform</em>, то давайте попросим его вернуть нам ссылку на этот же компонент, но уже у экземпляра префаба. Создадим переменную типа <code class="highlighter-rouge">Transform</code> и присвоим ей возвращаемое значение метода <code class="highlighter-rouge">Instantiate</code>.</p>

<div class="language-c# highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">void</span> <span class="nf">Awake</span> <span class="p">()</span>
<span class="p">{</span>
	<span class="n">Transform</span> <span class="n">point</span> <span class="p">=</span> <span class="nf">Instantiate</span><span class="p">(</span><span class="n">pointPrefab</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Теперь мы можем задать положение точки, назначив ей нужное нам значение 3D вектора. Вспомните как мы задавали положение стрелкам часов в предыдущем уроке <a href="/jekyll/update/2018/01/17/Game-Objects-and-Scripts.html">Игровые объекты и скрипты</a>. Точно так же мы будем делать и для точек графика. Мы будем изменять локальное положение через свойство <code class="highlighter-rouge">localPosition</code>, а не через <code class="highlighter-rouge">position</code>.</p>

<p>3D вектора создаются при помощи структуры <code class="highlighter-rouge">Vector3</code>. Поскольку это структура, то используется она в контексте значения, примерно так же как число, она не является объектом. Например, можно вручную установть координату X равной 1, оставив координаты Y и Z равные нулю, но можно использовать свойство <code class="highlighter-rouge">Vector3.right</code> которое хранит в себе значения для координат X,Y,Z равные (+1,0,0).</p>
<div class="language-c# highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Transform</span> <span class="n">point</span> <span class="p">=</span> <span class="nf">Instantiate</span><span class="p">(</span><span class="n">pointPrefab</span><span class="p">);</span>
<span class="n">point</span><span class="p">.</span><span class="n">localPosition</span> <span class="p">=</span> <span class="n">Vector3</span><span class="p">.</span><span class="n">right</span><span class="p">;</span>
</code></pre></div></div>

<blockquote>
  <p>Разве свойства не должны писаться с большой буквы?</p>

  <p>По негласному соглашению так и есть. Мы должны давать имена свойствам с заглавной буквы, но в Unity очень часто пренебрегают этим.</p>
</blockquote>

<p>При переходе в режим игры мы все равно получаем один куб, только в немного другой позиции. Давайте создадим второй экземпляр, сместив его немного вправо. Это можно сделать, умножив наш вектор на 2. Продублируйте строку с созданием экземпляра объекта и строку с изменением позиции, но умножив правый вектор на 2 <code class="highlighter-rouge">Vector3.right *2</code>.</p>

<div class="language-c# highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Transform</span> <span class="n">point</span> <span class="p">=</span> <span class="nf">Instantiate</span><span class="p">(</span><span class="n">pointPrefab</span><span class="p">);</span>
<span class="n">point</span><span class="p">.</span><span class="n">localPosition</span> <span class="p">=</span> <span class="n">Vector3</span><span class="p">.</span><span class="n">right</span><span class="p">;</span>
<span class="n">Transform</span> <span class="n">point</span> <span class="p">=</span> <span class="nf">Instantiate</span><span class="p">(</span><span class="n">pointPrefab</span><span class="p">);</span>
<span class="n">point</span><span class="p">.</span><span class="n">localPosition</span> <span class="p">=</span> <span class="n">Vector3</span><span class="p">.</span><span class="n">right</span> <span class="p">*</span> <span class="m">2f</span><span class="p">;</span>
</code></pre></div></div>

<blockquote>
  <p>Можем ли мы перемножать структуры и числа?</p>

  <p>“Из под коробки” такого функционала нет, но можно добавить его. Это делается путем создания метода со специальным синтаксисом, который перегружает символ умножения <code class="highlighter-rouge">*</code>. В этом случае, то, что кажется простым умножением, но на самом деле является вызовом метода, что-то вроде <code class="highlighter-rouge">Vector3.Multiply(Vector3.right, 2f)</code>.</p>

  <p>Возможность использовать методы, как если бы они были простыми операциям, делает написание кода более быстрым и легким для чтения. Это не особо важно, но приятно иметь такую возможность, так же, как возможность неявно использовать пространства имен. Такой более удобное написание называется синтаксическим сахаром.</p>

  <p>Но когда мы внедряем подобный сахар, то мы должны быть уверены, что подобное сокращение не приведет к двузначности в понимании нашего сокращения. Методы, должны выполнять только то, что определено конкретным символом (сложение, умножение, деление и т.д.). В случае векторов некоторые математические операторы четко определены, поэтому мы можем спокойно использовать сахар для векторов.</p>
</blockquote>

<p>Код, который мы только что написали приведет к ошибке компиляции, потому что мы пытаемся определить переменную <code class="highlighter-rouge">point</code> дважды. Если мы хотим использовать другую переменную, мы должны дать ей другое имя. Нам уже не нужна ссылка на первую точку (куб), поэтому просто создайте новый экземпляр точки использовав ту же переменную.</p>

<div class="language-c# highlighter-rouge"><div class="highlight"><pre class="highlight"><code>	<span class="n">Transform</span> <span class="n">point</span> <span class="p">=</span> <span class="nf">Instantiate</span><span class="p">(</span><span class="n">pointPrefab</span><span class="p">);</span>
	<span class="n">point</span><span class="p">.</span><span class="n">localPosition</span> <span class="p">=</span> <span class="n">Vector3</span><span class="p">.</span><span class="n">right</span><span class="p">;</span>
<span class="c1">//	Transform point = Instantiate(pointPrefab);</span>
	<span class="n">point</span> <span class="p">=</span> <span class="nf">Instantiate</span><span class="p">(</span><span class="n">pointPrefab</span><span class="p">);</span>
	<span class="n">point</span><span class="p">.</span><span class="n">localPosition</span> <span class="p">=</span> <span class="n">Vector3</span><span class="p">.</span><span class="n">right</span> <span class="p">*</span> <span class="m">2f</span><span class="p">;</span>
</code></pre></div></div>

<center><img src="\images\2018\02\BuildingGraph\two-instances.png" /></center>
<p><em><center>Два экземпляра с координатой по оси X равной 1 и 2.</center></em></p>

<h2 id="14-Циклы"><strong>1.4 Циклы</strong></h2>
<p>Давайте создадим больше точек, например, 10. Мы, конечно, можем просто продублировать код, который у нас уже есть еще 8 раз, но это очень неэффективно. В идеале, мы пишем код только для одной точки и поручаем программе выполнить его несколько раз с небольшими изменениями.</p>

<p>Ключевое слово <code class="highlighter-rouge">while</code> будет повторять блок кода, которые написан внутри него. Напишите <code class="highlighter-rouge">while</code> после него поставьте фигурные скобки <code class="highlighter-rouge">{}</code> и внутри этих скобок впишите первые 2 строки, остальное удалите.</p>

<div class="language-c# highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">void</span> <span class="nf">Awake</span> <span class="p">()</span> 
<span class="p">{</span>
	<span class="k">while</span> 
	<span class="p">{</span>
		<span class="n">Transform</span> <span class="n">point</span> <span class="p">=</span> <span class="nf">Instantiate</span><span class="p">(</span><span class="n">pointPrefab</span><span class="p">);</span>			
		<span class="n">point</span><span class="p">.</span><span class="n">localPosition</span> <span class="p">=</span> <span class="n">Vector3</span><span class="p">.</span><span class="n">right</span><span class="p">;</span>
	<span class="p">}</span>
<span class="c1">//		point = Instantiate(pointPrefab);</span>
<span class="c1">//		point.localPosition = Vector3.right * 2f;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Так же, как и оператор <code class="highlighter-rouge">if</code> оператор <code class="highlighter-rouge">while</code> должен иметь условие, которое указывается в круглых скобках. Как и в случае с <code class="highlighter-rouge">if</code>, следующий за условием блок кода будет выполняться только в том случае, если выражение имеет значение <code class="highlighter-rouge">true</code>. Если указанное условие истинно, то выполнится код, который описан внутри фигурных скобок, после этого программа вернется проверить выполнилось ли условие. Если нет, то цепочка действий будет повторяться до тех пор, пока условие не станет <code class="highlighter-rouge">false</code>.</p>

<p>Поэтому мы должны создавать такое условие, которое точно выполнится через какой-то промежуток времени. Создание бесконечных циклов ни к чему хорошему не приводит. Программа просто зависает и перестает работать. Давайте добавим самое простое условие, которое точно не будет бесконечным циклом.</p>

<div class="language-c# highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">while</span> <span class="p">(</span><span class="k">false</span><span class="p">)</span> 
<span class="p">{</span>
	<span class="n">Transform</span> <span class="n">point</span> <span class="p">=</span> <span class="nf">Instantiate</span><span class="p">(</span><span class="n">pointPrefab</span><span class="p">);</span>
	<span class="n">point</span><span class="p">.</span><span class="n">localPosition</span> <span class="p">=</span> <span class="n">Vector3</span><span class="p">.</span><span class="n">right</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<blockquote>
  <p>Можем ли мы проинициализировать переменную внутри цикла?</p>

  <p>Конечно. Каждый раз, когда цикл будет повторяться он будет создавать новую переменную заданного типа с заданным именем, а по завершении удалять ее. Переменные, определенные вне цикла так же можно использовать.</p>

  <p>Но важно знать одну вещь: проинициализированная переменная внутри цикла будет доступна только в нем т.е. мы не сможем использовать эту переменную вне блока <code class="highlighter-rouge">while</code>.</p>
</blockquote>

<p>Ограничить количество итераций можно путем отслеживания того, сколько раз мы повторяли код. Мы можем использовать целочисленную переменную, чтобы отслеживать это. Пременная будет содержать в себе номер итерации цикла. Объявим новую переменную типа <code class="highlighter-rouge">int</code> и назовем её <code class="highlighter-rouge">i</code> от слова <em>iteration</em>. Нам нужно чтобы эта переменная хранила в себе номер итерации. Если мы ее объявим внутри цикла, то она будет постоянно объявляться заново, поэтому сделаем это вне цикла.</p>

<div class="language-c# highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">void</span> <span class="nf">Awake</span> <span class="p">()</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="k">false</span><span class="p">)</span> 
	<span class="p">{</span>
		<span class="n">Transform</span> <span class="n">point</span> <span class="p">=</span> <span class="nf">Instantiate</span><span class="p">(</span><span class="n">pointPrefab</span><span class="p">);</span>
		<span class="n">point</span><span class="p">.</span><span class="n">localPosition</span> <span class="p">=</span> <span class="n">Vector3</span><span class="p">.</span><span class="n">right</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>На каждой итерации увеличиваем значение счетчика на единицу.</p>
<div class="language-c# highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">void</span> <span class="nf">Awake</span> <span class="p">()</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="k">false</span><span class="p">)</span> 
	<span class="p">{</span>
		<span class="n">i</span> <span class="p">=</span> <span class="n">i</span> <span class="p">+</span> <span class="m">1</span><span class="p">;</span>
		<span class="n">Transform</span> <span class="n">point</span> <span class="p">=</span> <span class="nf">Instantiate</span><span class="p">(</span><span class="n">pointPrefab</span><span class="p">);</span>
		<span class="n">point</span><span class="p">.</span><span class="n">localPosition</span> <span class="p">=</span> <span class="n">Vector3</span><span class="p">.</span><span class="n">right</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Если мы сейчас запустим наш код, то это приведет в ошибке компиляции. Это произошло потому что наша переменная не проинициализирована. Мы как бы пытаемся прибавить единицу к неопределённому значению, чего сделать конечно же невозможно*. Нужно явно указать значение, к которому будет прибавляться единица.</p>

<blockquote>
  <ul>
    <li>Примечание от переводчика.</li>
  </ul>

  <p>Вы могли задаться вопросом: «Если мы не проинициализируем переменную и попытаемся узнать, чему она равна, то окажется что она равно нулю. Для чего тогда нам явно указывать то, что уже было сделано до нас?».</p>

  <p>В других языках, например, C++, при объявлении переменной её значение вообще заполнено «мусором». Оно может быть равно любому числу, которое попадает в диапазон, покрываемый значением типа <code class="highlighter-rouge">int</code>. При разработке на C# мы можем не задумываться об этом, мы знаем, что значение переменной по умолчанию равно нулю. Конструкцию <code class="highlighter-rouge">i = i + 1;</code> можно расшифровать как: «Возьми значение переменной <code class="highlighter-rouge">i</code> прибавь к нему единицу и получившееся значение присвой переменной <code class="highlighter-rouge">i</code>.» Но какое именно значение переменной нужно взять? 0? 1? 100000? Откуда именно начинать отсчет, никому не понятно. Разработчики языка учли этот момент и сделали обязательным инициализацию переменной, которой потом происходят какие-либо манипуляции. Чтобы не возникало путаницы, чтобы любому человеку, который будет работать с этим кодом было понятно откуда именно мы ведем отсчет. Так же это сделано для безопасности кода, мы ведь не знаем действительно ли значение по умолчанию равно нулю. Понимаю, звучит абсурдно, но мы можем обходными путями добиться того чтобы наши переменные имели какое угодно значение по умолчанию. Но мы пишем код на высокоуровневом языке программирования, зачем нам об это вообще думать. Так вот и не думайте, за вас уже этот момент продумали. Просто явно укажите откуда именно вы хотите вести счет.</p>
</blockquote>

<div class="language-c# highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">i</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span>
</code></pre></div></div>

<p>Проговорим что нам нужно. Нам нужно чтобы цикл выполнился определённое количество раз. Для этого мы создали счетчик. Когда цикл начинает выполняться, то <code class="highlighter-rouge">i</code> увеличивается на единицу. При первом проходе она равна 1, потом 2, потом 3 на 10 проходе она равна 9. Допустим я хочу, чтобы цикл закончил выполняться после 10 итераций. Значит нам нужно чтобы цикл выполнялся пока значение счетчика меньше 10. Математически это условие можно записать как <script type="math/tex">% <![CDATA[
i  < 10 %]]></script>.</p>

<p>После того как мы проговорили это, нужно прописать это условие в коде:</p>

<div class="language-c# highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">i</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span>
<span class="k">while</span> <span class="p">(</span><span class="n">i</span> <span class="p">&lt;</span> <span class="m">10</span><span class="p">)</span> 
<span class="p">{</span>
	<span class="n">i</span> <span class="p">=</span> <span class="n">i</span> <span class="p">+</span> <span class="m">1</span><span class="p">;</span>
	<span class="n">Transform</span> <span class="n">point</span> <span class="p">=</span> <span class="nf">Instantiate</span><span class="p">(</span><span class="n">pointPrefab</span><span class="p">);</span>
	<span class="n">point</span><span class="p">.</span><span class="n">localPosition</span> <span class="p">=</span> <span class="n">Vector3</span><span class="p">.</span><span class="n">right</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Теперь после перехода в режим воспроизведения мы получим 10 кубов. Но все они окажутся в одной позиции. Чтобы переместить их в ряд вдоль оси X, умножьте правый вектор на <code class="highlighter-rouge">i</code>.</p>

<div class="language-c# highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">point</span><span class="p">.</span><span class="n">localPosition</span> <span class="p">=</span> <span class="n">Vector3</span><span class="p">.</span><span class="n">right</span> <span class="p">*</span> <span class="n">i</span><span class="p">;</span>
</code></pre></div></div>

<center><img src="\images\2018\02\BuildingGraph\ten-cubes.png" /></center>
<p><em><center>Десять кубов в ряд.</center></em></p>

<p>Обратите внимание, что сейчас координаты первого куда по оси X начинаются с 1, а заканчиваются 10. Это не много не то что мы хотели. Поскольку счет мы начинаем с 0, то хотим чтобы наш первый куб был с координатой 0. Мы можем сдвинуть все точки на одну единицу влево, умножив наш вектор на <code class="highlighter-rouge">i-1</code> вместо <code class="highlighter-rouge">i</code>. Но подобные вещи в программировании принято называть костылями. Но у нас есть более элегантное решение.</p>

<div class="language-c# highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">while</span> <span class="p">(</span><span class="n">i</span> <span class="p">&lt;</span> <span class="m">10</span><span class="p">)</span> 
<span class="p">{</span>
<span class="c1">//	i = i + 1;</span>
<span class="n">Transform</span> <span class="n">point</span> <span class="p">=</span> <span class="nf">Instantiate</span><span class="p">(</span><span class="n">pointPrefab</span><span class="p">);</span>
	<span class="n">point</span><span class="p">.</span><span class="n">localPosition</span> <span class="p">=</span> <span class="n">Vector3</span><span class="p">.</span><span class="n">right</span> <span class="p">*</span> <span class="n">i</span><span class="p">;</span>
	<span class="n">i</span> <span class="p">=</span> <span class="n">i</span> <span class="p">+</span> <span class="m">1</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="15-Лаконичный-синтаксис"><strong>1.5 Лаконичный синтаксис</strong></h2>
<p>Использование циклов очень распространено в программировании. В любой ситуации где наши действия нужно выполнить несколько раз используется цикл. Чем сложнее код внутри цикла, тем сложнее понять, что он делает. Для упрощения чтения и понимания кода существует такая вещь как «синтаксический сахар».</p>

<p>Например, давайте рассмотрим увеличение операцию инкремента. Увеличение счетчика на единицу мы можем написать так: <code class="highlighter-rouge">i = i + 1;</code>, но можем и так <code class="highlighter-rouge">i += 1;</code>. Подобные сокращения и называются синтаксическим сахаром.</p>

<div class="language-c# highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//	i = i + 1;</span>
	<span class="n">i</span> <span class="p">+=</span> <span class="m">1</span><span class="p">;</span>
</code></pre></div></div>

<p>Но и в данной ситуации можно «добавить сахара» заменив <code class="highlighter-rouge">i += 1;</code> на <code class="highlighter-rouge">++i;</code>.</p>

<div class="language-c# highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//	i += 1;</span>
	<span class="p">++</span><span class="n">i</span><span class="p">;</span>
</code></pre></div></div>

<p>Стоит так же сказать об интересной особенности использования данного сахара. Подобные конструкции могут использоваться в качестве выражений. Это означает, что вы можете написать что-то вроде <code class="highlighter-rouge">y = (x += 3)</code>. Это можно расшифровать как: «Присвоить Y значение равное X + 3». Из этого можно сделать вывод что инкремент (увеличение) <code class="highlighter-rouge">i</code> мы могли бы сделать внутри условия цикла <code class="highlighter-rouge">while</code>, тем самым сократив блок кода.</p>

<div class="language-c# highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">while</span> <span class="p">(++</span><span class="n">i</span> <span class="p">&lt;</span> <span class="m">10</span><span class="p">)</span> 
<span class="p">{</span>
	<span class="n">Transform</span> <span class="n">point</span> <span class="p">=</span> <span class="nf">Instantiate</span><span class="p">(</span><span class="n">pointPrefab</span><span class="p">);</span>
	<span class="n">point</span><span class="p">.</span><span class="n">localPosition</span> <span class="p">=</span> <span class="n">Vector3</span><span class="p">.</span><span class="n">right</span> <span class="p">*</span> <span class="n">i</span><span class="p">;</span>
<span class="c1">//	++i;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Однако, сейчас мы увеличиваем <code class="highlighter-rouge">i</code> до сравнения, а не после. Это приведет к меньшему числу итераций нежели хотим мы. Специально для таких ситуаций операторы инкремента и декремента также могут быть размещены после переменной, а не перед ней.</p>

<div class="language-c# highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//while (++i &lt; 10) {</span>
<span class="k">while</span> <span class="p">(</span><span class="n">i</span><span class="p">++</span> <span class="p">&lt;</span> <span class="m">10</span><span class="p">)</span> 
<span class="p">{</span>
	<span class="n">Transform</span> <span class="n">point</span> <span class="p">=</span> <span class="nf">Instantiate</span><span class="p">(</span><span class="n">pointPrefab</span><span class="p">);</span>
	<span class="n">point</span><span class="p">.</span><span class="n">localPosition</span> <span class="p">=</span> <span class="n">Vector3</span><span class="p">.</span><span class="n">right</span> <span class="p">*</span> <span class="n">i</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Хотя цикл <code class="highlighter-rouge">while</code> работает для всех типов циклов, существует альтернативный синтаксис, особенно подходящий для итерации по диапазонам. Это цикл <code class="highlighter-rouge">for</code>. Он работает так же, как и <code class="highlighter-rouge">while</code>, за исключением того, что объявление переменной итератора и ее сравнение содержатся в круглых скобках и разделяются точкой с запятой.</p>

<div class="language-c# highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//int i = 0;</span>
<span class="c1">//while (i++ &lt; 10) {</span>
<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span><span class="p">++</span> <span class="p">&lt;</span> <span class="m">10</span><span class="p">)</span> 
<span class="p">{</span>
	<span class="n">Transform</span> <span class="n">point</span> <span class="p">=</span> <span class="nf">Instantiate</span><span class="p">(</span><span class="n">pointPrefab</span><span class="p">);</span>
	<span class="n">point</span><span class="p">.</span><span class="n">localPosition</span> <span class="p">=</span> <span class="n">Vector3</span><span class="p">.</span><span class="n">right</span> <span class="p">*</span> <span class="n">i</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Фрагмент выше приведет к ошибке компиляции, потому что на самом деле есть три части. Третья часть отвечает за увеличение итератора, как бы сохраняя его отдельно от сравнения.</p>

<div class="language-c# highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//for (int i = 0; i++ &lt; 10) {</span>
<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span> <span class="p">&lt;</span> <span class="m">10</span><span class="p">;</span> <span class="n">i</span><span class="p">++)</span> 
<span class="p">{</span>
	<span class="n">Transform</span> <span class="n">point</span> <span class="p">=</span> <span class="nf">Instantiate</span><span class="p">(</span><span class="n">pointPrefab</span><span class="p">);</span>
	<span class="n">point</span><span class="p">.</span><span class="n">localPosition</span> <span class="p">=</span> <span class="n">Vector3</span><span class="p">.</span><span class="n">right</span> <span class="p">*</span> <span class="n">i</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<blockquote>
  <p>Почему в цикле <code class="highlighter-rouge">for</code> мы используем <code class="highlighter-rouge">i++</code> а не <code class="highlighter-rouge">++i</code>?</p>

  <p>Поскольку выражение инкремента не используется ни для чего другого, не имеет значения, какую из двух этих версий мы используем. Мы могли бы также использовать <code class="highlighter-rouge">i += 1</code> или <code class="highlighter-rouge">i = i + 1</code>.</p>

  <p>Классический цикл <code class="highlighter-rouge">for</code> имеет форму <code class="highlighter-rouge">for (int i  = 0; i &lt; someLimit; i++)</code>. Вы будете сталкиваться с подобной записью во многих других скриптах и программах.</p>
</blockquote>

<h2 id="16-Изменение-области-определения-функции"><strong>1.6 Изменение <a href="https://ru.wikipedia.org/wiki/Область_определения_функции">области определения функции</a></strong></h2>
<p>На данный момент нашим кубам даны координаты по оси X от 0 до 9. Это не удобный диапазон для работы с функциями. Чаще всего используется диапазон от 0 до 1. Или если мы работаем с функцией, которая симметрична относительно нуля то ее диапазон обычно равен <script type="math/tex">(-1, +1)</script>. Давайте расположим наши кубы в соответствующем диапазоне.</p>

<p>Расположение десятка кубов на отрезке длиной в две единицы приведет к их перекрытию. Чтобы предотвратить это надо уменьшить масштаб кубов. Каждый куб имеет размер 1 по всем осям по умолчанию. Для того чтобы сделать их подходящего размера нам нужно уменьшить их масштаб до <script type="math/tex">\frac{2}{10} = \frac{1}{5}</script>. Мы можем сделать это установив масштаб каждого куба равный <code class="highlighter-rouge">Vector3.one</code> деленный на 5 т.е. принять значение масштаба для всех осей равный <script type="math/tex">\frac{1}{5}</script></p>

<div class="language-c# highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span> <span class="p">&lt;</span> <span class="m">10</span><span class="p">;</span> <span class="n">i</span><span class="p">++)</span> 
<span class="p">{</span>
	<span class="n">Transform</span> <span class="n">point</span> <span class="p">=</span> <span class="nf">Instantiate</span><span class="p">(</span><span class="n">pointPrefab</span><span class="p">);</span>
	<span class="n">point</span><span class="p">.</span><span class="n">localPosition</span> <span class="p">=</span> <span class="n">Vector3</span><span class="p">.</span><span class="n">right</span> <span class="p">*</span> <span class="n">i</span><span class="p">;</span>
	<span class="n">point</span><span class="p">.</span><span class="n">localScale</span> <span class="p">=</span> <span class="n">Vector3</span><span class="p">.</span><span class="n">one</span> <span class="p">/</span> <span class="m">5f</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<center><img src="\images\2018\02\BuildingGraph\small-cubes.png" /></center>
<p><em><center>Маленькие кубики. </center></em></p>

<p>Чтобы снова собрать кубики вместе разделите их позицию на 5.</p>

<div class="language-c# highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">point</span><span class="p">.</span><span class="n">localPosition</span> <span class="p">=</span> <span class="n">Vector3</span><span class="p">.</span><span class="n">right</span> <span class="p">*</span> <span class="n">i</span> <span class="p">/</span> <span class="m">5f</span><span class="p">;</span>
</code></pre></div></div>

<p>Теперь наши кубики располагаются в диапазоне от <script type="math/tex">(0,2)</script>. Но нам нужен диапазон <script type="math/tex">(-1,+1)</script>, поэтому надо он нашей формулы отнять единицу.</p>

<div class="language-c# highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">point</span><span class="p">.</span><span class="n">localPosition</span> <span class="p">=</span> <span class="n">Vector3</span><span class="p">.</span><span class="n">right</span> <span class="p">*</span> <span class="p">(</span><span class="n">i</span> <span class="p">/</span> <span class="m">5f</span> <span class="err">–</span> <span class="m">1</span><span class="p">);</span>
</code></pre></div></div>

<p>Сейчас у первого куба координата по оси X равна -1, в то время как последний куб имеет координату 0.8. Однако размер куба равен 0.2. Поскольку размер куб считается его центра, то левая сторона первого куба имеет координату X равной -1.1, в то время как правая сторона этого же куба имеет координату -0.9. Чтобы правильно заполнить диапазон <script type="math/tex">(-1,+1)</script> нашими кубиками, мы должны сдвинуть их на половину куба вправо. Это можно сделать просто, добавив значение 0.5 к <code class="highlighter-rouge">i</code> перед операцией деления. Более подробнее узнать о том, как приводить какие-либо значения к нужному диапазону можно узнать из статьи на Википедии: <a href="https://en.wikipedia.org/wiki/Feature_scaling">Feature scaling</a>.</p>

<div class="language-c# highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">point</span><span class="p">.</span><span class="n">localPosition</span> <span class="p">=</span> <span class="n">Vector3</span><span class="p">.</span><span class="n">right</span> <span class="p">*</span> <span class="p">((</span><span class="n">i</span> <span class="p">+</span> <span class="m">0.5f</span><span class="p">)</span> <span class="p">/</span> <span class="m">5f</span> <span class="p">-</span> <span class="m">1f</span><span class="p">);</span>
</code></pre></div></div>

<h2 id="17-Выносим-вектора-за-пределы-цикла"><strong>1.7 Выносим вектора за пределы цикла</strong></h2>
<p>Хотя все кубы у нас имеют одинаковый масштаб, мы вычисляем его в каждой итерации цикла. С точки зрения производительности это не очень хорошо. Вместо этого мы могли бы вычислить его один раз перед циклом, сохранить его в переменной имеющей тип <code class="highlighter-rouge">Vector3</code> и использовать эту переменную внутри цикла.</p>

<div class="language-c# highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">void</span> <span class="nf">Awake</span> <span class="p">()</span> 
<span class="p">{</span>
	<span class="n">Vector3</span> <span class="n">scale</span> <span class="p">=</span> <span class="n">Vector3</span><span class="p">.</span><span class="n">one</span> <span class="p">/</span> <span class="m">5f</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span> <span class="p">&lt;</span> <span class="m">10</span><span class="p">;</span> <span class="n">i</span><span class="p">++)</span> 
	<span class="p">{</span>
		<span class="n">Transform</span> <span class="n">point</span> <span class="p">=</span> <span class="nf">Instantiate</span><span class="p">(</span><span class="n">pointPrefab</span><span class="p">);</span>
		<span class="n">point</span><span class="p">.</span><span class="n">localPosition</span> <span class="p">=</span> <span class="n">Vector3</span><span class="p">.</span><span class="n">right</span> <span class="p">*</span> <span class="p">((</span><span class="n">i</span> <span class="p">+</span> <span class="m">0.5f</span><span class="p">)</span> <span class="p">/</span> <span class="m">5f</span> <span class="p">-</span> <span class="m">1f</span><span class="p">);</span>
		<span class="n">point</span><span class="p">.</span><span class="n">localScale</span> <span class="p">=</span> <span class="n">scale</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Мы также можем определить переменную для позиции перед циклом. Поскольку мы создаем линию вдоль оси X, нам нужно изменять только координату X внутри цикла. Таким образом нам больше не нужно умножать нашу позицию на <code class="highlighter-rouge">Vector3.right</code>.</p>

<div class="language-c# highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Vector3</span> <span class="n">scale</span> <span class="p">=</span> <span class="n">Vector3</span><span class="p">.</span><span class="n">one</span> <span class="p">/</span> <span class="m">5f</span><span class="p">;</span>
<span class="n">Vector3</span> <span class="n">position</span><span class="p">;</span>
<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span> <span class="p">&lt;</span> <span class="m">10</span><span class="p">;</span> <span class="n">i</span><span class="p">++)</span> 
<span class="p">{</span>
	<span class="n">Transform</span> <span class="n">point</span> <span class="p">=</span> <span class="nf">Instantiate</span><span class="p">(</span><span class="n">pointPrefab</span><span class="p">);</span>
<span class="c1">//	point.localPosition = Vector3.right * ((i + 0.5f) / 5f - 1f);</span>
	<span class="n">position</span><span class="p">.</span><span class="n">x</span> <span class="p">=</span> <span class="p">(</span><span class="n">i</span> <span class="p">+</span> <span class="m">0.5f</span><span class="p">)</span> <span class="p">/</span> <span class="m">5f</span> <span class="p">-</span> <span class="m">1f</span><span class="p">;</span>
	<span class="n">point</span><span class="p">.</span><span class="n">localPosition</span> <span class="p">=</span> <span class="n">position</span><span class="p">;</span>
	<span class="n">point</span><span class="p">.</span><span class="n">localScale</span> <span class="p">=</span> <span class="n">scale</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<blockquote>
  <p>Можем ли мы изменить составляющие вектора так как мне нужно?</p>

  <p><code class="highlighter-rouge">Vector3</code> это структура, которая содержит в себе три поля <code class="highlighter-rouge">x</code>, <code class="highlighter-rouge">y</code> и <code class="highlighter-rouge">z</code> типа <code class="highlighter-rouge">float</code>. Эти поля публичные, значит мы можем изменить их.</p>

  <p>Идея заключается в том, чтобы структуры должны быть неизменяемыми поскольку они как правило хранят в себе простые значения. Конечные структуры не должны изменяться. Если вы хотите использовать другое значение, создайте новую структуру поле или переменную как это мы делаем с числами. Если мы скажем что <script type="math/tex">x = 3</script>, а потом <script type="math/tex">x = 5</script>, то мы присвоим переменной X другое значение. Мы не использовали 3 чтобы получить 5, мы просто заменили одно значение другим. Хоть и структуры, содержащие в себе значения векторов и можно изменить в Unity, лучше избегать этого. Создайте новую переменную типа <code class="highlighter-rouge">Vector3</code> и ей присвойте значение, взятое из структуры, а после изменяйте его как хотите. Манипуляции будут происходить только с объявленной вами переменной.</p>

  <p>Чтобы получить представление о том, как работать с изменяемыми векторами нужно рассмотреть использование <code class="highlighter-rouge">Vector3</code> в качестве удобной замены для использования трех отдельных значений <code class="highlighter-rouge">float</code>. Вы можете получить к ним доступ независимо друг от друга, скопировать любое значение или объединить их в группу.</p>
</blockquote>

<p>Код выше приведет к ошибке компиляции, жалуясь на использование неназначенной переменной. Это происходит потому что мы назначаем позицию чему-то, не установив его начальные координаты по осям Y и Z. Явно установите их, присвоив им значение нуля.</p>

<div class="language-c# highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Vector3</span> <span class="n">position</span><span class="p">;</span>
<span class="n">position</span><span class="p">.</span><span class="n">y</span> <span class="p">=</span> <span class="m">0f</span><span class="p">;</span>
<span class="n">position</span><span class="p">.</span><span class="n">z</span> <span class="p">=</span> <span class="m">0f</span><span class="p">;</span>
<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span> <span class="p">&lt;</span> <span class="m">10</span><span class="p">;</span> <span class="n">i</span><span class="p">++)</span> 
<span class="p">{</span>
	<span class="err">…</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="18-Выражаем-y-через-x"><strong>1.8 Выражаем Y через X</strong></h2>
<p>Идея заключается в том, что позиции наших кубов можно выразить как <script type="math/tex">\left[\begin{array}{c}x\\f(x)\\0\end{array}\right]</script> для отображения нашей функции. В настоящий момент координата Y равна нулю, что представляет собой тривиальную функцию <script type="math/tex">f(x) = 0</script>. Чтобы наш график начал отображать хоть какую-либо зависимость мы должны изменить нашу функцию на <script type="math/tex">f(x) = x</script> для начала. Для этого нужно присваивать координате Y значение внутри цикла, а не перед ним.</p>

<div class="language-c# highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Vector3</span> <span class="n">position</span><span class="p">;</span>
<span class="c1">//position.y = 0f;</span>
<span class="n">position</span><span class="p">.</span><span class="n">z</span> <span class="p">=</span> <span class="m">0f</span><span class="p">;</span>
<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span> <span class="p">&lt;</span> <span class="m">10</span><span class="p">;</span> <span class="n">i</span><span class="p">++)</span> 
<span class="p">{</span>
	<span class="n">Transform</span> <span class="n">point</span> <span class="p">=</span> <span class="nf">Instantiate</span><span class="p">(</span><span class="n">pointPrefab</span><span class="p">);</span>
	<span class="n">position</span><span class="p">.</span><span class="n">x</span> <span class="p">=</span> <span class="p">(</span><span class="n">i</span> <span class="p">+</span> <span class="m">0.5f</span><span class="p">)</span> <span class="p">/</span> <span class="m">5f</span> <span class="p">-</span> <span class="m">1f</span><span class="p">;</span>
	<span class="n">position</span><span class="p">.</span><span class="n">y</span> <span class="p">=</span> <span class="n">position</span><span class="p">.</span><span class="n">x</span><span class="p">;</span>
	<span class="n">point</span><span class="p">.</span><span class="n">localPosition</span> <span class="p">=</span> <span class="n">position</span><span class="p">;</span>
	<span class="n">point</span><span class="p">.</span><span class="n">localScale</span> <span class="p">=</span> <span class="n">scale</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>
<center><img src="\images\2018\02\BuildingGraph\y-equals-x.png" /></center>
<p><em><center>Y равен X. </center></em></p>

<p>Не много менее очевидная функция <script type="math/tex">f(x) = x^2</script>, которая определяет <a href="https://ru.wikipedia.org/wiki/Парабола">параболу</a> с вершиной в нуле.</p>
<div class="language-c# highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">position</span><span class="p">.</span><span class="n">y</span> <span class="p">=</span> <span class="n">position</span><span class="p">.</span><span class="n">x</span> <span class="p">*</span> <span class="n">position</span><span class="p">.</span><span class="n">x</span><span class="p">;</span>
</code></pre></div></div>

<center><img src="\images\2018\02\BuildingGraph\y-equals-x-squared.png" /></center>
<p><em><center>Y равен X в квадрате. </center></em>
<a href="\content\2018\02\BuildingGraph\creating-a-line-of-cubes.unitypackage">1. unitypackage</a></p>

<h2 id="2-Создаем-больше-кубов"><strong>2. Создаем больше кубов.</strong></h2>
<p>Хотя на данный момент у нас есть готовый график, но на данный момент он уродлив. Потому что мы используем только десять кубов, предложенная линия выглядит очень блочной и разрозненной. Было бы лучше, если бы мы использовали больше кубиков меньшего размера.</p>

<h2 id="21--Различные-разрешения"><strong>2.1.  Различные разрешения.</strong></h2>
<p>Вместо того, чтобы использовать фиксированное количество кубов, мы можем сделать его настраиваемым. Чтобы сделать это возможным, добавьте публичное целое поле, которое будет хранить в себе разрешение <code class="highlighter-rouge">Graph</code> (разрешение в данном контексте подразумевает количество кубов, которое будет использоваться для отображения графика. Как монитор компьютера, чем больше разрешение, тем точнее картинка. Так же и тут чем выше разрешение, тем точнее график). Дайте ему значение по умолчанию 10, которое мы используем сейчас.</p>

<div class="language-c# highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">public</span> <span class="kt">int</span> <span class="n">resolution</span> <span class="p">=</span> <span class="m">10</span><span class="p">;</span>
</code></pre></div></div>

<center><img src="\images\2018\02\BuildingGraph\resolution-number.png" /></center>
<p><em><center>Поле Resolution </center></em></p>

<p>Идея заключается в том, что мы можем изменить разрешение графа, изменив это значение с помощью созданного нами поля в инспекторе. Однако не все целые числа являются допустимыми. Как минимум, числа должны быть положительными. Мы можем поручить инспектору обеспечить соблюдение попадания в определенный диапазон для нашего поля. Это делается путем записи Range в квадратные скобки перед определением поля.</p>

<div class="language-c# highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">[Range]</span> <span class="k">public</span> <span class="kt">int</span> <span class="n">resolution</span> <span class="p">=</span> <span class="m">10</span><span class="p">;</span>
</code></pre></div></div>

<p><code class="highlighter-rouge">Range</code> -Тип атрибута, определяемый <em>Unity</em>. Атрибут-это способ присоединения метаданных к структурам кода, в данном случае к полю. Инспектор Unity проверяет, есть ли у поля добавленный атрибут <code class="highlighter-rouge">Range</code>. Если это так, он будет использовать ползунок вместо поля ввода по умолчанию для чисел. Однако для этого необходимо знать допустимый диапазон. Так <code class="highlighter-rouge">Range</code> имеет два параметра, для минимального и максимального значения. Давайте используем 10 и 100. Кроме того, атрибуты обычно записываются выше объявляемого поля или метода, а не перед ними.</p>

<div class="language-c# highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">[Range(10, 100)]</span>
<span class="k">public</span> <span class="kt">int</span> <span class="n">resolution</span> <span class="p">=</span> <span class="m">10</span><span class="p">;</span>
</code></pre></div></div>

<center><img src="\images\2018\02\BuildingGraph\resolution-slider.png" /></center>
<p><em><center>Поле Resolution со слайдером</center></em></p>

<blockquote>
  <p>Гарантирует ли это, что разрешение будет ограничено 10-100?</p>

  <p>Нет, что что делает атрибут <code class="highlighter-rouge">Range</code> это настраивает ползунок в инспекторе. Это в целом никак вообще не влияет на то какие значения будет принимать эта переменная. Мы можем в любом месте кода спокойно изменить значение этого поля на любое целое число, котором нам нравится. Но в нашем случае мы предполагаем, что значение регулируется только с помощью инспектора и нигде больше.</p>
</blockquote>

<h2 id="22-Создание-различных-экземпляров"><strong>2.2 Создание различных экземпляров.</strong></h2>
<p>Для того чтобы использовать разрешение, мы должны изменить количество кубов, которое мы создаем. Вместо использования циклов фиксированное количество раз в awake, количество итераций теперь ограничено разрешением. Теперь если разрешение установлено 50, мы создадим 50 кубов после входа в игровой режим.</p>

<div class="language-c# highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span> <span class="p">&lt;</span> <span class="n">resolution</span><span class="p">;</span> <span class="n">i</span><span class="p">++)</span> 
<span class="p">{</span>
	<span class="err">…</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Мы также должны отрегулировать масштаб и положение кубов чтобы оставить их в позиции <script type="math/tex">-1 -1</script>. Размер каждого шага, который мы будем делать каждую итерацию сейчас равен <script type="math/tex">\frac{2}{resolution}</script> вместо обычного <script type="math/tex">\frac{1}{5}</script>. Сохраните это значение в переменной и используйте его для вычисления масштаба кубов и их координат по оси X.</p>

<div class="language-c# highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">void</span> <span class="nf">Awake</span> <span class="p">()</span> 
<span class="p">{</span>
	<span class="kt">float</span> <span class="n">step</span> <span class="p">=</span> <span class="m">2f</span> <span class="p">/</span> <span class="n">resolution</span><span class="p">;</span>
	<span class="n">Vector3</span> <span class="n">scale</span> <span class="p">=</span> <span class="n">Vector3</span><span class="p">.</span><span class="n">one</span> <span class="p">*</span> <span class="n">step</span><span class="p">;</span>
	<span class="n">Vector3</span> <span class="n">position</span><span class="p">;</span>
	<span class="n">position</span><span class="p">.</span><span class="n">z</span> <span class="p">=</span> <span class="m">0f</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span> <span class="p">&lt;</span> <span class="n">resolution</span><span class="p">;</span> <span class="n">i</span><span class="p">++)</span> 
	<span class="p">{</span>
		<span class="n">Transform</span> <span class="n">point</span> <span class="p">=</span> <span class="nf">Instantiate</span><span class="p">(</span><span class="n">pointPrefab</span><span class="p">);</span>
		<span class="n">position</span><span class="p">.</span><span class="n">x</span> <span class="p">=</span> <span class="p">(</span><span class="n">i</span> <span class="p">+</span> <span class="m">0.5f</span><span class="p">)</span> <span class="p">*</span> <span class="n">step</span> <span class="p">-</span> <span class="m">1f</span><span class="p">;</span>
		<span class="n">position</span><span class="p">.</span><span class="n">y</span> <span class="p">=</span> <span class="n">position</span><span class="p">.</span><span class="n">x</span> <span class="p">*</span> <span class="n">position</span><span class="p">.</span><span class="n">x</span><span class="p">;</span>
		<span class="n">point</span><span class="p">.</span><span class="n">localPosition</span> <span class="p">=</span> <span class="n">position</span><span class="p">;</span>
		<span class="n">point</span><span class="p">.</span><span class="n">localScale</span> <span class="p">=</span> <span class="n">scale</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<center><img src="\images\2018\02\BuildingGraph\resolution-50.png" /></center>
<p><em><center>График со значением Resolution равным 50</center></em></p>

<h2 id="23-Устанавливаем-родителя"><strong>2.3. Устанавливаем родителя</strong></h2>
<p>После открытия режима с разрешением в 50, множество созданных кубов окажутся на сцене.</p>

<center><img src="\images\2018\02\BuildingGraph\many-root-objects.png" /></center>
<p><em><center>Все точки графика являются корневыми. </center></em></p>

<p>Эти Кубы в настоящее время являются корневыми объектами, хотя по сути они должны являться потомками объекта <em>Graph</em>. Мы можем установить эту связь после создания экземпляра куба, вызвав метод <code class="highlighter-rouge">SetParent</code> из компонента куба <code class="highlighter-rouge">Transform</code>. В качестве аргумента мы должны предоставить компонент <code class="highlighter-rouge">Transform</code> объекта, который будет для наших кубов родителем. Мы можем напрямую получить доступ к компоненту <code class="highlighter-rouge">Transform</code> объекта <em>Graph</em> через его свойство <code class="highlighter-rouge">transform</code>.</p>

<div class="language-c# highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span> <span class="p">&lt;</span> <span class="n">resolution</span><span class="p">;</span> <span class="n">i</span><span class="p">++)</span> 
<span class="p">{</span>
	<span class="n">Transform</span> <span class="n">point</span> <span class="p">=</span> <span class="nf">Instantiate</span><span class="p">(</span><span class="n">pointPrefab</span><span class="p">);</span>
	<span class="n">position</span><span class="p">.</span><span class="n">x</span> <span class="p">=</span> <span class="p">(</span><span class="n">i</span> <span class="p">+</span> <span class="m">0.5f</span><span class="p">)</span> <span class="p">*</span> <span class="n">step</span> <span class="p">-</span> <span class="m">1f</span><span class="p">;</span>
	<span class="n">position</span><span class="p">.</span><span class="n">y</span> <span class="p">=</span> <span class="n">position</span><span class="p">.</span><span class="n">x</span> <span class="p">*</span> <span class="n">position</span><span class="p">.</span><span class="n">x</span><span class="p">;</span>
	<span class="n">point</span><span class="p">.</span><span class="n">localPosition</span> <span class="p">=</span> <span class="n">position</span><span class="p">;</span>
	<span class="n">point</span><span class="p">.</span><span class="n">localScale</span> <span class="p">=</span> <span class="n">scale</span><span class="p">;</span>
	<span class="n">point</span><span class="p">.</span><span class="nf">SetParent</span><span class="p">(</span><span class="n">transform</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<center><img src="\images\2018\02\BuildingGraph\child-objects.png" /></center>
<p><em><center>Все точки графика стали дочерними к объекту Graph. </center></em></p>

<p>Когда новый родитель установлен, Unity попытается сохранить объект в исходном положении, вращении и масштабе. В нашем случае, нам это не нужно. Мы можем указать это, подставляя <code class="highlighter-rouge">false</code> в качестве второго аргумента <code class="highlighter-rouge">SetParent</code>.</p>

<p><a href="\content\2018\02\BuildingGraph\creating-more-cubes.unitypackage">2. unitypackage</a></p>

<h2 id="3-Раскрасим-график"><strong>3. Раскрасим график</strong></h2>
<p>Белый график выглядит не очень презентабельно. МЫ могли бы использовать другой сплошной цвет, но это тоже не очень интересно. Что мы можем сделать, так это использовать позицию точки для определения ее цвета.</p>

<p>Простой способ настройки цвета каждого куба можно сделать через свойство цвета материала куба. Мы можем сделать это в цикле. Поскольку каждый куб будет иметь свой цвет, это означает, что мы будем иметь один уникальный материал для каждого объекта. Хоть данная идея и реализуема, она не очень эффективна. Было бы на много проще, если бы могли использовать один материал, который изменял бы свой цвет в зависимости от своего положения в пространстве. К сожалению, в Unity нет такого материала. Так что давайте сами его создадим.</p>

<h2 id="31-Создание-собственного-шейдера"><strong>3.1 Создание собственного шейдера.</strong></h2>
<p>GPU (graphic processing unit) или графический процессор отвечает за рендер (отображение) 3D-объектов. Материалы в Unity определяются при помощи шейдеров, который позволяют настраивать его свойства. Нам нужно создать пользовательский шейдер для получения нужной функциональности. Создайте таковой через : <em>Assets / Create / Shader / Standard Surface Shader</em> и дайте ему имя <em>ColoredPoint</em>.</p>

<center><img src="\images\2018\02\BuildingGraph\custom-shader-asset.png" /></center>
<p><em><center>Пользовательский шейдер </center></em></p>

<p>Теперь у нас есть файл c расширением shader, который мы можем открыть как обычный скрипт с синтаксисом отличным от языка C#. Наш файл шейдера содержит код для определения качеств, которые присущи нашему материалу. Ниже представлено содержимое файла, которое генерируется Unity. Все строки с комментариями удалены для краткости.</p>

<div class="language-c# highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Shader</span> <span class="s">"Custom/ColoredPoint"</span> <span class="p">{</span>
	<span class="n">Properties</span> <span class="p">{</span>
		<span class="nf">_Color</span> <span class="p">(</span><span class="s">"Color"</span><span class="p">,</span> <span class="n">Color</span><span class="p">)</span> <span class="p">=</span> <span class="p">(</span><span class="m">1</span><span class="p">,</span><span class="m">1</span><span class="p">,</span><span class="m">1</span><span class="p">,</span><span class="m">1</span><span class="p">)</span>
		<span class="nf">_MainTex</span> <span class="p">(</span><span class="s">"Albedo (RGB)"</span><span class="p">,</span> <span class="m">2D</span><span class="p">)</span> <span class="p">=</span> <span class="s">"white"</span> <span class="p">{}</span>
		<span class="nf">_Glossiness</span> <span class="p">(</span><span class="s">"Smoothness"</span><span class="p">,</span> <span class="nf">Range</span><span class="p">(</span><span class="m">0</span><span class="p">,</span><span class="m">1</span><span class="p">))</span> <span class="p">=</span> <span class="m">0.5</span>
		<span class="nf">_Metallic</span> <span class="p">(</span><span class="s">"Metallic"</span><span class="p">,</span> <span class="nf">Range</span><span class="p">(</span><span class="m">0</span><span class="p">,</span><span class="m">1</span><span class="p">))</span> <span class="p">=</span> <span class="m">0.0</span>
	<span class="p">}</span>
	<span class="n">SubShader</span> <span class="p">{</span>
		<span class="n">Tags</span> <span class="p">{</span> <span class="s">"RenderType"</span><span class="p">=</span><span class="s">"Opaque"</span> <span class="p">}</span>
		<span class="n">LOD</span> <span class="m">200</span>
		
		<span class="n">CGPROGRAM</span>
		<span class="err">#</span><span class="n">pragma</span> <span class="n">surface</span> <span class="n">surf</span> <span class="n">Standard</span> <span class="n">fullforwardshadows</span>

		<span class="err">#</span><span class="n">pragma</span> <span class="n">target</span> <span class="m">3.0</span>

		<span class="n">sampler2D</span> <span class="n">_MainTex</span><span class="p">;</span>

		<span class="k">struct</span> <span class="nc">Input</span> <span class="p">{</span>
			<span class="n">float2</span> <span class="n">uv_MainTex</span><span class="p">;</span>
		<span class="p">};</span>

		<span class="n">half</span> <span class="n">_Glossiness</span><span class="p">;</span>
		<span class="n">half</span> <span class="n">_Metallic</span><span class="p">;</span>
		<span class="n">fixed4</span> <span class="n">_Color</span><span class="p">;</span>

		<span class="nf">UNITY_INSTANCING_CBUFFER_START</span><span class="p">(</span><span class="n">Props</span><span class="p">)</span>
		<span class="n">UNITY_INSTANCING_CBUFFER_END</span>

		<span class="k">void</span> <span class="nf">surf</span> <span class="p">(</span><span class="n">Input</span> <span class="n">IN</span><span class="p">,</span> <span class="n">inout</span> <span class="n">SurfaceOutputStandard</span> <span class="n">o</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">fixed4</span> <span class="n">c</span> <span class="p">=</span> <span class="nf">tex2D</span> <span class="p">(</span><span class="n">_MainTex</span><span class="p">,</span> <span class="n">IN</span><span class="p">.</span><span class="n">uv_MainTex</span><span class="p">)</span> <span class="p">*</span> <span class="n">_Color</span><span class="p">;</span>
			<span class="n">o</span><span class="p">.</span><span class="n">Albedo</span> <span class="p">=</span> <span class="n">c</span><span class="p">.</span><span class="n">rgb</span><span class="p">;</span>
			<span class="n">o</span><span class="p">.</span><span class="n">Metallic</span> <span class="p">=</span> <span class="n">_Metallic</span><span class="p">;</span>
			<span class="n">o</span><span class="p">.</span><span class="n">Smoothness</span> <span class="p">=</span> <span class="n">_Glossiness</span><span class="p">;</span>
			<span class="n">o</span><span class="p">.</span><span class="n">Alpha</span> <span class="p">=</span> <span class="n">c</span><span class="p">.</span><span class="n">a</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">ENDCG</span>
	<span class="p">}</span>
	<span class="n">FallBack</span> <span class="s">"Diffuse"</span>
<span class="p">}</span>
</code></pre></div></div>

<blockquote>
  <p>Как работает поверхностный шейдер?</p>

  <p>Написание шейдеров, взаимодействующих с освещением, это сложная задача. Есть различные типы источников света, различные варианты теней, различные пути рендеринга - прямой (forward) и отложенный (deferred), и шейдер должен как-то управлять всей этой сложностью. Шейдеры поверхности в Unity – это подход к созданию кода, который упрощает написание. Если вы хотите узнать больше о шейдерах, вы можете ознакомиться с серией туторов по <a href="http://catlikecoding.com/unity/tutorials/rendering/part-1/">Рендерингу</a> (пока не переведено)</p>
</blockquote>

<p>Наш новый шейдер имеет: сплошной цвет, текстуру, а также глянцевую и металлическую поверхности. Поскольку мы будем определять цвет по позиции точки графика в пространстве, нам не понадобится ни сплошной цвет, ни текстура. В приведенном ниже коде все ненужные строки закомментированы. Оставим только альбедо со значением сплошного черного цвета и альфа-канал равный единице.</p>

<div class="language-c# highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Shader</span> <span class="s">"Custom/ColoredPoint"</span> <span class="p">{</span>
	<span class="n">Properties</span> <span class="p">{</span>
<span class="c1">//		_Color ("Color", Color) = (1,1,1,1)</span>
<span class="c1">//		_MainTex ("Albedo (RGB)", 2D) = "white" {}</span>
		<span class="nf">_Glossiness</span> <span class="p">(</span><span class="s">"Smoothness"</span><span class="p">,</span> <span class="nf">Range</span><span class="p">(</span><span class="m">0</span><span class="p">,</span><span class="m">1</span><span class="p">))</span> <span class="p">=</span> <span class="m">0.5</span>
		<span class="nf">_Metallic</span> <span class="p">(</span><span class="s">"Metallic"</span><span class="p">,</span> <span class="nf">Range</span><span class="p">(</span><span class="m">0</span><span class="p">,</span><span class="m">1</span><span class="p">))</span> <span class="p">=</span> <span class="m">0.0</span>
	<span class="p">}</span>
	<span class="n">SubShader</span> <span class="p">{</span>
		<span class="n">Tags</span> <span class="p">{</span> <span class="s">"RenderType"</span><span class="p">=</span><span class="s">"Opaque"</span> <span class="p">}</span>
		<span class="n">LOD</span> <span class="m">200</span>
		
		<span class="n">CGPROGRAM</span>
		<span class="err">#</span><span class="n">pragma</span> <span class="n">surface</span> <span class="n">surf</span> <span class="n">Standard</span> <span class="n">fullforwardshadows</span>

		<span class="err">#</span><span class="n">pragma</span> <span class="n">target</span> <span class="m">3.0</span>

<span class="c1">//		sampler2D _MainTex;</span>

		<span class="k">struct</span> <span class="nc">Input</span> <span class="p">{</span>
<span class="c1">//			float2 uv_MainTex;</span>
		<span class="p">};</span>

		<span class="n">half</span> <span class="n">_Glossiness</span><span class="p">;</span>
		<span class="n">half</span> <span class="n">_Metallic</span><span class="p">;</span>
<span class="c1">//		fixed4 _Color;</span>

		<span class="nf">UNITY_INSTANCING_CBUFFER_START</span><span class="p">(</span><span class="n">Props</span><span class="p">)</span>
		<span class="n">UNITY_INSTANCING_CBUFFER_END</span>

		<span class="k">void</span> <span class="nf">surf</span> <span class="p">(</span><span class="n">Input</span> <span class="n">IN</span><span class="p">,</span> <span class="n">inout</span> <span class="n">SurfaceOutputStandard</span> <span class="n">o</span><span class="p">)</span> <span class="p">{</span>
<span class="c1">//			fixed4 c = tex2D (_MainTex, IN.uv_MainTex) * _Color;</span>
<span class="c1">//			o.Albedo = c.rgb;</span>
			<span class="n">o</span><span class="p">.</span><span class="n">Metallic</span> <span class="p">=</span> <span class="n">_Metallic</span><span class="p">;</span>
			<span class="n">o</span><span class="p">.</span><span class="n">Smoothness</span> <span class="p">=</span> <span class="n">_Glossiness</span><span class="p">;</span>
<span class="c1">//			o.Alpha = c.a;</span>
			<span class="n">o</span><span class="p">.</span><span class="n">Alpha</span> <span class="p">=</span> <span class="m">1</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">ENDCG</span>
	<span class="p">}</span>
	<span class="n">FallBack</span> <span class="s">"Diffuse"</span>
<span class="p">}</span>
</code></pre></div></div>

<blockquote>
  <p>Что такое альбедо и альфа-канал?</p>

  <p>Цвет диффузного отражения материала называется альбедо. В нем описывается сколько каналов красного, зеленого и синего отражено диффузно. Остальное поглощается.</p>

  <p>Альфа-канал используется как мера непрозрачности. При альфа-канале равным нулю поверхность полностью прозрачная, в то время как при альфа-канале равным единице она полностью непрозрачна.</p>
</blockquote>

<p>На этом этапе шейдер не скомпилируется, поскольку поверхностные шейдеры не могут работать с пустой входной структурой. В ней мы определяем, какие пользовательские данные необходимы для окрашивания пикселей. В нашем случае, нам нужна позиция точки. Мы можем получить доступ к позиции объекта в глобальной системе координат, добавив <code class="highlighter-rouge">float3 worldPos;</code> в структуру <code class="highlighter-rouge">Input</code>.</p>

<div class="language-c# highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="nc">Input</span> <span class="p">{</span>
	<span class="n">float3</span> <span class="n">worldPos</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div></div>

<blockquote>
  <p>Говорит ли это о том, что перемещение объекта Graph повлияет на его цвет?</p>

  <p>Да. При таком подходе окраска будет правильно только до тех пор, пока <code class="highlighter-rouge">Graph</code> находится в начале координат.</p>

  <p>Также обратите внимание, что эта позиция определяется для каждой вершины. В нашем случае для каждого угла куба. Цвет будет интерполирован по его граням. Чем больше кубики, тем более очевидным будет цветовой переход.</p>
</blockquote>

<p>Теперь, когда у нас есть функционирующий шейдер, создайте для него материал с именем <em>Colored Point</em>. Перетяните шейдер на материал или выберите в выпадающем меню <em>Custom / Colored Point</em>.</p>

<center><img src="\images\2018\02\BuildingGraph\colored-point-material.png" /></center>
<p><em><center>Материал для раскраски точек. </center></em></p>

<p>Пусть префаб нашего куба использует этот материал вместо материала по умолчанию. Это можно сделать просто перетащим наш материала на префаб.</p>

<h2 id="32-Изменение-цвета-основанное-на-изменении-глобальных-координат"><strong>3.2 Изменение цвета, основанное на изменении глобальных координат</strong></h2>
<p>Если мы нажмем кнопку воспроизведения, то наш график будет создать экземпляры черных кубов. Чтобы изменить их цвет, мы должны изменить переменную <code class="highlighter-rouge">o.Albedo</code>. Вместо того чтобы присваивать ему ноль, присвойте свойству отвечающего за красный цвет значение координаты X.</p>

<div class="language-c# highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//	o.Albedo = 0;</span>
	<span class="n">o</span><span class="p">.</span><span class="n">Albedo</span><span class="p">.</span><span class="n">r</span> <span class="p">=</span> <span class="n">IN</span><span class="p">.</span><span class="n">worldPos</span><span class="p">.</span><span class="n">x</span><span class="p">;</span>
</code></pre></div></div>

<center><img src="\images\2018\02\BuildingGraph\colored-graph-x.png" /></center>
<p><em><center>График, цвет которого регулируется координатой X. </center></em></p>

<blockquote>
  <p>Разве мы не должны инициализировать <code class="highlighter-rouge">o.Albedo</code>?</p>

  <p>Нам не нужно устанавливать значения для свойств отвечающие за зеленый и синий цвет, потому что они им уже было установлено значение нуля перед тем как был вызван метод <code class="highlighter-rouge">surf</code></p>
</blockquote>

<p>Кубы имеющие положительное значение координаты по оси X постепенно становятся красными. А вот кубы имеющие отрицательные значения по оси X остаются черными, потому что цвета не могут быть отрицательными. Чтобы получить более плавный переход в красный цвет, необходимо в двое сократить координаты X и прибавить 0.5.</p>

<div class="language-c# highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">o</span><span class="p">.</span><span class="n">Albedo</span><span class="p">.</span><span class="n">r</span> <span class="p">=</span> <span class="n">IN</span><span class="p">.</span><span class="n">worldPos</span><span class="p">.</span><span class="n">x</span> <span class="p">*</span> <span class="m">0.5</span> <span class="p">+</span> <span class="m">0.5</span><span class="p">;</span>
</code></pre></div></div>

<center><img src="\images\2018\02\BuildingGraph\colored-graph-x-normalized.png" /></center>
<p><em><center>Плавный переход </center></em></p>

<p>Давайте также использовать координату по оси Y для регулирования свойства отвечающего за зеленый цвет. В файле шейдера это можно сделать одним простым движением, заменив <code class="highlighter-rouge">o.Albedo.r</code> на <code class="highlighter-rouge">o.Albedo.rg</code> и <code class="highlighter-rouge">IN.worldPos.x</code> на <code class="highlighter-rouge">IN.worldPos.xy</code>.</p>

<div class="language-c# highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">o</span><span class="p">.</span><span class="n">Albedo</span><span class="p">.</span><span class="n">rg</span> <span class="p">=</span> <span class="n">IN</span><span class="p">.</span><span class="n">worldPos</span><span class="p">.</span><span class="n">xy</span> <span class="p">*</span> <span class="m">0.5</span> <span class="p">+</span> <span class="m">0.5</span><span class="p">;</span>
</code></pre></div></div>

<center><img src="\images\2018\02\BuildingGraph\colored-graph-xy.png" /></center>
<p><em><center>Изменение цвета в зависимости от положения по осям X и Y</center></em></p>

<p>Красный плюс зеленый равен желтому, поэтому наш график плавно переходит от светло-зеленого к желтому цвету. Поскольку график по оси Y начинает отображаться с позиции равной -1, то в этом положении он имеет темно-зеленый цвет. Чтобы проверить мое утверждение измените нашу функцию с квадратичной параболы на кубическую. Формула кубической параболы выглядит так: <script type="math/tex">f(x) = x^3</script>.</p>

<div class="language-c# highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">position</span><span class="p">.</span><span class="n">y</span> <span class="p">=</span> <span class="n">position</span><span class="p">.</span><span class="n">x</span> <span class="p">*</span> <span class="n">position</span><span class="p">.</span><span class="n">x</span> <span class="p">*</span> <span class="n">position</span><span class="p">.</span><span class="n">x</span><span class="p">;</span>
</code></pre></div></div>

<center><img src="\images\2018\02\BuildingGraph\x-cubed.png" /></center>
<p><em><center>Кубическая парабола лежащая в диапазоне (-1,+1)</center></em></p>

<p><a href="\content\2018\02\BuildingGraph\coloring-the-graph.unitypackage">3. unitypackage</a></p>

<h2 id="4-Анимируем-график"><strong>4. Анимируем график</strong></h2>
<p>Отображение графика в статическом положении безусловно полезно, но движущийся график более интересен для просмотра. Поэтому давайте добавим поддержку анимации для функций. Это делается путем добавления времени в качестве дополнительного параметра функции. Таким образом наша функция изменится с <script type="math/tex">f(x)</script> на <script type="math/tex">f(x,t)</script>.</p>

<h2 id="41-Отслеживание-точек"><strong>4.1 Отслеживание точек</strong></h2>
<p>Чтобы заставить наш график двигаться, нам придется корректировать положения его точек в данный момент времени. Первое что приходит в голову это каждый раз удалять все точки и заново создавать, но уже в новой позиции. Отличная идея, но неэффективная. Гораздо лучше использовать уже созданные нами точки, просто корректируя их положение в зависимости от параметра времени. Сделать это проще всего можно путем добавления поля, которое будет содержать в себе ссылки на все наши точки. Создадим поле <code class="highlighter-rouge">points</code> в скрипте <code class="highlighter-rouge">Graph</code> типа <code class="highlighter-rouge">Transform</code>.</p>

<div class="language-c# highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Transform</span> <span class="n">points</span><span class="p">;</span>
</code></pre></div></div>

<p>Созданное только что поле позволяет нам ссылаться на одну точку, но нам нужна не одна, а множество точек. В языке C# и во многих других языках уже существует готовая конструкция, позволяющая хранить в себе множество значений одного типа и называется она – массив. Для того чтобы превратить нашу обычную переменную в массив необходимо всего лишь добавить пару квадратных скобок после объявления типа переменной. Читаться такая конструкция будет как: «Создадим поле с именем <code class="highlighter-rouge">points</code>, которое будет содержать в себе массив значений типа <code class="highlighter-rouge">Transform</code>».</p>

<div class="language-c# highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Transform</span><span class="p">[]</span> <span class="n">points</span><span class="p">;</span>
</code></pre></div></div>

<p>Массив – это ссылочный тип данных, а не тип значений, потому при объявлении переменной мы обязаны передать ссылку на экземпляр данного массива, либо же объявить новый используя ключевое слово <code class="highlighter-rouge">new</code>, далее указывается тип создаваемого экземпляра, который соответствует типу переменной, которой мы пытаемся присвоить значение <code class="highlighter-rouge">Transform[]</code>. Мы ведь не хотим создавать массив при каждой итерации цикла, потому объявление сделаем перед циклом <code class="highlighter-rouge">for</code>.</p>
<div class="language-c# highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">points</span> <span class="p">=</span> <span class="k">new</span> <span class="n">Transform</span><span class="p">[];</span>
<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span> <span class="p">&lt;</span> <span class="n">resolution</span><span class="p">;</span> <span class="n">i</span><span class="p">++)</span> 
<span class="p">{</span>
	<span class="err">…</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Необходимо помнить одну очень важную особенность всех массивов: они создаются фиксированной длины. Размерность массива определяет сколько элементов может в нем храниться. Если нам нужно будет увеличить размерность массива, то нужно будет создавать новый экземпляр с нужной нам длиной. Размерность массива указывается внутри квадратных скобок при объявлении. В нашем случае его длина равна разрешению (<code class="highlighter-rouge">resolution</code>).</p>

<div class="language-c# highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">points</span> <span class="p">=</span> <span class="k">new</span> <span class="n">Transform</span><span class="p">[</span><span class="n">resolution</span><span class="p">];</span>
</code></pre></div></div>

<p>Теперь, наконец-то, мы можем заполнить наш массив ссылками на наши точки. Доступ к элементам массива можно получить путем указания нужного индекса в квадратных скобках после переменной. Нумерация элементов массива начинается с нуля, так же, как и наш цикл. Таким образом, мы можем использовать итератор цикла для доступа к нужному нам элементу массива.</p>

<div class="language-c# highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">points</span> <span class="p">=</span> <span class="k">new</span> <span class="n">Transform</span><span class="p">[</span><span class="n">resolution</span><span class="p">];</span>
<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span> <span class="p">&lt;</span> <span class="n">resolution</span><span class="p">;</span> <span class="n">i</span><span class="p">++)</span> 
<span class="p">{</span>
	<span class="err">…</span>
	<span class="n">points</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="p">=</span> <span class="n">point</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="42-Перенос-логики-в-метод-update"><strong>4.2 Перенос логики в метод Update.</strong></h2>
<p>Нельзя заставить двигаться график, прописав его создание в методе, который вызывается всего 1 раз. Чтобы у нас получилась красивая анимация нам нужно перенести часть логики в метод <code class="highlighter-rouge">Update</code>. В результате нем не нужно будет вычислять положение точек в месте их создания. Однако инициализацию некоторых переменных, чье значение должно быть нулевым на момент их изменения мы сотавим в блоке <code class="highlighter-rouge">Awake</code>. Код ниже отображает изменения в методе <code class="highlighter-rouge">Awake</code>.</p>

<div class="language-c# highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">position</span><span class="p">.</span><span class="n">y</span> <span class="p">=</span> <span class="m">0f</span><span class="p">;</span>
<span class="n">position</span><span class="p">.</span><span class="n">z</span> <span class="p">=</span> <span class="m">0f</span><span class="p">;</span>
<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span> <span class="p">&lt;</span> <span class="n">resolution</span><span class="p">;</span> <span class="n">i</span><span class="p">++)</span> 
<span class="p">{</span>
	<span class="n">Transform</span> <span class="n">point</span> <span class="p">=</span> <span class="nf">Instantiate</span><span class="p">(</span><span class="n">pointPrefab</span><span class="p">);</span>
	<span class="n">position</span><span class="p">.</span><span class="n">x</span> <span class="p">=</span> <span class="p">(</span><span class="n">i</span> <span class="p">+</span> <span class="m">0.5f</span><span class="p">)</span> <span class="p">*</span> <span class="n">step</span> <span class="p">-</span> <span class="m">1f</span><span class="p">;</span>
<span class="c1">//	position.y = position.x * position.x * position.x;</span>
	<span class="n">point</span><span class="p">.</span><span class="n">localPosition</span> <span class="p">=</span> <span class="n">position</span><span class="p">;</span>
	<span class="n">point</span><span class="p">.</span><span class="n">localScale</span> <span class="p">=</span> <span class="n">scale</span><span class="p">;</span>
	<span class="n">point</span><span class="p">.</span><span class="nf">SetParent</span><span class="p">(</span><span class="n">transform</span><span class="p">,</span> <span class="k">false</span><span class="p">);</span>
	<span class="n">points</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="p">=</span> <span class="n">point</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Добавьте пустой цикл <code class="highlighter-rouge">for</code> в метод <code class="highlighter-rouge">Update</code></p>

<div class="language-c# highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">void</span> <span class="nf">Update</span> <span class="p">()</span> 
<span class="p">{</span>
	<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span> <span class="p">&lt;</span> <span class="n">resolution</span><span class="p">;</span> <span class="n">i</span><span class="p">++)</span> <span class="p">{}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Теперь проговорим что нам нужно. Нам нужно пройтись по нашему массиву точек и установить каждой точке координаты по оси Y. Поскольку длина массива совпадает с <code class="highlighter-rouge">resolution</code>, мы можем использовать эту переменную для граничного значения счетчика массива. Но мало ли что может произойти с нашим массивом, вдруг приедет хипстер на голубом самокате и изменит размерность массива? В реальности, конечно, такое маловероятно, но давайте просто воспользуемся встроенным C# свойством <code class="highlighter-rouge">Length</code>, которое хранит в себе длину нашего массива.</p>

<div class="language-c# highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span> <span class="p">&lt;</span> <span class="n">points</span><span class="p">.</span><span class="n">Length</span><span class="p">;</span> <span class="n">i</span><span class="p">++)</span> <span class="p">{}</span>
</code></pre></div></div>

<p>Мы проходим по всем элементам массива, получая текущую позицию для каждой точки. Далее получаем нужное нам значение, отвечающее за позицию в локальной системе координат.</p>

<div class="language-c# highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span> <span class="p">&lt;</span> <span class="n">points</span><span class="p">.</span><span class="n">Length</span><span class="p">;</span> <span class="n">i</span><span class="p">++)</span> 
<span class="p">{</span>
	<span class="n">Transform</span> <span class="n">point</span> <span class="p">=</span> <span class="n">points</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
	<span class="n">Vector3</span> <span class="n">position</span> <span class="p">=</span> <span class="n">point</span><span class="p">.</span><span class="n">localPosition</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Далее получим значение для текущей точки в соответствии с нашей формулой <script type="math/tex">f(y) = x^3</script></p>

<div class="language-c# highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span> <span class="p">&lt;</span> <span class="n">points</span><span class="p">.</span><span class="n">Length</span><span class="p">;</span> <span class="n">i</span><span class="p">++)</span> 
<span class="p">{</span>
	<span class="n">Transform</span> <span class="n">point</span> <span class="p">=</span> <span class="n">points</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
	<span class="n">Vector3</span> <span class="n">position</span> <span class="p">=</span> <span class="n">point</span><span class="p">.</span><span class="n">localPosition</span><span class="p">;</span>
	<span class="n">position</span><span class="p">.</span><span class="n">y</span> <span class="p">=</span> <span class="n">position</span><span class="p">.</span><span class="n">x</span> <span class="p">*</span> <span class="n">position</span><span class="p">.</span><span class="n">x</span> <span class="p">*</span> <span class="n">position</span><span class="p">.</span><span class="n">x</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Поскольку <code class="highlighter-rouge">Vector3</code> содержит в себе лишь значения (он не является игровым объектом), то значение получившихся координат нужно присвоить нашей точке.</p>

<div class="language-c# highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span> <span class="p">&lt;</span> <span class="n">points</span><span class="p">.</span><span class="n">Length</span><span class="p">;</span> <span class="n">i</span><span class="p">++)</span> 
<span class="p">{</span>
	<span class="n">Transform</span> <span class="n">point</span> <span class="p">=</span> <span class="n">points</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
	<span class="n">Vector3</span> <span class="n">position</span> <span class="p">=</span> <span class="n">point</span><span class="p">.</span><span class="n">localPosition</span><span class="p">;</span>
	<span class="n">position</span><span class="p">.</span><span class="n">y</span> <span class="p">=</span> <span class="n">position</span><span class="p">.</span><span class="n">x</span> <span class="p">*</span> <span class="n">position</span><span class="p">.</span><span class="n">x</span> <span class="p">*</span> <span class="n">position</span><span class="p">.</span><span class="n">x</span><span class="p">;</span>
	<span class="n">point</span><span class="p">.</span><span class="n">localPosition</span> <span class="p">=</span> <span class="n">position</span><span class="p">;</span>
<span class="p">}</span> 
</code></pre></div></div>

<blockquote>
  <p>А разве мы не можем сделать так: <code class="highlighter-rouge">point.localPosotion.y</code>?</p>

  <p>Если бы <code class="highlighter-rouge">localPosition</code> было полем, то это было бы возможно. Мы могли бы напрямую задать координату Y. Однако <code class="highlighter-rouge">localPosition</code> является свойством. Оно может передать и принять только значение вектора. Таким образом, мы пытаем скорректировать позицию в локальной системе координат, которая вообще никак не влияет на положение точки. И поскольку мы явно не сохранили его в переменно, операция бессмысленна и вызовет ошибку компилятора.</p>
</blockquote>

<h2 id="43-Отобразим-синусоиду"><strong>4.3 Отобразим синусоиду</strong></h2>
<p>С этого момента, если мы перейдем в режим воспроизведения, то точки нашего графика будут менять свое положение каждый кадр. Одна проблема: мы не замечаем никаких изменений, потому что они всегда остаются на одних и тех же позициях.  Для того чтобы изменить текущее положение дел надо наконец-то добавить зависимость нашей функции от времени. Однако стоит сразу сделать не большую оговорку: простое добавление времени приведет к тому что наша функция просто уползет куда-то в сторону бесконечности. Чтобы подобного не произошло мы должны использовать функцию, которая изменяется, но остается в фиксированном диапазоне. Функция синуса идеально подойдет для этого. В стандартной библиотеке Unity есть уже готовая структура для работы с математическими функциями - <code class="highlighter-rouge">Mathf</code>. В ней есть метод <code class="highlighter-rouge">Sin</code>, который возвращает значение синуса от переменной, которую мы передадим в качестве аргумента. В данном случае мы хотим отобразить функцию вида <script type="math/tex">f(y) = sin(x)</script>, потому мы должный координате в оси Y присвоить значение синуса от координаты X.</p>

<div class="language-c# highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">position</span><span class="p">.</span><span class="n">y</span> <span class="p">=</span> <span class="n">Mathf</span><span class="p">.</span><span class="nf">Sin</span><span class="p">(</span><span class="n">position</span><span class="p">.</span><span class="n">x</span><span class="p">);</span>
</code></pre></div></div>

<blockquote>
  <p>Что за Mathf?</p>

  <p>Это структура, содержащая в себе набор математических функций и констант для работы с числами и векторами. В пространстве имен <code class="highlighter-rouge">System</code> уже есть подобная структура, которая называется <code class="highlighter-rouge">Math</code>. Отличие в том, что <code class="highlighter-rouge">Mathf</code> работает с числами типа <code class="highlighter-rouge">float</code> и векторами, а <code class="highlighter-rouge">Math</code> с числами типа <code class="highlighter-rouge">double</code> и в ней вообще такого типа как вектор.</p>
</blockquote>

<p>Синусоида меняется в диапазоне от <script type="math/tex">(-1,+1)</script>. Данная функция циклична и повторяется каждые <script type="math/tex">2\pi</script> юнита, что примерно равно 6.28. Если так же масштабировать параметр времени на <script type="math/tex">\pi</script>, функция будет повторяться каждые две секунды. В итоге получим вот такую функцию: <script type="math/tex">f(x,t) = sin(\pi(x+t))</script>, где <script type="math/tex">t</script> это прошедшее время с момента запуска сцены. Этот параметр будет двигать синусоиду (волну), смещая ее в отрицательном направлении по оси X.</p>

<center><img src="\content\2018\02\BuildingGraph\FlamboyantCheapHoki-small.gif" /></center>
<p><em><center>Анимированная функция</center></em></p>

<p>Итоговый вариант от автора урока: <a href="\content\2018\02\BuildingGraph\animating-the-graph.unitypackage">4. unitypackage</a></p>

<p>Итоговый вариант от переводчика: <a href="http://catlikecoding.com/unity/tutorials/basics/building-a-graph/">5. unitypackage</a></p>

<p>Следующий урок: Математические поверхности</p>

<section class="tabs">
	<input id="tab_1" type="radio" name="tab" />
	
	<label for="tab_1" id="tab_l1">Tab One</label>
		<div style="clear:both"></div>

	<div class="tabs_cont">
		<div id="tab_c1">Content of first tab</div>
		
	</div>
</section>

<script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>

<script id="dsq-count-scr" src="//https-vangogih-github-io.disqus.com/count.js" async=""></script>


        </article>
      </div>
    </div>
    <footer>
      <div class="owner">
      

       

    </footer>
  </div>
  <div class="current-section">
    <a href="#top">Scroll to top</a>
    <p class="name"></p>
  </div>

  
  
   
  <div id="disqus_thread"></div>
	<script>
		(function() { 
		var d = document, s = d.createElement('script');
		s.src = 'https://https-vangogih-github-io.disqus.com/embed.js';
		s.setAttribute('data-timestamp', +new Date());
		(d.head || d.body).appendChild(s);
		})();
	</script>
	<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
  
</body>
</html>