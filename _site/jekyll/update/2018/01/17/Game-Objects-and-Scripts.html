<!doctype html>
<!-- The Time Machine GitHub pages theme was designed and developed by Jon Rohan, on Feb 7, 2012. -->
<!-- Follow him for fun. http://twitter.com/jonrohan. Tail his code on https://github.com/jonrohan -->
<html lang="en-US">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">

  <link rel="stylesheet" href="/assets/css/style.css?v=">
  <script type="text/javascript" src="https://ajax.googleapis.com/ajax/libs/jquery/1.7.1/jquery.min.js"></script>
  <script type="text/javascript" src="/assets/js/script.js"></script>

<!-- Begin Jekyll SEO tag v2.4.0 -->
<title>Unity3D Урок №1. Игровые объекты и скрипты | Блог Маслёнка</title>
<meta name="generator" content="Jekyll v3.6.2" />
<meta property="og:title" content="Unity3D Урок №1. Игровые объекты и скрипты" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="Привет. В один прекрасный день, пытаясь решить одну свою проблему, связанную с Unity3D, я наткнулся на блог одного человека. В этом блоге было представлено множество разных уроков по Unity3D. Сам парень из Дании и производство подобных статей для него является бизнесом. Он делает реально крутой контент, который ну просто грех не перевести на русский язык. Я связался с ним и попросил разрешения на перевод, на что он дал добро. Потому я запускаю большой цикл статей с переводом его уроков по Unity3D." />
<meta property="og:description" content="Привет. В один прекрасный день, пытаясь решить одну свою проблему, связанную с Unity3D, я наткнулся на блог одного человека. В этом блоге было представлено множество разных уроков по Unity3D. Сам парень из Дании и производство подобных статей для него является бизнесом. Он делает реально крутой контент, который ну просто грех не перевести на русский язык. Я связался с ним и попросил разрешения на перевод, на что он дал добро. Потому я запускаю большой цикл статей с переводом его уроков по Unity3D." />
<link rel="canonical" href="http://localhost:4000/jekyll/update/2018/01/17/Game-Objects-and-Scripts.html" />
<meta property="og:url" content="http://localhost:4000/jekyll/update/2018/01/17/Game-Objects-and-Scripts.html" />
<meta property="og:site_name" content="Блог Маслёнка" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2018-01-17T19:00:00+03:00" />
<script type="application/ld+json">
{"description":"Привет. В один прекрасный день, пытаясь решить одну свою проблему, связанную с Unity3D, я наткнулся на блог одного человека. В этом блоге было представлено множество разных уроков по Unity3D. Сам парень из Дании и производство подобных статей для него является бизнесом. Он делает реально крутой контент, который ну просто грех не перевести на русский язык. Я связался с ним и попросил разрешения на перевод, на что он дал добро. Потому я запускаю большой цикл статей с переводом его уроков по Unity3D.","@type":"BlogPosting","url":"http://localhost:4000/jekyll/update/2018/01/17/Game-Objects-and-Scripts.html","headline":"Unity3D Урок №1. Игровые объекты и скрипты","dateModified":"2018-01-17T19:00:00+03:00","datePublished":"2018-01-17T19:00:00+03:00","mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/jekyll/update/2018/01/17/Game-Objects-and-Scripts.html"},"@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->

  <meta name="description" content="All contents under (CC) BY-NC-SA license, unless otherwise noted. ">

  <meta name="viewport" content="width=device-width,initial-scale=1">

</head>

<body>

  <div class="wrapper">
    <header>
	  <a class="title" href = "http://localhost:4000"> Блог Маслёнка </a>
    </header>
    <div id="container">
      <p class="tagline">All contents under (CC) BY-NC-SA license, unless otherwise noted. </p>
      <div id="main" role="main">
        <article class="markdown-body">
          <p>Привет. В один прекрасный день, пытаясь решить одну свою проблему, связанную с Unity3D, я наткнулся на блог одного человека. В этом блоге было представлено множество разных уроков по Unity3D. Сам парень из Дании и производство подобных статей для него является бизнесом. Он делает реально крутой контент, который ну просто грех не перевести на русский язык. Я связался с ним и попросил разрешения на перевод, на что он дал добро. Потому я запускаю большой цикл статей с переводом его уроков по Unity3D.</p>

<p>Перейдя на его сайт Вы сможете ознакомиться с его статьями в оригинале. Я не прошу и не буду просить денег за свою работу, но если Вы разделяете мое мнение насчет годности контента этого талантливейшего разработчика, то Вы можете отблагодарить его за работу просто присоединивших к платформе Patreon и указать сумму ежемесячного взноса, либо же сделать единовременно пожертвование. В каждой переведенной мною статье я буду напоминать о том, что можно отблагодарить этого человека.</p>

<p>Ссылка на его блог: <a href="http://catlikecoding.com/">http://catlikecoding.com/</a></p>

<p>Ссылка где можно отблагодарить: <a href="https://www.patreon.com/catlikecoding">https://www.patreon.com/catlikecoding</a></p>

<p>Вот что пишет автор на странице <a href="https://www.patreon.com/catlikecoding">https://www.patreon.com/catlikecoding</a></p>

<p>Привет! Я Jasper Flick с сайта Catlike Coding.
Я делаю высококачественные уроки, которые позволят Вам узнать все о программировании с использованием языка C# в Unity. Мои уроки поданы в текстовом формате потому что считаю, что текст — это лучшее средство для данной тематики (для раскрытия данной темы). Так же они содержат набольшие вставки (картинки, анимации) которые, как я считаю, добавляют ценности.</p>

<p>Я в Patreon с Мая 2014 года и в настоящее время выпускаю по 2 урока в месяц. Сейчас я работаю над двумя разделами, шестиугольная карта (Hex Map) и рендеринг (Rendering).</p>

<p>Создание таких уроков отнимает очень много времени. Время, которое мне в основном приходится тратить на то чтобы не остаться голодным и т.п. Ваша поддержка — значит то, что я могу тратить больше времени на создание уроков, что улучшает их качество и количество.
Используйте Patreon для того чтобы сделать залог некоторой суммы денег, которую вы бы хотели дать мне, как спасибо за каждый новый урок. Нет пожертвований, нет уроков. Как бы плати сколько хочешь, но перед этим сказав сколько именно ты хочешь заплатить. Вы можете заранее выбрать одну из сумм залога или установить собственную. Не волнуйтесь, вы можете в любой момент изменить свою сумму, а также установить месячный лимит.</p>

<p>Не хотите заморачиваться с Patreon? Всегда можно сделать единовременное <a href="http://catlikecoding.com/unity/tutorials/donating.html">пожертвование</a></p>

<p>Это было не большое вступление, а теперь занавес, мы начинаем.</p>

<h2 id="Игровые-объекты-и-скрипты-Создание-часов"><strong>Игровые объекты и скрипты. Создание часов</strong></h2>

<ul>
  <li>Создадим часы из простых объектов</li>
  <li>Напишем скрипты на C#</li>
  <li>Заставим стрелки часов вращаться для отображения времени</li>
  <li>Добавим плавности</li>
</ul>

<p>В этом уроке мы создадим простые часы и запрограммируем их так чтобы они отображали время. Вам нужны будут только минимальные знания о редакторе Unity. Если вы до этого хотя бы пару минут игрались с Unity и знаете, как работать с окном <em>Scene</em>, то этого будет достаточно.</p>

<p>Данный урок сделан с использованием Unity версии 2017.1.0.</p>

<p><img src="\images\2018\01\GameObjectsAndScripts\tutorial-image.jpg" alt="Пришло время создать часы" />
<em><center>Пришло время создать часы</center></em></p>

<h2 id="1-Создадим-часы"><strong>1. Создадим часы</strong></h2>
<p>Откройте Unity и создайте новый 3D проект. Вам не понадобятся какие-либо уникальные ассеты с готовыми компонентами, аналитика вам тоже не понадобится, потому ее можно просто отключить. Если вы еще не настроили редактор, то у Вас будет установлено расположение окон по умолчанию.</p>

<p><img src="\images\2018\01\GameObjectsAndScripts\default-layout.png" alt="_Вариант расположения окон по умолчанию_" />
<em><center>Вариант расположения окон по умолчанию</center></em></p>

<p>Я использую другой вариант 2 к 3 (2 by 3) который вы можете выбрать в правом верхнем углу редактора. Изменим не много окно <em>Project</em> нажав на кнопку в правом верхнем углу и в выпадающем меню выбрав <em>One Column Layout</em>. Так же советую отключить показ координатной сетки <em>Show Grid</em> во вкладке <em>Scene</em>. Этот пункт можно найти в выпадающем меню на вкладке <em>Scene</em></p>

<p><img src="\images\2018\01\GameObjectsAndScripts\2-by-3.png" alt="_Измененное расположение окон_" />
<em><center>Измененное расположение окон</center></em></p>

<blockquote>
  <p><strong>Почему окно с игрой маленькое и черными границами по краям?</strong></p>

  <p>Такое может произойти есть вы используете монитор с большим разрешением и с нестандартным соотношением сторон. Для того чтобы избавиться от этого стоит на вкладке Game нажать на кнопку, которая находится рядом с Display 1. В выпавшем меню нужно убрать галку <em>Low Resolution Aspect Ratios</em> и установить <em>Free Aspect</em>.</p>

  <center><img src="\images\2018\01\GameObjectsAndScripts\low-resolution-aspect-ratios.png" width="300px" /></center>

  <p><em><center>Low resolution aspect ratios отключена</center></em></p>
</blockquote>

<h2 id="11-Создадим-игровой-объект-game-object"><strong>1.1 Создадим игровой объект (Game Object)</strong></h2>
<p>По умолчанию в сцене присутствуют 2 игровых объекта. Эти объекты находятся во вкладке Hierarchy и именно их иконки вы можете наблюдать во вкладке Scene. Первое это <em>Main Camera</em>, используется для отображения всех объектов на сцене. Окно <em>Game</em> отображается все что попадает в поле зрения камеры. Второй это <em>Directional Light</em> этот компонент добавляет базовый свет на сцену (он как солнце освещает всю сцену равномерно из одной точки).</p>

<p>Создадим собственный игровой объект выбрав в строке меню <em>GameObject / CreateEmpty</em>. Так же подобное вы можете сделать просто, нажав правой клавишей мыши на свободное место в окне <em>Hierarchy</em>. Давайте дадим только что добавленному объекту имя, для этого нажмите ПКМ на только что добавленном объекте и выберете <em>Rename</em>. Поскольку мы создаем часы, то назовем объект соответствующе - <em>Clock</em>.</p>

<center><img src="\images\2018\01\GameObjectsAndScripts\hierarchy.png" /></center>
<p><em><center>Вкладка Hierarchy с объектом Clock</center></em></p>

<p>Познакомимся с окном Inspector. В этом окне отображаются компоненты, которые есть у нашего игрового объекта. При выборе нашего объекта <em>Clock</em> он будет содержать заголовок с именем объекта и параметрами конфигурации. По умолчанию объект включен, не является статическим, не имеет тега и принадлежит слою <em>Default</em>. Эти настройки отлично подойдут нам. Ниже приведен список всех компонентов игрового объекта. На любом созданном объекте всегда присутствует компонент <em>Transform</em>.</p>

<center><img src="\images\2018\01\GameObjectsAndScripts\inspector.png" width="450px" /></center>
<p><em><center>Вкладка Inspector с выбранными часами</center></em></p>

<p>Компонент <em>Transform</em> хранит в себе позицию, углы поворота, масштаб в 3D пространстве. Убедитесь, что координаты и угол поворота у наших часов равен 0, а масштаб 1.</p>

<blockquote>
  <p><em>Что насчет 2D объектов?</em></p>

  <p>При работе в 2D вместо 3D игнорируется одно из трех измерений. Объекты, специально предназначенные для 2D-подобных элементов пользовательского интерфейса, обычно имеют <em>Rect Transform</em>, который является специализированным компонентом <em>Transform</em> для 2D объектов.</p>
</blockquote>

<h2 id="12-Создадим-основу-для-часов"><strong>1.2 Создадим основу для часов.</strong></h2>

<p>Хоть у нас и есть объект часы, на сцене мы не видим ничего. Хорошо, давайте добавим на сцену 3D модель, которая будет отображаться на нашей сцене. В Unity «из-под коробки» есть несколько примитивных объектов, которые мы можем использовать для того чтобы создать наши часы. Давайте начнем. Добавим на нашу сцену цилиндр нажав на <em>GameObject/3DObject/Cylinder</em>.  Убедитесь, что он имеет те же значения Transform что и объект <em>Clock</em>.</p>

<center>
<img src="\images\2018\01\GameObjectsAndScripts\cylinder.png" width="170" height="160" />
<img src="\images\2018\01\GameObjectsAndScripts\cylinder-inspector.png" width="320" height="229" />
</center>
<p><em><center>Игровой объект, представляющий собой цилиндр</center></em></p>

<p>Наш только что добавленный объект имеет несколько незнакомых нам компонентов. Первый это <em>Mesh Filter</em>, этот компонент просто содержит в себе ссылку на <em>Mesh (сетку)</em> цилиндра. Второй это <em>Capsule Collider</em>, который предназначен для взаимодействия объектов. Без этого компонента все объекты будут просто проходить насквозь друг через друга и никак не взаимодействовать между собой. Третий компонент это <em>Mesh Renderer</em>. Этот компонент обеспечивает визуализацию нашего объекта, путем наложения текстуры на сетку.  Он так же контролирует какой материал вы используете для отрисовки, по умолчанию устанавливается <em>Default-Material</em>, но вы всегда можете его изменить в соответствующем компоненте, который расположен ниже <em>Mesh Renderer</em>.</p>

<p>Если вы уже успели покликать по нашему объекту, то вы наверняка заметили, что наш объект представляет собой цилиндр, а вот коллайдер у нас имеет форму капсулы. Так произошло потому что в Unity нет готового компонента с коллайдером в форме цилиндра. Но собственно нас это не волнует, потому просто удалим этот компонент. Если же вам вдруг понадобится сделать коллайдер именно у цилиндра или у другого объекта, форма которого более сложная, то воспользуйтесь компонентом <em>Mesh Collider</em>. Компоненты можно удалить с помощью выпадающего меню со знаком шестеренки в правом верхнем углу.</p>

<center><img src="\images\2018\01\GameObjectsAndScripts\cylinder-no-collider.png" width="450" /></center>
<p><em><center>Наш объект без коллайдера</center></em></p>

<p>Для того чтобы превратить наш цилиндр в нечто похожее на часы, необходимо сделать циферблат, путем сплющивания нашего цилиндра. Это делается уменьшением значения <em>Scale</em> по оси Y до 0,1, а X, Z увеличением на 10.</p>

<center>
<img src="\images\2018\01\GameObjectsAndScripts\cylinder-scaled-scene.png" width="230" height="170" />
<img src="\images\2018\01\GameObjectsAndScripts\cylinder-scaled-inspector.png" width="320" height="76" />
</center>
<p><em><center>Растянутый цилиндр</center></em></p>

<p>Изменим имя нашего цилиндра на <em>Face</em>. Поскольку сделанный нами циферблат является частью часов, то укажем это в иерархии. Для этого переместим наш <em>Face</em> на объект <em>Clock</em>.</p>

<center><img src="\images\2018\01\GameObjectsAndScripts\child-object.png" /></center>
<p><em><center>Face является дочерним к объекту Clock.</center></em></p>

<p>Дочерние объекты копируют преобразования родительского объекта. Это значит, что если мы изменим положение часов, то положение циферблата изменится вместе с ним, как будто они стали единым целым. Тоже самое касается вращения и масштаба. Это можно использовать для создания сложных иерархий объектов.</p>

<h2 id="13-Создание-циферблата"><strong>1.3 Создание циферблата</strong></h2>
<p>Теперь сделаем градуировку на нашем циферблате, по которой можно будет ориентироваться во времени или по-другому контур часов. 
Добавим объект Куб на сцену кликнув <em>GameObject / 3D Object / Cube</em>. Изменим масштаб на <em>(0.5, 0.2, 1)</em> сделав его длинным узким блоком похожий на брусок. Установим ему позицию <em>(0, 0.2, 4)</em>. Это положение соответствует 12 часам. Назовите его <em>Hour Indicator</em>.</p>

<center>
<img src="\images\2018\01\GameObjectsAndScripts\indicator-scene.png" width="300" height="214" />
<img src="\images\2018\01\GameObjectsAndScripts\indicator-inspector.png" width="320" height="229" />
</center>
<p><em><center>Отметка 12 часов</center></em></p>

<p>Пока нашу отметку очень сложно увидеть, потому что она сливается с циферблатом. Для того чтобы изменить текущее положение дел нужно нажать <em>Assets / Create / Material</em> и создать новый материал или сделать аналогичные действия в окне <em>Project</em>. Это создаст нам материал, который дублирует материал по умолчанию. Изменим <em>Albedo</em> на что-то более темное, установив значение 73 для красного, зеленого и синего. В результате мы получим темно-серый материал. Давайте дадим ему соответствующее имя – <em>Clock dark</em>.</p>

<center>
<img src="\images\2018\01\GameObjectsAndScripts\dark-material.png" width="556" height="130" />
<img src="\images\2018\01\GameObjectsAndScripts\color-popup.png" width="220" height="356" />
</center>
<p><em><center>Темный материал и всплывающее окно с выбором цвета</center></em></p>

<blockquote>
  <p><em>Что за альбедо такое?</em></p>

  <p>Альбедо происходит от латинского слова белизна. Это просто цвет материала.</p>

  <p>Прим. От переводчика: как бы по факту это не совсем так. Почему назвали именно альбедо, а не просто цвет сложно сказать, но Вы можете почитать сами и внести ясности в данный вопрос</p>
</blockquote>

<p>Перетащите этот материал на нашу 12 часовую отметку или просто переместите наш материал в ячейку <em>Element 0</em> компонента <em>Mesh Renderer</em>.</p>

<center><img src="\images\2018\01\GameObjectsAndScripts\dark-indicator.png" width="300" /></center>
<p><em><center>Отметка 12 часов темно-серого цвета</center></em></p>

<p>Наша отметка корректно показывает 12 часов, но что если мы хотим показать 1 час на часах? Все 12 часов располагаются на круге 360°, разделив 360° на 12 отметок получим 30°. Получается, что каждую отметку нам нужно будет поворачивать на 30° по оси Y. Давайте сделаем это.</p>

<center>
<img src="\images\2018\01\GameObjectsAndScripts\rotated-scene.png" width="250" height="188" />
<img src="\images\2018\01\GameObjectsAndScripts\rotated-inspector.png" width="320" height="76" />
</center>
<p><em><center>Повернутая часовая отметка, но неправильно расположенная</center></em></p>

<p>Наша отметка повернута на правильный угол, но расположена она все еще на позиции 12 часовой отметки. Это произошло потому мы вращали объект относительно его собственное локальной исходной точки, которая является его положением в пространстве.</p>

<p>Мы должны переместить отметку вдоль кромки циферблата так чтобы наша отметка занимала положение часовой отметки. Вместо того чтобы высчитывать вручную положение в пространстве каждой отметки мы можем использовать иерархию объектов. Для начала сбросьте параметр поворота у нашей отметки (измените его на 0).  Затем создайте новый пустой объект с координатами, поворотом равными 0 и масштабом равным 1. Сделайте нашу отметку дочерней к пустому только что созданному объекту.</p>

<center><img src="\images\2018\01\GameObjectsAndScripts\temporary-parent.png" /></center>
<p><em><center>Временный родитель</center></em></p>

<p>Теперь установим у родителя значение поворота по оси Y равное 30°. Таким образом наша отметка будет вращаться вокруг пустого объекта родителя, а это именно то что нам нужно.</p>

<center><img src="\images\2018\01\GameObjectsAndScripts\rotated-correct.png" width="300" /></center>
<p><em><center>Правильное положение часовой отметки</center></em></p>

<p>Продублируйте нашего временного родителя используя сочетанием клавиш <em>Ctrl+D</em> или воспользовавшись контекстным меню во вкладке <em>hierarchy</em>. В каждом дубликате увеличьте значение поворота по оси Y на 30°. Сделайте подобным образом все 12 отметок.</p>

<center><img src="\images\2018\01\GameObjectsAndScripts\12-hour-indicators.png" width="300" /></center>
<p><em><center>Циферблат со всеми часовыми отметками</center></em></p>

<p>Нам больше не понадобятся временные родители. Выберите все отметки часов использовав <em>Ctrl+ЛКМ</em> и сделайте их дочерними к нашим часам. Теперь объясню, как такое получилось. Если перед тем как сделать объект дочерним к часам вы посмотрите на компонент <em>Transform</em> у отметки, то вы заметите что у всех объектов одинаковое значения как координат, так и углов поворота. А после того как вы поменяете у него родителя, то эта значения изменятся. Это произошла трансформация из локальной системы координат в глобальную. Раньше наши отметки получали координаты и угол поворота от временного родителя, сейчас же их координаты преобразовались в локальные координаты для объекта <em>Clock</em> сохранив углы поворота.</p>

<center><img src="\images\2018\01\GameObjectsAndScripts\periphery-children.png" /></center>
<p><em><center>Получившаяся иерархия</center></em></p>

<blockquote>
  <p><em>У меня значения координат равно 90,0000001. Это правильно?</em></p>

  <p>Это произошло потому что координаты, углы поворота и масштаб являются числами с плавающей точкой (float). Этот тип переменных имеет ограниченную точность, потому может вызвать незначительные отклонения, связанные с округлением. Переживать по этому поводу не стоит, поскольку отклонение 0,0000001 настолько мало что не оказывает никакого заметного влияния.</p>
</blockquote>

<h2 id="14-Создадим-стрелки-часов"><strong>1.4 Создадим стрелки часов</strong></h2>
<p>Мы можем использовать тот же подход чтобы создать стрелки часов. Создайте новый куб и назовите его Arm, сразу перетяните на него созданный нами материал и удалите коллайдер. Установите масштаб равный <em>(0.3, 0.2, 2.5)</em> таким образом сделав его уже и длиннее чем наша отметка. Установите координаты <em>(0, 0.2, 0.75)</em> при такой установке стрелка будет направлена в сторону 12 часов, а другая сторона стрелки будет не много смещена относительно центра часов. Со стороны это выглядит как не большой противовес.</p>

<center>
<img src="\images\2018\01\GameObjectsAndScripts\hours-arm-scene.png" width="250" height="200" />
<img src="\images\2018\01\GameObjectsAndScripts\hours-arm-inspector.png" width="320" height="229" />
</center>
<p><em><center>Часовая стрелка</center></em></p>

<blockquote>
  <p>Куда делась иконка с солнцем?</p>

  <p>Я переместил свет не много в сторону чтобы он больше не загромождал сцену. Directional Light освещается сцену равномерно независимо от его положения.</p>
</blockquote>

<p>Чтобы заставить нашу стрелку правильно вращаться, создайте родительский пустой объект для него по аналогии с отметками. Убедитесь, что родитель имеет координаты и углы поворота равные 0, а масштаб равный 1. Проверить необходимо, потому что вращать стрелку мы будет чуть позже. Сделайте стрелку дочерним к пустому объекту, назовите родительский объект Hours Arm, после сделайте его дочерним к часам. Теперь стрелка является как бы «внуком» часов.</p>

<center><img src="\images\2018\01\GameObjectsAndScripts\hours-arm-hierarchy.png" /></center>
<p><em><center>Колонка hierarchy после всех действий</center></em></p>

<p>Продублируйте Hours Arm дважды для создания минутной и секундной стрелки. Переименуйте их в <em>Minutes Arm</em> и <em>Seconds Arm</em> соответственно. Минутная стрелка должная быть длиннее и уже, чем часовая, для этого проставим значения масштаба равные <em>(0.2, 0.15, 4)</em> и координат равные <em>(0, 0.375, 1)</em>. Таким образом наша стрелка будет расположена выше часовой стрелки.</p>

<p>Для секундной стрелки установим значения для масштаба равные <em>(0.1, 0.1, 5)</em> и координат <em>(0, 0.5, 1.25)</em>. Выделим нашу секундную стрелку на общем фоне путем создания нового материала красного цвета со значением <em>Albedo</em> равным <em>(197,0,0)</em> и применим этот материал на нашей стрелке.</p>

<center>
<img src="\images\2018\01\GameObjectsAndScripts\all-arms-scene.png" width="250" height="188" />
<img src="\images\2018\01\GameObjectsAndScripts\all-arms-hierarchy.png" width="120" height="154" />
</center>
<p><em><center>Часы со всеми стрелками</center></em></p>

<p>Наши часы полностью готовы. Если вы до этого не создавали и не сохраняли вашу сцену, то самое время это сделать, нажав <em>File / Save Scene</em> имя сцены выбирайте сами. Я назвал ее просто <em>Scene</em>.</p>

<p><strong>Прим. От переводчика:</strong> сцены в Unity это как отдельные уровни одной большой игры. У вас может быть несколько сцен, на которых будут разные уровни. После завершения одного вы можете запускать другой, обеспечивая тем самым смену локаций. Заведите себе привычку при создании любого проекта первым делом создать сцену. Сохраняйте эту сцену каждые 5-10 минут нажатием клавиш Ctrl+S. Это не раз вас спасет если вы работаете не на самом мощном компьютере.</p>

<center><img src="\images\2018\01\GameObjectsAndScripts\saved-scene.png" /></center>
<p><em><center>Сохраненная сцена</center></em></p>

<p>Если вы застряли, хотите сравнить или пропустить блок с созданием часов, то вы можете <a href="http://catlikecoding.com/unity/tutorials/basics/game-objects-and-scripts/building-a-simple-clock/building-a-simple-clock.unitypackage">скачать</a> сделанный мною вариант. Вы можете присоединить мой вариант к своему проекту через вкладку <em>Assets / Import Package / Custom Package</em>. Далее нажмите <em>Import</em> и запустите мою сцену.</p>

<h2 id="2-Анимируем-часы"><strong>2. Анимируем часы</strong></h2>
<p>Замечательно! Часы есть. Запустим сцену нажав на кнопку <em>Play</em>. Если у вас камера направлена прямо на часы, то вы заметите что часы не идут. Нажмем снова на <em>Play</em>, остановим игру и проясним ситуацию. На данный момент мы просто создали иерархию объектов, которые просто расположены на сцене. Ничего более. Если бы в Unity был уже готовый компонент, который мы могли бы прикрепить к часам, и он начал бы сразу бы работать, было бы круто, но такого компонента нет. Потому нам придется его создать самим. Компоненты создаются с помощью скриптов. Добавим новый скрипт нажав _ Assets / Create / C# Script_ и назвав его <em>Clock</em>.</p>

<center>
<img src="\images\2018\01\GameObjectsAndScripts\clock-project.png" width="90" height="70" />
<img src="\images\2018\01\GameObjectsAndScripts\clock-inspector.png" width="320" height="156" />
</center>
<p><em><center>Наш скрипт во вкладке проект и во вкладке с компонентами </center></em></p>

<p>При выборе скрипта инспектор покажет содержимое скрипта и там же можно найти кнопку <em>Open</em> для того чтобы открыть наш файл в редакторе. Или просто сделай двойной клик по файлу, и он откроется в редакторе. Наш скрипт будет содержать в себе шаблон кода по умолчанию. Этот код представлен ниже.</p>

<figure class="highlight"><pre><code class="language-c#" data-lang="c#"><span class="k">using</span> <span class="nn">System.Collections</span><span class="p">;</span>
<span class="k">using</span> <span class="nn">System.Collections.Generic</span><span class="p">;</span>
<span class="k">using</span> <span class="nn">UnityEngine</span><span class="p">;</span>
<span class="k">public</span> <span class="k">class</span> <span class="nc">Clock</span> <span class="p">:</span> <span class="n">MonoBehaviour</span> <span class="p">{</span>
	<span class="c1">// Use this for initialization</span>
	<span class="k">void</span> <span class="nf">Start</span> <span class="p">()</span> <span class="p">{</span>		
	<span class="p">}</span>
	<span class="c1">// Update is called once per frame</span>
	<span class="k">void</span> <span class="nf">Update</span> <span class="p">()</span> <span class="p">{</span>	
	<span class="p">}</span>
<span class="p">}</span></code></pre></figure>

<p>Этот код написан на языке C#. Это язык программирования используется в Unity для создания скриптов. Для того чтобы более подробно разобраться с тем как работает код, удалим все что нам сгенерировал Unity с начнем сначала.</p>

<blockquote>
  <p>А что насчет JavaScript?</p>

  <p>Unity так же поддерживает другой язык программирования, обычно называемый JavaScript, но его фактическое название – UnityScript. Unity 2017.1.0 до сих пор поддерживает его, но в версии Unity 2017.2.0 из меню для добавления компонентов была убрана возможность создать JavaScript. Как бы можно точно сказать, что поддержка этого языка полностью прекращена в Unity.</p>
</blockquote>

<h2 id="21-Введение-в-скриптинг"><strong>2.1 Введение в скриптинг</strong></h2>
<p>Пустой скрипт, в котором нет ни единой строчки не будет работать в Unity. Мы назвали наш файл <em>Clock</em> и Unity ждет того что в данном скрипте будет указано то, что должны делать наши часы. Мы не даем определение для одного экземпляра компонента. Вместо этого мы определяем общий класс или тип, известный как <code class="highlighter-rouge">Clock</code>. После того как мы это сделаем, мы можем создать несколько таких компонентов в Unity.</p>

<p>В C# мы определяем тип <code class="highlighter-rouge">Clock</code> начиная с определения класса. Нужно явно указать какую структуру мы будем использовать для определения наших часов.  <em>Строки кода в которых что-то изменилось будут закоментированы. Когда мы начинаем работу с полностью пустым файлом первое что мы должны объявить это <code class="highlighter-rouge">class Clock</code>. При желании можете поиграться со знаками табуляции нажав пробел или _Tab</em>,</p>

<figure class="highlight"><pre><code class="language-c#" data-lang="c#"><span class="err">с</span><span class="n">lass</span> <span class="n">Clock</span></code></pre></figure>

<blockquote>
  <p>Что такое класс с технической точки зрения?</p>

  <p>Класс представляет собой шаблон, по которому определяется форма объекта. В нем указываются данные и код, который будет оперировать этими данными. В C# используется спецификация класса для построения объектов, которые являются экземплярами класса. Следовательно, класс, по существу, представляет собой ряд схематических описаний способа построения объекта. При этом очень важно подчеркнуть, что класс является логической абстракцией. Физическое представление класса появится в оперативной памяти лишь после того, как будет создан объект этого класса.</p>

  <p>Классы и структуры — это, по сути, шаблоны, по которым можно создавать объекты. Каждый объект содержит данные и методы, манипулирующие этими данными.</p>

  <p>Прим. От переводчика: у автора написано примерно такое же определение, но в более сжатой форме. Его определение очень сложно перевести так, чтобы оно было понятно читателю. Потому данное определение я сформулировал самостоятельно исходя из контекста автора. При необходимости прочитайте это в оригинале.</p>
</blockquote>

<p>Поскольку мы не хотим ограничивать доступ к нашему классу, проставим модификатор доступа к <code class="highlighter-rouge">Clock</code>. Это делается путем подставленные префикса <code class="highlighter-rouge">public</code> перед определением класса.</p>

<figure class="highlight"><pre><code class="language-c#" data-lang="c#"><span class="k">public</span> <span class="err">с</span><span class="n">lass</span> <span class="n">Clock</span></code></pre></figure>

<blockquote>
  <p>Что такое модификатор доступа по умолчанию для классов?</p>

  <p>Если мы не проставим самостоятельно модификатор доступа, то будет выбран модификатор по умолчанию ` internal class Clock`. Это ограничивает доступ к коду из одной сборки, что становится актуальным при использовании кода, упакованного в несколько DLL файлов.</p>
</blockquote>

<p>На данном этапе наш код до сих пор не компилируется. Мы указали что есть некий класс <code class="highlighter-rouge">Clock</code> но мы не указали что он должен делать. Для компилятора необходимо явно указать область, в которой будет прописан код нашего класса. Эти самый границы обозначаются фигурными скобками <code class="highlighter-rouge">{}</code>, давайте добавим их</p>

<figure class="highlight"><pre><code class="language-c#" data-lang="c#"><span class="k">public</span> <span class="err">с</span><span class="n">lass</span> <span class="n">Clock</span> <span class="p">{}</span></code></pre></figure>

<p>Теперь наш скрипт скомпилируется. Нажмите <em>Ctrl+S</em> для того чтобы сохранить изменения в файле и вернитесь в окно редактора Unity. Unity «увидела» что файл был изменен и сразу перекомпилировала его. Давайте выберем наш скрипт. И в инспекторе мы можем увидеть надпись, которой до этого не было, которая говорит нам о том, что наш класс не содержит <code class="highlighter-rouge">MonoBehaviour</code>.</p>

<center>
<img src="\images\2018\01\GameObjectsAndScripts\non-component.png" />
</center>
<p><em><center>Отсутствует  MonoBehaviour </center></em></p>

<p>Это означает что мы не можем использовать этот скрипт для создания компонента в Unity. На данном этапе наш класс <code class="highlighter-rouge">Clock</code> определяет универсальный тип объекта в C#. Для того чтобы наш компонент мог что-либо сделать (в данном случае нам нужно заставить стрелки часов вращаться) нужно реализовать методы, которые есть в классе <code class="highlighter-rouge">MonoBehaviour</code>.</p>

<blockquote>
  <p>Что за MonoBehaviour?</p>

  <p>Идея заключается в том, что мы можем программировать наши собственные компоненты, чтобы добавить пользовательского <strong>поведения</strong> (от англ. Behaviour) для наших игровых объектов. Приставка Mono была добавлена в следствии того что ранее Unity использовал проекты типа mono что является кроссплатформенным расширением файлов в .NET framework. Потому и MonoBehaviour. Это старое название, которое пришло к нам из первых версий Unity.  Узнать о Mono подробнее можно <a href="https://ru.wikipedia.org/wiki/Mono">тут</a>.</p>
</blockquote>

<p>Чтобы превратить <code class="highlighter-rouge">Clock</code> в подтип <code class="highlighter-rouge">MonoBehaviour</code> мы должны явно это указать через знак двоеточия. Это позволяет нашим <code class="highlighter-rouge">Clock</code> унаследовать весь функционал ` MonoBehaviour `.</p>

<figure class="highlight"><pre><code class="language-c#" data-lang="c#"><span class="k">public</span> <span class="err">с</span><span class="n">lass</span> <span class="n">Clock</span> <span class="p">:</span> <span class="n">MonoBehaviour</span> <span class="p">{}</span></code></pre></figure>

<p>Однако, это все равно приводит к ошибке компиляции. Компилятор жалуется, что не может найти тип <code class="highlighter-rouge">MonoBehaviour</code>. Это произошло потому что <code class="highlighter-rouge">MonoBehaviour</code> находится в пространстве имен <code class="highlighter-rouge">UnityEngine</code>. Чтобы получить доступ к нему необходимо явно указать что мы хотим использовать <code class="highlighter-rouge">MonoBehaviour</code> из пространства имен <code class="highlighter-rouge">UnityEngine</code>.</p>

<figure class="highlight"><pre><code class="language-c#" data-lang="c#"><span class="k">public</span> <span class="err">с</span><span class="n">lass</span> <span class="n">Clock</span> <span class="p">:</span> <span class="n">UnityEngine</span><span class="p">.</span><span class="n">MonoBehaviour</span> <span class="p">{}</span></code></pre></figure>

<blockquote>
  <p>Что такое пространство имен?</p>

  <p>Пространство имен это как домен для сайта, но только в коде. Как домен может иметь субдомен, так и пространство имен может иметь подпространство имен. Большая проблема данной аналогии в том, что путь к сайту в программировании записывается наоборот. Вместо forum.unity3d.com мы имеем com.unity3d.forum. Код написанный разработчиками не нужно ниоткуда качать т.к. он сразу есть в Unity. Пространства имен используются для организации кода и предотвращения смешивания имен функции.</p>
</blockquote>

<p>Поскольку неудобно всегда использовать префикс <code class="highlighter-rouge">UnityEngine</code>, мы можем сказать компилятору чтобы он выполнял поиск в этом пространстве имен. Это делается путем добавления строки <code class="highlighter-rouge">using UnityEngine;</code> в заголовок скрипта. Знак точки с запятой <code class="highlighter-rouge">:</code> здесь очень важен потому что он явно говорит компилятору где именно закончилась команда.</p>

<figure class="highlight"><pre><code class="language-c#" data-lang="c#"><span class="k">using</span> <span class="nn">UnityEngine</span><span class="p">;</span>
<span class="k">public</span> <span class="err">с</span><span class="n">lass</span> <span class="n">Clock</span> <span class="p">:</span> <span class="n">MonoBehaviour</span> <span class="p">{}</span></code></pre></figure>

<p>Ну теперь наконец-то мы можем прикрепить наш компонент к объекту. Это можно легко сделать просто, перетащив наш скрипт на нужный нам объект, либо нажать на объекте кнопку <em>Add Component</em>, которая находится во вкладке <em>Inpector</em>.</p>

<center>
<img src="\images\2018\01\GameObjectsAndScripts\clock-with-component.png" />
</center>
<p><em><center>Объект Clock с прикрепленным к нему скриптом </center></em></p>

<p>Теперь у нас создан экземпляр объекта C#, использующий наш класс <code class="highlighter-rouge">Clock</code> в качестве шаблона. В результате чего мы видим неизменяемое поле Script со значением Clock.</p>

<h2 id="22-Получим-стрелки-часов"><strong>2.2 Получим стрелки часов</strong></h2>
<p>Для того чтобы поворачивать наши стрелки необходимо передать информацию о них нашему скрипту <code class="highlighter-rouge">Clock</code>. Давайте начнем с часовой стрелки. Все игровые объекты могут быть повернуты путем изменения углов поворота в соответствующем компоненте <em>Transform</em>. Поэтому нашему скрипту необходимо явно указать на то какой компонент нам необходимо получить. Это можно сделать путем добавления поля с данными внутрь блока с кодом.</p>

<p><code class="highlighter-rouge">Hours transform</code> будет подходящим именем для нашего поля. Для того чтобы Unity мог правильно распарсить имена наших переменных, то стоит их называть в соответствии со стилем написания составных слов, при котором несколько слов пишутся слитно без пробелов, при этом каждое слово внутри фразы пишется с заглавной буквы - <em>CamelCase</em>. В нашем случае будет правильно назвать наше поле <code class="highlighter-rouge">hoursTransform</code>.</p>

<figure class="highlight"><pre><code class="language-c#" data-lang="c#"><span class="k">public</span> <span class="err">с</span><span class="n">lass</span> <span class="n">Clock</span> <span class="p">:</span> <span class="n">MonoBehaviour</span> 
<span class="p">{</span>
	<span class="n">hoursTransform</span><span class="p">;</span>
<span class="p">}</span></code></pre></figure>

<blockquote>
  <p>Куда делась строка с using?</p>

  <p>Она все еще тут. Фрагменты кода, которые будут приведены будут содержать фрагменты, в которых что-либо изменилось. потому если вы части кода не видите, то значит он остается без изменений.</p>
</blockquote>

<p>Так же обязательно мы должны указать тип нашего поля. В данном случае мы хотим получить компонент <code class="highlighter-rouge">UnityEngine.Transform</code> который содержит в себе информацию взятую из компонента <em>Transform</em>.</p>

<figure class="highlight"><pre><code class="language-c#" data-lang="c#"><span class="n">Transform</span> <span class="n">hoursTransform</span><span class="p">;</span></code></pre></figure>

<p>Наш класс теперь определяет поле, которое должно содержать ссылку на объект, тип которого должен быть <code class="highlighter-rouge">Transform</code>. Нам нужно убедиться, что мы передаем ссылку на компонент <code class="highlighter-rouge">Transform</code> объекта <em>Hours Arm</em>.</p>

<p>Но пока мы не можем этого сделать, потому что у нас не указан модификатор доступа к данному полю. Вся загвоздка тут в том, что если мы явно не прописываем этот модификатор, то по умолчанию он проставляется как <code class="highlighter-rouge">private</code>, что означает что получить доступ к данному полю мы можем только внутри нашего класса и никак не можем получить из вне. Поэтому давайте изменим модификатор доступа, добавив ключевое слово <code class="highlighter-rouge">public</code>.</p>

<figure class="highlight"><pre><code class="language-c#" data-lang="c#"><span class="k">public</span> <span class="n">Transform</span> <span class="n">hoursTransform</span><span class="p">;</span> </code></pre></figure>

<blockquote>
  <p>Разве публичные поля это не плохо?</p>

  <p>В целом, консенсус заключается в том, чтобы избежать создания открытых полей при создании программ. Однако в Unity публичные поля нужны для того чтобы передать ссылку на элементы сцены, которые мы хотим каким-либо образом изменить. Можно обойтись и без публичных полей, но тогда вам придется изрядно с этим заморочиться и написать алгоритм, который рекурсивно проходит по всей иерархии и ищет ваши объекты по имени или тегам.</p>
</blockquote>

<p>После того как мы проставили наш модификатор доступа, то мы должны увидеть соответствующее поле в окне <em>Inspector</em>. Это работает именно так. Вы пишете код, сохраняете его, Unity видит что файл был изменен, заново его компилирует, и обновляет его.</p>

<center>
<img src="\images\2018\01\GameObjectsAndScripts\hours-transform-field.png" />
</center>
<p><em><center>Поле Hours Transform типа Transform</center></em></p>

<p>Для того чтобы передать ссылку на нужный нам компонент, необходимо найти нужный нам объект в иерархии и просто перетащить его в созданное нами поле. Но есть и другой способ. Необходимо просто нажать на кружок рядом с полем и выбрать в выпадающем меню нужный нам компонент.</p>

<center>
<img src="\images\2018\01\GameObjectsAndScripts\hours-transform-connected.png" />
</center>
<p><em><center>Ссылка на компонент Transform объекта Hours Arms передана</center></em></p>

<h2 id="23-Получим-все-стрелки-часов"><strong>2.3 Получим все стрелки часов</strong></h2>
<p>Сделаем то же самое для минутной и секундной стрелки.</p>

<figure class="highlight"><pre><code class="language-c#" data-lang="c#"><span class="k">public</span> <span class="n">Transform</span> <span class="n">hoursTransform</span><span class="p">;</span>
<span class="k">public</span> <span class="n">Transform</span> <span class="n">minutesTransform</span><span class="p">;</span>
<span class="k">public</span> <span class="n">Transform</span> <span class="n">secondsTransform</span><span class="p">;</span></code></pre></figure>

<p>Эти объявления полей можно сделать более краткими, поскольку они имеют один и тот же модификатор доступа и тип. Объявление всех этих переменных можно свернуть в одну строчку. Для этого нужно просто записывать все переменные друг за другом, отделяя их друг от друга запятыми.</p>

<figure class="highlight"><pre><code class="language-c#" data-lang="c#"><span class="k">public</span> <span class="n">Transform</span> <span class="n">hoursTransform</span><span class="p">,</span> <span class="n">minutesTransform</span><span class="p">,</span> <span class="n">secondsTransform</span><span class="p">;</span>
<span class="c1">// public Transform minutesTransform;</span>
<span class="c1">// public Transform secondsTransform;</span></code></pre></figure>

<blockquote>
  <p>Что означает //?</p>

  <p>Два слэша идущих друг за другом это комментирование. Весь текст которых находится на этой строчке после двух слэшей просто игнорируется компилятором. Используется это для того чтобы добавлять какой-либо текст, не являющийся кодом в файл с кодом. Комментарии нужны для того чтобы дать понять другим людям или вам самим что делает тот или иной блок кода. Не стоит комментировать каждую строчку кода, это только затруднит чтение.</p>
</blockquote>

<p>Теперь передайте ссылки на наши объекты так же как мы сделали это с часовой стрелкой.</p>

<center>
<img src="\images\2018\01\GameObjectsAndScripts\arms-connected.png" />
</center>
<p><em><center>Ссылки на все объекты переданы</center></em></p>

<h2 id="24-Какой-сейчас-час"><strong>2.4 Какой сейчас час?</strong></h2>
<p>Теперь, когда мы явно указали ссылки на все объекты с которыми мы хотим что-либо сделать, мы можем перейти к следующему шагу – узнать который сейчас час. Чтобы сделать это мы должны прописать код, который будет делать то что нам нужно. Это делается путем добавления метода в наш класс <code class="highlighter-rouge">Clock</code>. Метод этот должен определенное имя <code class="highlighter-rouge">Awake</code> и название такое он имеет потому что мы предполагаем, что наш код должен выполнится, как только запустится наша сцена.</p>

<figure class="highlight"><pre><code class="language-c#" data-lang="c#"><span class="k">public</span> <span class="k">class</span> <span class="nc">Clock</span> <span class="p">:</span> <span class="n">MonoBehaviour</span> <span class="p">{</span>
	<span class="k">public</span> <span class="n">Transform</span> <span class="n">hoursTransform</span><span class="p">,</span> 
	<span class="n">minutesTransform</span><span class="p">,</span> 
	<span class="n">secondsTransform</span><span class="p">;</span>
	<span class="n">Awake</span> <span class="p">{}</span>
<span class="p">}</span></code></pre></figure>

<p>Методы несколько похожи на математические функции, для примера <script type="math/tex">f(x) = 2x + 3</script>. Эта функция берет некоторое число, умножает его на 2 и прибавляет 3. Она берет одно число на вход и возвращает тоже одно число. В случае метода это больше похоже на <script type="math/tex">f(p) = c</script>, где <script type="math/tex">p</script> представляет собой входные параметры, а <script type="math/tex">с</script> это выполнение кода. Такое объяснение может показаться слишком абстрактным, потому что не понятно какой результат выполнения нашей функции. Но на самом деле наша функция может и не возвращать никакого результата, она может просто выполнять код, который прописан внутри метода и все. Для того чтобы создать такой метод, то перед именем метода должен стоять префикс <code class="highlighter-rouge">void</code> (в дословном переводе «пустой»).</p>

<figure class="highlight"><pre><code class="language-c#" data-lang="c#"><span class="k">void</span> <span class="n">Awake</span> <span class="p">{}</span></code></pre></figure>

<p>Отлично. Но есть еще одна загвоздка. Компилятор ожидает что наш метод может принимать на вход какие-либо параметры. Но в нашем случае метод не принимает на вход никаких параметров и мы обязательно должны это указать поставив круглые скобки после имени нашего метода <code class="highlighter-rouge">()</code>.</p>

<figure class="highlight"><pre><code class="language-c#" data-lang="c#"><span class="k">void</span> <span class="nf">Awake</span><span class="p">()</span> <span class="p">{}</span></code></pre></figure>

<p>Теперь у нас есть валидный метод, который ничего не делает. Как бы Unity увидит наши поля, которые прописаны выше, увидит <code class="highlighter-rouge">Awake</code> метод и сделает то что написано в <code class="highlighter-rouge">{}</code> скобках. Если в нашем скрипте присутствует метод <code class="highlighter-rouge">Awake</code> и этот скрипт наследуется от ` MonoBehaviour`, то фрагмент кода написанный внутри этого метода выполняется сразу, как только компонент содержащий наш скрипт будет создан или загружен на сцену.</p>

<blockquote>
  <p>Почему у нашего метода Awake нет модификатора доступа?</p>

  <p>Метод Awake и набор некоторых других методов считаются особенными конкретно для Unity. Unity найдет и вызовет этот метод тогда, когда это будет нужно Unity. Мы не должны вызывать эти методы самостоятельно, Unity сам все поймет, распарсит и запустит помеченные нами методы именно в тот момент, в который нам надо.</p>
</blockquote>

<p>Чтобы проверить как именно это работает давайте заставим нашу программу выводить сообщение в консоль. Как раз класс <code class="highlighter-rouge">UnityEngine.Debug</code> имеет публичный метод <code class="highlighter-rouge">Log</code>, который поможет решить нашу задачу. Давайте просто выведем простой текст в консоль. Текст, который мы хотим вывести обернем в <code class="highlighter-rouge">“”</code>. И не забудьте про <code class="highlighter-rouge">;</code>, которая вспомните сами для чего нам нужна :)</p>

<figure class="highlight"><pre><code class="language-c#" data-lang="c#"><span class="k">void</span> <span class="nf">Awake</span><span class="p">()</span>
<span class="p">{</span>
	<span class="n">Debug</span><span class="p">.</span><span class="nf">Log</span><span class="p">(</span><span class="err">“</span><span class="n">Test</span><span class="err">”</span><span class="p">);</span>
<span class="p">}</span></code></pre></figure>

<p>Нажмите на кнопку <em>Play</em> в редакторе. И вы увидите, как текст, написанный нами, отобразится во вкладке <em>Console</em>. Либо же вы можете нажать <em>Window / Console</em>. В консоль может выводится вся информация, связанная с работой самой программы и кода, который вы написали. Если вы допустите ошибку при написании, то Unity выбросит вам исключение, которое отобразится в консоли.</p>

<p>Теперь, когда мы знаем, что наш метод работает, давайте узнаем текущее время. Пространство имен <code class="highlighter-rouge">UnityEngine</code> содержит в себе класс <code class="highlighter-rouge">Time</code>, который в свою очередь содержит свойство <code class="highlighter-rouge">time</code>. Очевидно, даже очень, давайте закодим и посмотрим, что у нас получится.</p>

<figure class="highlight"><pre><code class="language-c#" data-lang="c#"><span class="k">void</span> <span class="nf">Awake</span><span class="p">()</span>
<span class="p">{</span>
	<span class="n">Debug</span><span class="p">.</span><span class="nf">Log</span><span class="p">(</span><span class="n">Time</span><span class="p">.</span><span class="n">time</span><span class="p">);</span>
<span class="p">}</span></code></pre></figure>

<blockquote>
  <p>Что такое свойство?</p>

  <p>Свойство – это метод, который притворяется полем. У свойств можно проставить свои модификаторы доступа, позволяющие только читать, только записывать или и читать, и записывать данные. Негласно программисты стараются избегать использования свойств, но в Unity не всегда следуют этому негласному правилу.</p>
</blockquote>

<p>После запуска мы увидим в консоли цифру 0. Это произошло потому что <code class="highlighter-rouge">Time.time</code> возвращает время, которое прошло со времени запуска сцены. А поскольку, как мы говорили ранее, вывод в консоль происходит в момент инициализации компонента, а наш компонент инициализируется во время запуска сцены, а это значит, что времени с момента запуска сцены прошло ровно 0.</p>

<p>Для того чтобы получить доступ к системному времени компьютера, на котором мы работаем, мы можем использовать структуру <code class="highlighter-rouge">DateTime</code>. Данная структура не относится к Unity и находится в пространстве имен <code class="highlighter-rouge">System</code>. Эта структура является частью .Net framework.</p>

<blockquote>
  <p>Что такое структура?</p>

  <p>Как вам должно быть уже известно, классы относятся к ссылочным типам данных. Это означает, что объекты конкретного класса доступны по ссылке, в отличие от значений простых типов, доступных непосредственно. Но иногда прямой доступ к объектам как к значениям простых типов оказывается полезно иметь, например, ради повышения эффективности программы. Ведь каждый доступ к объектам (даже самым мелким) по ссылке связан с дополнительными издержками на расход вычислительных ресурсов и оперативной памяти.</p>

  <p>Для разрешения подобных затруднений в C# предусмотрена структура, которая подобна классу, но относится к типу значения, а не к ссылочному типу данных. Т.е. структуры отличаются от классов тем, как они сохраняются в памяти и как к ним осуществляется доступ (классы — это ссылочные типы, размещаемые в куче, структуры — типы значений, размещаемые в стеке), а также некоторыми свойствами (например, структуры не поддерживают наследование). Из соображений производительности вы будете использовать структуры для небольших типов данных. Однако в отношении синтаксиса структуры очень похожи на классы.</p>
</blockquote>

<p><code class="highlighter-rouge">DateTime</code> имеет публичное свойство <code class="highlighter-rouge">Now</code>. Оно создает значение <code class="highlighter-rouge">DateTime</code>, которое содержит текущую системную дату и время. Let’s code it.</p>

<figure class="highlight"><pre><code class="language-c#" data-lang="c#"><span class="k">using</span> <span class="nn">System</span><span class="p">;</span>
<span class="k">using</span> <span class="nn">UnityEngine</span><span class="p">;</span>

<span class="k">public</span> <span class="k">class</span> <span class="nc">Clock</span> <span class="p">:</span> <span class="n">MonoBehaviour</span> <span class="p">{</span>
	<span class="k">public</span> <span class="n">Transform</span> <span class="n">hoursTransform</span><span class="p">,</span> <span class="n">minutesTransform</span><span class="p">,</span> <span class="n">secondsTransform</span><span class="p">;</span>
	<span class="k">void</span> <span class="nf">Awake</span> <span class="p">()</span> 
<span class="p">{</span>
		<span class="n">Debug</span><span class="p">.</span><span class="nf">Log</span><span class="p">(</span><span class="n">DateTime</span><span class="p">.</span><span class="n">Now</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span></code></pre></figure>

<p>Теперь каждый раз при запуске нашей сцены у нас в консоли прописывается время, когда мы входим в <em>Play mode</em>.</p>

<h2 id="25-Поворачиваем-наши-стрелки"><strong>2.5 Поворачиваем наши стрелки</strong></h2>
<p>Следующий шаг — это поворот стрелок, основанный на текущем времени. По сложившейся традиции начнем мы с часовой стрелки. <code class="highlighter-rouge">DateTime</code> имеет еще одно интересное свойство, которое будет для нас полезно. Вызов свойства <code class="highlighter-rouge">hour</code> возвращает нам количество часов в данный момент времени. У меня он вернет час дня.</p>

<figure class="highlight"><pre><code class="language-c#" data-lang="c#"><span class="k">void</span> <span class="nf">Awake</span> <span class="p">()</span> 
<span class="p">{</span>
<span class="n">Debug</span><span class="p">.</span><span class="nf">Log</span><span class="p">(</span><span class="n">DateTime</span><span class="p">.</span><span class="n">Now</span><span class="p">.</span><span class="n">Hour</span><span class="p">);</span>
<span class="p">}</span></code></pre></figure>

<p>Мы можем использовать это свойство для предания вращения нашим стрелкам. Вращение объектов в Unity описывается при помощи кватернионов (quaternions). Вызовем публичный метод <code class="highlighter-rouge">Quaternion.Euler</code>. В качестве аргументов данный метод принимает углы поворота по осям X, Y и Z и возвращает он соответствующий этим аргументам кватернион.</p>

<figure class="highlight"><pre><code class="language-c#" data-lang="c#"><span class="k">void</span> <span class="nf">Awake</span> <span class="p">()</span> 
<span class="p">{</span>
<span class="c1">//Debug.Log(DateTime.Now.Hour);</span>
<span class="n">Quaternion</span><span class="p">.</span><span class="nf">Euler</span><span class="p">(</span><span class="m">0</span><span class="p">,</span> <span class="n">DateTime</span><span class="p">.</span><span class="n">Now</span><span class="p">.</span><span class="n">Hour</span><span class="p">,</span> <span class="m">0</span><span class="p">);</span>
<span class="p">}</span></code></pre></figure>

<blockquote>
  <p>Что такое кватернион?</p>

  <p>Кватернионы базируются на комплексных числах и используются для описания поворота объекта в 3D пространстве. Их труднее понять, чем простые 3D векторы, но они имею ряд полезных свойств. Например, они не будут повержены эффекту <a href="https://ru.wikipedia.org/wiki/Складывание_рамок">складывания рамок</a></p>

  <p><code class="highlighter-rouge">UnityEngine.Quaternion</code> используется как простое значение. Это структура, не класс.</p>
</blockquote>

<p>Все три аргумента это действительные числа, которые представлены в C# как числа с плавающей точкой. Чтобы явно объявить, что мы передаем методу числа с плавающей точкой, нужно к каждому нулю добавить суффикс <code class="highlighter-rouge">f</code>.</p>

<figure class="highlight"><pre><code class="language-c#" data-lang="c#"><span class="n">Quaternion</span><span class="p">.</span><span class="nf">Euler</span><span class="p">(</span><span class="m">0f</span><span class="p">,</span> <span class="n">DateTime</span><span class="p">.</span><span class="n">Now</span><span class="p">.</span><span class="n">Hour</span><span class="p">,</span> <span class="m">0f</span><span class="p">);</span></code></pre></figure>

<p>На часах наши отметки расположены по кругу через каждый 30°. Чтобы наше вращение стрелок было правильным мы должны умножить текущее значение часов на 30.</p>

<figure class="highlight"><pre><code class="language-c#" data-lang="c#"><span class="n">Quaternion</span><span class="p">.</span><span class="nf">Euler</span><span class="p">(</span><span class="m">0f</span><span class="p">,</span> <span class="n">DateTime</span><span class="p">.</span><span class="n">Now</span><span class="p">.</span><span class="n">Hour</span> <span class="p">*</span> <span class="m">30f</span><span class="p">,</span> <span class="m">0f</span><span class="p">);</span></code></pre></figure>

<p>Чтобы было ясно, что мы преобразуем часы в градусы, мы можем определить поле с соответствующим именем для коэффициента преобразования.</p>

<figure class="highlight"><pre><code class="language-c#" data-lang="c#"><span class="kt">float</span> <span class="n">degreesPerHour</span> <span class="p">=</span> <span class="m">30f</span><span class="p">;</span>
<span class="k">public</span> <span class="n">Transform</span> <span class="n">hoursTransform</span><span class="p">,</span> <span class="n">minutesTransform</span><span class="p">,</span> <span class="n">secondsTransform</span><span class="p">;</span>

<span class="k">void</span> <span class="nf">Awake</span> <span class="p">()</span>
<span class="p">{</span>
	<span class="n">Quaternion</span><span class="p">.</span><span class="nf">Euler</span><span class="p">(</span><span class="m">0f</span><span class="p">,</span> <span class="n">DateTime</span><span class="p">.</span><span class="n">Now</span><span class="p">.</span><span class="n">Hour</span> <span class="p">*</span> <span class="n">degreesPerHour</span><span class="p">,</span> <span class="m">0f</span><span class="p">);</span>
<span class="p">}</span></code></pre></figure>

<p>Поскольку данный коэффициент преобразования не будет нами больше изменяться, то мы можем объявить его константой.  Делаем это путем добавления префикса <code class="highlighter-rouge">const</code>.</p>

<figure class="highlight"><pre><code class="language-c#" data-lang="c#"><span class="k">const</span> <span class="kt">float</span> <span class="n">degreesPerHour</span> <span class="p">=</span> <span class="m">30f</span><span class="p">;</span></code></pre></figure>

<blockquote>
  <p>Что особенного в константах?</p>

  <p>Ключевое слово const обозначает что значение нашей переменной будет постоянно и его не нужно изменять. Как фундаментальные константы, которые существуют в реальном мире, такие как число Авогадро, постоянная Планка, число ПИ, число Эйлера и т.п. Особенность констант в том, что значение нашей константе присваивается в момент компиляции и не может быть изменено в процессы выполнения самой программы.</p>
</blockquote>

<p>Отлично, у нас есть строка, которая описывает то, как должен вращаться наш объект. Но если мы запустим сцену, то увидим, что ничего не произошло. Дело все в том, что мы не указали что именно мы хотим вращать. А вращать мы хотим часовую стрелку и вращать мы ее будем относительно ее центра координат. У нашего поля <code class="highlighter-rouge">hoursTransform</code> есть свойство, которое описывает поворот нашего объекта относительно центра координат <code class="highlighter-rouge">localRotation</code> и необходимо этому свойству присвоить значение, полученное нами выше. Как бы поворачиваем нашу часовую стрелку относительно начала координат на кватернион полученный из текущего значения часов, умноженные на угловой интервал расположения часовых отметок.</p>

<figure class="highlight"><pre><code class="language-c#" data-lang="c#"><span class="k">void</span> <span class="nf">Awake</span> <span class="p">()</span>
<span class="p">{</span>
<span class="n">hoursTransform</span><span class="p">.</span><span class="n">localRotation</span> <span class="p">=</span>
		<span class="n">Quaternion</span><span class="p">.</span><span class="nf">Euler</span><span class="p">(</span><span class="m">0f</span><span class="p">,</span> <span class="n">DateTime</span><span class="p">.</span><span class="n">Now</span><span class="p">.</span><span class="n">Hour</span> <span class="p">*</span> <span class="n">degreesPerHour</span><span class="p">,</span> <span class="m">0f</span><span class="p">);</span>
<span class="p">}</span></code></pre></figure>

<center>
<img src="\images\2018\01\GameObjectsAndScripts\hours-arm-rotated.png" />
</center>
<p><em><center>Часовая стрелка показывает 4 часа</center></em></p>

<p>Запустив нашу сцену, мы увидим, что наша часовая стрелка заняла правильное положение и отображает текущее значение часов. Давайте теперь сделаем все то же самое для минутной и секундной стрелки, но с не большим уточнением. Поскольку часовых отметок на часах 12, а минутных и секундных отметок 60, то стоит объявить для каждой стрелки свою константу, чтобы они вращались правильно. <script type="math/tex">360° / 60 = 6°</script> именно на столько градусов должна поворачиваться минутная и секундная стрелка.</p>

<figure class="highlight"><pre><code class="language-c#" data-lang="c#"><span class="k">const</span> <span class="kt">float</span>
	<span class="n">degreesPerHour</span> <span class="p">=</span> <span class="m">30f</span><span class="p">,</span>
	<span class="n">degreesPerMinute</span> <span class="p">=</span> <span class="m">6f</span><span class="p">,</span>
	<span class="n">degreesPerSecond</span> <span class="p">=</span> <span class="m">6f</span><span class="p">;</span>

	<span class="k">public</span> <span class="n">Transform</span> <span class="n">hoursTransform</span><span class="p">,</span> <span class="n">minutesTransform</span><span class="p">,</span> <span class="n">secondsTransform</span><span class="p">;</span>

	<span class="k">void</span> <span class="nf">Awake</span> <span class="p">()</span> <span class="p">{</span>
		<span class="n">hoursTransform</span><span class="p">.</span><span class="n">localRotation</span> <span class="p">=</span>
			<span class="n">Quaternion</span><span class="p">.</span><span class="nf">Euler</span><span class="p">(</span><span class="m">0f</span><span class="p">,</span> <span class="n">DateTime</span><span class="p">.</span><span class="n">Now</span><span class="p">.</span><span class="n">Hour</span> <span class="p">*</span> <span class="n">degreesPerHour</span><span class="p">,</span> <span class="m">0f</span><span class="p">);</span>
		<span class="n">minutesTransform</span><span class="p">.</span><span class="n">localRotation</span> <span class="p">=</span>
			<span class="n">Quaternion</span><span class="p">.</span><span class="nf">Euler</span><span class="p">(</span><span class="m">0f</span><span class="p">,</span> <span class="n">DateTime</span><span class="p">.</span><span class="n">Now</span><span class="p">.</span><span class="n">Minute</span> <span class="p">*</span> <span class="n">degreesPerMinute</span><span class="p">,</span> <span class="m">0f</span><span class="p">);</span>
		<span class="n">secondsTransform</span><span class="p">.</span><span class="n">localRotation</span> <span class="p">=</span>
			<span class="n">Quaternion</span><span class="p">.</span><span class="nf">Euler</span><span class="p">(</span><span class="m">0f</span><span class="p">,</span> <span class="n">DateTime</span><span class="p">.</span><span class="n">Now</span><span class="p">.</span><span class="n">Second</span> <span class="p">*</span> <span class="n">degreesPerSecond</span><span class="p">,</span> <span class="m">0f</span><span class="p">);</span>
	<span class="p">}</span></code></pre></figure>

<center>
<img src="\images\2018\01\GameObjectsAndScripts\all-arms-rotated.png" />
</center>
<p><em><center>Часы показывают 16:29:06</center></em></p>

<p>Теперь взглянем на наш код внимательно и увидим, что у нас <code class="highlighter-rouge">DateTime.Now</code> используется трижды для часов, минут и секунд. Чисто теоретически из-за того, что наше свойство вызывается трижды в разных строчках кода, то может возникнуть коллизия, связанная с задержкой выполнения какой-либо из строчки кода. Например, каким-то неведанным образом после того как выполнится ` DateTime.Now.Minute ` произойдет задержка в пару секунд, и следующая строка выполнится позже, а если это еще произойдет на 59 секунде, то наша минутная стрелка целую секунду будет показывать неправильное время.  Для того чтобы такого не случилось нужно чтобы при каждом вызове нашего метода ` Quaternion.Euler<code class="highlighter-rouge"> значение времени было одинаковым независимо от того, когда выполнится строчка кода, которая отвечает за поворот стрелки. Для этого объявим внутри метода </code>Awake` переменную в которую поместим текущее время.</p>

<figure class="highlight"><pre><code class="language-c#" data-lang="c#"><span class="k">void</span> <span class="nf">Awake</span> <span class="p">()</span>
 <span class="p">{</span>
	<span class="n">DateTime</span> <span class="n">time</span> <span class="p">=</span> <span class="n">DateTime</span><span class="p">.</span><span class="n">Now</span><span class="p">;</span>
	<span class="n">hoursTransform</span><span class="p">.</span><span class="n">localRotation</span> <span class="p">=</span>
		<span class="n">Quaternion</span><span class="p">.</span><span class="nf">Euler</span><span class="p">(</span><span class="m">0f</span><span class="p">,</span> <span class="n">time</span><span class="p">.</span><span class="n">Hour</span> <span class="p">*</span> <span class="n">degreesPerHour</span><span class="p">,</span> <span class="m">0f</span><span class="p">);</span>
	<span class="n">minutesTransform</span><span class="p">.</span><span class="n">localRotation</span> <span class="p">=</span>
		<span class="n">Quaternion</span><span class="p">.</span><span class="nf">Euler</span><span class="p">(</span><span class="m">0f</span><span class="p">,</span> <span class="n">time</span><span class="p">.</span><span class="n">Minute</span> <span class="p">*</span> <span class="n">degreesPerMinute</span><span class="p">,</span> <span class="m">0f</span><span class="p">);</span>
	<span class="n">secondsTransform</span><span class="p">.</span><span class="n">localRotation</span> <span class="p">=</span>
		<span class="n">Quaternion</span><span class="p">.</span><span class="nf">Euler</span><span class="p">(</span><span class="m">0f</span><span class="p">,</span> <span class="n">time</span><span class="p">.</span><span class="n">Second</span> <span class="p">*</span> <span class="n">degreesPerSecond</span><span class="p">,</span> <span class="m">0f</span><span class="p">);</span>
<span class="p">}</span></code></pre></figure>

<h2 id="26-Заводим-наши-часы"><strong>2.6 «Заводим» наши часы</strong></h2>
<p>Если вы из любопытства уже успели запустить нашу сцену, то вы заметили, что наши часы не идут. Они показали время, в которое был проинициализирован наш скрипт и остановились. Как будто их нужно завести для того чтобы они снова начали показывать актуальное время.</p>

<p>Для того чтобы завести наши часы, нужно чтобы наш код выполнялся не в момент инициализации компонента, а каждый кадр. Но подождите, что нам придется опять писать много сложно кода чтобы заставить наши часы отображать время? – Нет, в Unity есть готовая реализация как метода <code class="highlighter-rouge">Awake</code> так и метода, который вызывается каждый кадр и выполняет весь код что написан внутри него. Метод этот называется <code class="highlighter-rouge">Update</code>. И для того чтобы все заработало достаточно будет заменить <code class="highlighter-rouge">Awake</code> на <code class="highlighter-rouge">Update</code>.</p>

<figure class="highlight"><pre><code class="language-c#" data-lang="c#"><span class="k">void</span> <span class="nf">Update</span> <span class="p">()</span>
<span class="p">{</span>
	<span class="n">DateTime</span> <span class="n">time</span> <span class="p">=</span> <span class="n">DateTime</span><span class="p">.</span><span class="n">Now</span><span class="p">;</span>
	<span class="n">hoursTransform</span><span class="p">.</span><span class="n">localRotation</span> <span class="p">=</span>
		<span class="n">Quaternion</span><span class="p">.</span><span class="nf">Euler</span><span class="p">(</span><span class="m">0f</span><span class="p">,</span> <span class="n">time</span><span class="p">.</span><span class="n">Hour</span> <span class="p">*</span> <span class="n">degreesPerHour</span><span class="p">,</span> <span class="m">0f</span><span class="p">);</span>
	<span class="n">minutesTransform</span><span class="p">.</span><span class="n">localRotation</span> <span class="p">=</span>
		<span class="n">Quaternion</span><span class="p">.</span><span class="nf">Euler</span><span class="p">(</span><span class="m">0f</span><span class="p">,</span> <span class="n">time</span><span class="p">.</span><span class="n">Minute</span> <span class="p">*</span> <span class="n">degreesPerMinute</span><span class="p">,</span> <span class="m">0f</span><span class="p">);</span>
	<span class="n">secondsTransform</span><span class="p">.</span><span class="n">localRotation</span> <span class="p">=</span>
		<span class="n">Quaternion</span><span class="p">.</span><span class="nf">Euler</span><span class="p">(</span><span class="m">0f</span><span class="p">,</span> <span class="n">time</span><span class="p">.</span><span class="n">Second</span> <span class="p">*</span> <span class="n">degreesPerSecond</span><span class="p">,</span> <span class="m">0f</span><span class="p">);</span>
<span class="p">}</span></code></pre></figure>

<center>
<video class="video" id="video-cooperativeradiantichneumonfly" alt="Clock GIF" height="372" width="492" autoplay="" loop="" playsinline="" preload="auto" poster="https://thumbs.gfycat.com/CooperativeRadiantIchneumonfly-mobile.jpg" tabindex="-1"><source src="https://giant.gfycat.com/CooperativeRadiantIchneumonfly.webm" type="video/webm" /><source src="https://giant.gfycat.com/CooperativeRadiantIchneumonfly.mp4" type="video/mp4" /><meta itemprop="contentUrl" content="https://giant.gfycat.com/CooperativeRadiantIchneumonfly.mp4" /></video>
</center>
<p><em><center>Часы наконец-то показывают актуальное время</center></em></p>

<p>В случае если мы не хотим чтобы наш скрипт работал. Вместо того чтобы удалять компонент или править сам компонент, можно просто отключить наш компонент нажав на галочку рядом с именем нашего компонента</p>

<center>
<img src="\images\2018\01\GameObjectsAndScripts\enabled-toggle.png" />
</center>
<p><em><center>Компонент с включенным переключателем</center></em></p>

<p>## <strong>2.7 Непрерывное вращение</strong>
Сейчас наши стрелки часов двигаются с прерыванием. Но вы наверняка в рольном мире видели часы, в которых строки часов идут плавно без рывков. Давайте добавим маленькую фичу нашим часам.</p>

<p>Для этого создадим еще одно публичное поле в классе <code class="highlighter-rouge">Clock</code> и назовем его <code class="highlighter-rouge">continuous</code>. И поскольку это будет переключатель, который хранит в себе 2 состояния (плавное движение стрелок включено, плавное движение стрелок выключено), то объявим тип у этого поля <code class="highlighter-rouge">bool</code>.</p>

<figure class="highlight"><pre><code class="language-c#" data-lang="c#"><span class="k">public</span> <span class="n">Transform</span> <span class="n">hoursTransform</span><span class="p">,</span> <span class="n">minutesTransform</span><span class="p">,</span> <span class="n">secondsTransform</span><span class="p">;</span>

<span class="k">public</span> <span class="kt">bool</span> <span class="n">continuous</span><span class="p">;</span></code></pre></figure>

<p>Булева переменная может иметь всего 2 значения <code class="highlighter-rouge">true</code> или <code class="highlighter-rouge">false</code> (истина или ложь), которые соответствуют нашем случае положению включено и выключено. По умолчанию переменная типа <code class="highlighter-rouge">bool</code> имеет значение <code class="highlighter-rouge">false</code>, поэтому вернитесь в окно Unity и поставьте галочку.</p>

<center>
<img src="\images\2018\01\GameObjectsAndScripts\continuous-option.png" />
</center>
<p><em><center>Плавное вращение стрелок включено</center></em></p>

<p>Теперь нам нужно написать две разных реализации вращения стрелок. Но сначала не много подготовимся к этому. Продублируйте метод <code class="highlighter-rouge">Update</code> со всем имеющимся в нем кодом. Теперь у нас есть 2 метода <code class="highlighter-rouge">Update</code>. Переименуем их. Один назовем <code class="highlighter-rouge">UpdateContinuous</code>, второй <code class="highlighter-rouge">UpdateDiscrete</code>.</p>

<figure class="highlight"><pre><code class="language-c#" data-lang="c#"><span class="k">void</span> <span class="nf">UpdateContinuous</span> <span class="p">()</span> 
<span class="p">{</span>
		<span class="n">DateTime</span> <span class="n">time</span> <span class="p">=</span> <span class="n">DateTime</span><span class="p">.</span><span class="n">Now</span><span class="p">;</span>
		<span class="n">hoursTransform</span><span class="p">.</span><span class="n">localRotation</span> <span class="p">=</span>
			<span class="n">Quaternion</span><span class="p">.</span><span class="nf">Euler</span><span class="p">(</span><span class="m">0f</span><span class="p">,</span> <span class="n">time</span><span class="p">.</span><span class="n">Hour</span> <span class="p">*</span> <span class="n">degreesPerHour</span><span class="p">,</span> <span class="m">0f</span><span class="p">);</span>
		<span class="n">minutesTransform</span><span class="p">.</span><span class="n">localRotation</span> <span class="p">=</span>
			<span class="n">Quaternion</span><span class="p">.</span><span class="nf">Euler</span><span class="p">(</span><span class="m">0f</span><span class="p">,</span> <span class="n">time</span><span class="p">.</span><span class="n">Minute</span> <span class="p">*</span> <span class="n">degreesPerMinute</span><span class="p">,</span> <span class="m">0f</span><span class="p">);</span>
		<span class="n">secondsTransform</span><span class="p">.</span><span class="n">localRotation</span> <span class="p">=</span>
			<span class="n">Quaternion</span><span class="p">.</span><span class="nf">Euler</span><span class="p">(</span><span class="m">0f</span><span class="p">,</span> <span class="n">time</span><span class="p">.</span><span class="n">Second</span> <span class="p">*</span> <span class="n">degreesPerSecond</span><span class="p">,</span> <span class="m">0f</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">void</span> <span class="nf">UpdateDiscrete</span> <span class="p">()</span> 
<span class="p">{</span>
		<span class="n">DateTime</span> <span class="n">time</span> <span class="p">=</span> <span class="n">DateTime</span><span class="p">.</span><span class="n">Now</span><span class="p">;</span>
		<span class="n">hoursTransform</span><span class="p">.</span><span class="n">localRotation</span> <span class="p">=</span>
			<span class="n">Quaternion</span><span class="p">.</span><span class="nf">Euler</span><span class="p">(</span><span class="m">0f</span><span class="p">,</span> <span class="n">time</span><span class="p">.</span><span class="n">Hour</span> <span class="p">*</span> <span class="n">degreesPerHour</span><span class="p">,</span> <span class="m">0f</span><span class="p">);</span>
		<span class="n">minutesTransform</span><span class="p">.</span><span class="n">localRotation</span> <span class="p">=</span>
			<span class="n">Quaternion</span><span class="p">.</span><span class="nf">Euler</span><span class="p">(</span><span class="m">0f</span><span class="p">,</span> <span class="n">time</span><span class="p">.</span><span class="n">Minute</span> <span class="p">*</span> <span class="n">degreesPerMinute</span><span class="p">,</span> <span class="m">0f</span><span class="p">);</span>
		<span class="n">secondsTransform</span><span class="p">.</span><span class="n">localRotation</span> <span class="p">=</span>
			<span class="n">Quaternion</span><span class="p">.</span><span class="nf">Euler</span><span class="p">(</span><span class="m">0f</span><span class="p">,</span> <span class="n">time</span><span class="p">.</span><span class="n">Second</span> <span class="p">*</span> <span class="n">degreesPerSecond</span><span class="p">,</span> <span class="m">0f</span><span class="p">);</span>
<span class="p">}</span></code></pre></figure>

<p>Теперь создайте метод <code class="highlighter-rouge">Update</code> и давайте поговорим. Поскольку у нас есть переключатель, который хранит в себе 2 значения (включено и выключено) и мы хотим, чтобы при нажатии на эту кнопку режим отображения времени у нас менялся. Иначе говоря, если наше поле <code class="highlighter-rouge">continuous</code> имеет значение <code class="highlighter-rouge">true</code>, тогда вращать стрелки плавно, иначе вращать их с прерываниями.</p>

<figure class="highlight"><pre><code class="language-c#" data-lang="c#"><span class="k">void</span> <span class="nf">Update</span> <span class="p">()</span> 
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">continuous</span><span class="p">)</span> 
<span class="p">{</span>
		<span class="nf">UpdateContinuous</span><span class="p">();</span>
	<span class="p">}</span>
	<span class="k">else</span> 
<span class="p">{</span>
		<span class="nf">UpdateDiscrete</span><span class="p">();</span>
	<span class="p">}</span>
<span class="p">}</span></code></pre></figure>

<blockquote>
  <p>Где может быть объявлен метод Update?</p>

  <p>Внутри класса Clock. будет ли он расположен выше или ниже относительно других методов не имеет значения. Однако существует негласное правило, которое гласит что, каждый метод должен идти в порядке его выполнения. Это упрощает чтение и понимание ваше кода другими людьми. В нашем случае лучше всего расположить метод Update в самом верху, после него расположить метод UpdateContinuous, а после UpdateDiscrete, в соответствии с порядком вызова, который мы указали в методе Update.</p>
</blockquote>

<p>Не спешите пока запускать нашу сцену. Пока код в наших методах одинаковый и переключение не даст видимого эффекта. Для того чтобы все заработало нужно не много изменить наш метод ` UpdateContinuous`.</p>

<p>Класс <code class="highlighter-rouge">DateTime</code> не содержит в себе удобных дробных данных. Но к нашему счастью у него есть свойство TimeOfDay, которое содержит в себе значение типа <code class="highlighter-rouge">TimeSpan</code>, которое содержит в себе данные в нужном нам формате. А именно <code class="highlighter-rouge">TotalHours</code>, <code class="highlighter-rouge">TotalMinutes</code> и <code class="highlighter-rouge">TotalSeconds</code>.</p>

<figure class="highlight"><pre><code class="language-c#" data-lang="c#"><span class="k">void</span> <span class="nf">UpdateContinuous</span> <span class="p">()</span> 
<span class="p">{</span>
	<span class="n">TimeSpan</span> <span class="n">time</span> <span class="p">=</span> <span class="n">DateTime</span><span class="p">.</span><span class="n">Now</span><span class="p">.</span><span class="n">TimeOfDay</span><span class="p">;</span>
	<span class="n">hoursTransform</span><span class="p">.</span><span class="n">localRotation</span> <span class="p">=</span>
		<span class="n">Quaternion</span><span class="p">.</span><span class="nf">Euler</span><span class="p">(</span><span class="m">0f</span><span class="p">,</span> <span class="n">time</span><span class="p">.</span><span class="n">TotalHours</span> <span class="p">*</span> <span class="n">degreesPerHour</span><span class="p">,</span> <span class="m">0f</span><span class="p">);</span>
	<span class="n">minutesTransform</span><span class="p">.</span><span class="n">localRotation</span> <span class="p">=</span>
		<span class="n">Quaternion</span><span class="p">.</span><span class="nf">Euler</span><span class="p">(</span><span class="m">0f</span><span class="p">,</span> <span class="n">time</span><span class="p">.</span><span class="n">TotalMinutes</span> <span class="p">*</span> <span class="n">degreesPerMinute</span><span class="p">,</span> <span class="m">0f</span><span class="p">);</span>
	<span class="n">secondsTransform</span><span class="p">.</span><span class="n">localRotation</span> <span class="p">=</span>
		<span class="n">Quaternion</span><span class="p">.</span><span class="nf">Euler</span><span class="p">(</span><span class="m">0f</span><span class="p">,</span> <span class="n">time</span><span class="p">.</span><span class="n">TotalSeconds</span> <span class="p">*</span> <span class="n">degreesPerSecond</span><span class="p">,</span> <span class="m">0f</span><span class="p">);</span>
<span class="p">}</span></code></pre></figure>

<p>Кажется, что на этом все, но если мы сохраним наши изменения и вернемся в окно редактора, то увидим в консоли ошибку компиляции. Произошло это потому что наши значения аргументов имеют тип <em>double</em>. Это тот же самый тип <em>float</em> только хранить он в себе может в 2 раза больше значащих цифр после запятой. Ну и что? – Скажете вы. А дело все в том, что Unity работает только с типом <em>float</em> и нам придется под это подстроиться.</p>

<blockquote>
  <p>А достаточно ли точности в этом типе?</p>

  <p>Для большинства игр да. Проблемы начинают возникать тогда, когда вы начнете работать с очень большими рассеяниями или масштабами. Когда настанет такой момента, вам придется применять такие трюки как телепортация, чтобы сохранить локальную игровую зону в глобальных координатах. Хотя использование двойной точности решить эту проблему, это так же удвоит размер потребляемой памяти, что приведет к другим проблемам связанные с производительностью. Следовательно, лучше использовать float и прикручивать костыли по мере необходимости, нежели постоянно иметь проблему с производительностью.</p>
</blockquote>

<p>Решить данную проблему мы можем очень и очень просто путем преобразования значений наших аргументов в тип <em>float</em>. Это преобразование просто отбросит числа, которые не помещаются в 4 бита. Этот процесс называется принудительное приведение типов и делается он путем добавления круглых скобок перед нашим аргументом с написанным внутри значением типа переменной в который необходимо сделать преобразование.</p>

<figure class="highlight"><pre><code class="language-c#" data-lang="c#"><span class="n">hoursTransform</span><span class="p">.</span><span class="n">localRotation</span> <span class="p">=</span>
		<span class="n">Quaternion</span><span class="p">.</span><span class="nf">Euler</span><span class="p">(</span><span class="m">0f</span><span class="p">,</span> <span class="p">(</span><span class="kt">float</span><span class="p">)</span><span class="n">time</span><span class="p">.</span><span class="n">TotalHours</span> <span class="p">*</span> <span class="n">degreesPerHour</span><span class="p">,</span> <span class="m">0f</span><span class="p">);</span>
<span class="n">minutesTransform</span><span class="p">.</span><span class="n">localRotation</span> <span class="p">=</span>
		<span class="n">Quaternion</span><span class="p">.</span><span class="nf">Euler</span><span class="p">(</span><span class="m">0f</span><span class="p">,</span> <span class="p">(</span><span class="kt">float</span><span class="p">)</span><span class="n">time</span><span class="p">.</span><span class="n">TotalMinutes</span> <span class="p">*</span> <span class="n">degreesPerMinute</span><span class="p">,</span> <span class="m">0f</span><span class="p">);</span>
<span class="n">secondsTransform</span><span class="p">.</span><span class="n">localRotation</span> <span class="p">=</span>
		<span class="n">Quaternion</span><span class="p">.</span><span class="nf">Euler</span><span class="p">(</span><span class="m">0f</span><span class="p">,</span> <span class="p">(</span><span class="kt">float</span><span class="p">)</span><span class="n">time</span><span class="p">.</span><span class="n">TotalSeconds</span> <span class="p">*</span> <span class="n">degreesPerSecond</span><span class="p">,</span> <span class="m">0f</span><span class="p">);</span></code></pre></figure>

<center><video class="video" id="video-glitteringoilyfieldmouse" alt="Continuous Clock GIF" height="376" width="500" autoplay="" loop="" playsinline="" preload="auto" poster="https://thumbs.gfycat.com/GlitteringOilyFieldmouse-mobile.jpg" tabindex="-1"><source src="https://giant.gfycat.com/GlitteringOilyFieldmouse.webm" type="video/webm" /><source src="https://giant.gfycat.com/GlitteringOilyFieldmouse.mp4" type="video/mp4" /><meta itemprop="contentUrl" content="https://giant.gfycat.com/GlitteringOilyFieldmouse.mp4" /></video></center>
<p><em><center>Часы с плавным вращением стрелок</center></em></p>

<p>Скачать вариант сделаный автором можно по ссылке: <a href="http://catlikecoding.com/unity/tutorials/basics/game-objects-and-scripts/animating-the-clock/animating-the-clock.unitypackage">1.unitypackage</a></p>

<p>Скачать вариант сделанный переводчиком можно по ссылке: <a href="\content\2018\01\GameObjectsAndScripts\Clock.unitypackage">2.unitypackage</a></p>

<p>На этом все. Спасибо за внимание.</p>

<script id="dsq-count-scr" src="//https-vangogih-github-io.disqus.com/count.js" async=""></script>

<script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


        </article>
      </div>
    </div>
    <footer>
      <div class="owner">
      

       

	     
  <div id="disqus_thread"></div>
	<script>
		(function() { 
		var d = document, s = d.createElement('script');
		s.src = 'https://https-vangogih-github-io.disqus.com/embed.js';
		s.setAttribute('data-timestamp', +new Date());
		(d.head || d.body).appendChild(s);
		})();
	</script>
	<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
  
    </footer>
  </div>
  <div class="current-section">
    <a href="#top">Scroll to top</a>
    <p class="name"></p>
  </div>

  
  

</body>
</html>